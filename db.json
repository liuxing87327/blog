{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/coney/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":0},{"_id":"themes/coney/source/img/logo.svg","path":"img/logo.svg","modified":0},{"_id":"themes/coney/source/img/logo.jpg","path":"img/logo.jpg","modified":0},{"_id":"themes/coney/source/img/favicon.ico","path":"img/favicon.ico","modified":0},{"_id":"themes/coney/source/img/dots-2x.png","path":"img/dots-2x.png","modified":0},{"_id":"themes/coney/source/img/coney.png","path":"img/coney.png","modified":0},{"_id":"themes/coney/source/img/author.jpg","path":"img/author.jpg","modified":0},{"_id":"themes/coney/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0},{"_id":"themes/coney/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0},{"_id":"themes/coney/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0},{"_id":"themes/coney/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0},{"_id":"themes/coney/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0},{"_id":"themes/coney/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/coney/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/coney/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/coney/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/coney/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/coney/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/coney/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/coney/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/coney/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/coney/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/coney/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"source/images/xiulianzhidao.png","path":"images/xiulianzhidao.png","modified":0},{"_id":"source/images/websocket-01.png","path":"images/websocket-01.png","modified":0},{"_id":"source/images/liuxing.jpg","path":"images/liuxing.jpg","modified":0},{"_id":"source/images/jiagousheji/cover.jpg","path":"images/jiagousheji/cover.jpg","modified":0},{"_id":"source/images/jiagousheji/03.jpg","path":"images/jiagousheji/03.jpg","modified":0},{"_id":"source/images/jiagousheji/02.jpg","path":"images/jiagousheji/02.jpg","modified":0},{"_id":"source/images/jiagousheji/01.jpg","path":"images/jiagousheji/01.jpg","modified":0},{"_id":"source/images/bianchenghappy/04.png","path":"images/bianchenghappy/04.png","modified":0},{"_id":"source/images/bianchenghappy/03.png","path":"images/bianchenghappy/03.png","modified":0},{"_id":"source/images/bianchenghappy/02.png","path":"images/bianchenghappy/02.png","modified":0},{"_id":"source/images/bianchenghappy/01.png","path":"images/bianchenghappy/01.png","modified":0},{"_id":"source/LICENSE","path":"LICENSE","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":0}],"Cache":[{"_id":"source/404.html","shasum":"468385b3708e0c091347e17f25aaf0ac1165c156","modified":1433920115000},{"_id":"source/CNAME","shasum":"7b7ba814065271f7c13eec62f29f18db15e45ef1","modified":1434053465000},{"_id":"source/_posts/JS Hash对象.md","shasum":"bb37dbd9119822defdccfa998974fc70fbb99e38","modified":1433955303000},{"_id":"source/LICENSE","shasum":"30a6e0a424471d8ac874b5616dd5a18c45fd6046","modified":1434021915000},{"_id":"source/_posts/Java7 Try-with-resources (TWR).md","shasum":"e7f34ece044a2bae9f27b475b2b66eb4bbb5e9b4","modified":1434051684000},{"_id":"source/_posts/RestTemplate最佳实践.md","shasum":"3d3a9337d90267b2ffbf90089f18995ea4012093","modified":1434059058000},{"_id":"source/_posts/Windows 系统常用命令.md","shasum":"60cd5efe74bcf76737335af6384f9d933d136174","modified":1434010185000},{"_id":"source/_posts/faqs.md","shasum":"a4fe454a5cd603876bd8fe5fa277516d5cd98179","modified":1433995843000},{"_id":"source/_posts/java和数据库计算两个坐标的距离.md","shasum":"0cbd1772702d6b2581c72222048937272ac51d32","modified":1434056637000},{"_id":"source/_posts/jquery常用选择器.md","shasum":"4e910ea5af04472ebe05576f0f47d293d03429eb","modified":1433955303000},{"_id":"source/_posts/spring4.x不兼容ibatis的解决方法 .md","shasum":"062e23bbaf0550d3f0f4ff8569b4211126e0dc23","modified":1433955303000},{"_id":"source/_posts/linux软件的安装、更新与卸载.md","shasum":"05bbf6873541d0faa84048d42c6f277e903dc7f6","modified":1434010189000},{"_id":"source/_posts/websocket-demo.md","shasum":"64f1547e2953bf5ff5d3480605dca138edddd6be","modified":1433955303000},{"_id":"source/_posts/使用jmagick将CMYK转换为RGB.md","shasum":"0eb3ea1b35a2d0b3e263190573347ece9360b449","modified":1433955303000},{"_id":"source/_posts/一个简单的百度地图示例.md","shasum":"3581444d6aba5a15e9c2621bf2336b20193c6713","modified":1433955303000},{"_id":"source/_posts/优秀的开发者 vs. 差的开发者.md","shasum":"5f6fc78af4042fe0b49fa2e923a8fb8c069f413c","modified":1433955303000},{"_id":"source/_posts/使用pinyin4j将中文转换为拼音.md","shasum":"bd8dc18630141c46954d68967ef67188b329bd42","modified":1433955303000},{"_id":"source/_posts/使用spring4.x的websocket支持.md","shasum":"571b8561fd78f1110286860f5b9dd9bf4f80158a","modified":1434054704000},{"_id":"source/_posts/引入公共头部时，控制引入js、css、title.md","shasum":"fc249d6808b9d4aef7909985589871f86ae2a423","modified":1433955303000},{"_id":"source/_posts/在windows和linux上安装ImageMagick与Jmagick.md","shasum":"2bbd90ffea34ba49856ae77ec00ca266c1ead793","modified":1434010541000},{"_id":"source/_posts/谷歌地图坐标转换百度地图坐标 .md","shasum":"4053ce4fde48ebaae95dc0981e41ccc8e30a259a","modified":1433955303000},{"_id":"source/_posts/计算地图坐标是否在多边形内.md","shasum":"2552cf42ece5a434ca607e77fbfba1cb86f277e9","modified":1433955303000},{"_id":"source/_posts/我编程我快乐.md","shasum":"e45e2cc5301e1724fc22d97dfd666440e17e8618","modified":1434057843000},{"_id":"source/_posts/美到极致是疯狂.md","shasum":"5a45a44c5e2458b67695e2789e831b273292d9ca","modified":1433955303000},{"_id":"source/_posts/面向对象js.md","shasum":"c0367ed036bb0a4d57ab45613eedf431d8a5b33a","modified":1433955303000},{"_id":"source/_posts/逐步改善，设计优秀的API.md","shasum":"508d53cf6c112f399bca7a844ccc83d380f9640b","modified":1434077126000},{"_id":"source/categories/index.md","shasum":"2e19a36488900a8298812ac3680c74432ba8fc05","modified":1433870645000},{"_id":"source/about/index.md","shasum":"d22a62ff068aaa6085e3061fd46426b90204595f","modified":1433875108000},{"_id":"source/images/jiagousheji/01.jpg","shasum":"b7f470974974e00a0771a4fe978afdd78e10a2e2","modified":1433955303000},{"_id":"source/images/jiagousheji/02.jpg","shasum":"5899c5b35944a6080d7af0e7491167ad161f54d6","modified":1433955303000},{"_id":"source/images/jiagousheji/03.jpg","shasum":"adc4e40e915dc6057fac30f87151f24378cb8de3","modified":1433955303000},{"_id":"source/images/jiagousheji/cover.jpg","shasum":"f152679edd67731dabe9c239f2212514c7ef2b00","modified":1433955303000},{"_id":"source/images/liuxing.jpg","shasum":"2897a4a5c849a63bd7bab0da05e75b5e922e337d","modified":1433995200000},{"_id":"source/images/websocket-01.png","shasum":"f579ad7633de3725ff9699441e77c8d2c8545479","modified":1433955303000},{"_id":"source/tags/index.md","shasum":"fc88de6a4b24223a3bc68e4a9115cd9908673ff6","modified":1433870650000},{"_id":"source/search/index.md","shasum":"599729654c9a70c52f734beef077e2afec040330","modified":1434003041000},{"_id":"source/images/bianchenghappy/02.png","shasum":"62a58af47e6631ec605149454e4e52c3be17be1b","modified":1434057669000},{"_id":"source/images/bianchenghappy/04.png","shasum":"9827115dab83b6b7fa5293046bfb5754c4aaafed","modified":1434057684000},{"_id":"source/images/bianchenghappy/03.png","shasum":"f66609f92b919fa03739fb56a24186d27c8cbd0f","modified":1434057679000},{"_id":"themes/coney/LICENSE","shasum":"a12a2dc681f818facc310fa916aa5fd17c781aa6","modified":1433868217000},{"_id":"themes/coney/README.md","shasum":"34d4db9e0bb3846ff3db6183a687e6999e57a5b6","modified":1433868217000},{"_id":"themes/coney/languages/default.yml","shasum":"7bb3eb60c1cf8f96f9007487414bd376cef90766","modified":1433872044000},{"_id":"themes/coney/_config.yml","shasum":"5b781e06baf68c079bfaf6ece50f4d775b367eaf","modified":1434077865000},{"_id":"themes/coney/languages/zh-CN.yml","shasum":"772c90ef1b8e9a3e9a16fa4e670298b56f643473","modified":1433955749000},{"_id":"themes/coney/languages/zh-TW.yml","shasum":"65fb760b034ecba21bd705c91bf991d88bcf8d5e","modified":1433955753000},{"_id":"themes/coney/layout/_partial/archive.ejs","shasum":"aa3e66bb3b0249460ecc96ca9787c7e2f8e736b5","modified":1433868217000},{"_id":"themes/coney/layout/_partial/after_footer.ejs","shasum":"ddcfb1e948c7e82d94d11781505191813948928f","modified":1433992563000},{"_id":"themes/coney/layout/_partial/article.ejs","shasum":"3e04fa6779042982a80bb9607805c3bf0ebd66b0","modified":1433955303000},{"_id":"themes/coney/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1433868217000},{"_id":"themes/coney/layout/_partial/cnzz_analytics.ejs","shasum":"fbe0a43115b4ddcf318d20f34de88aef91766f9b","modified":1433880082000},{"_id":"themes/coney/layout/_partial/head.ejs","shasum":"b6c96820fa64a4e280295daa533d516bfb41e5ba","modified":1434091379000},{"_id":"themes/coney/layout/_partial/baidu_analytics.ejs","shasum":"27bad7f09baee31c5159319b848f8f68ca3525b6","modified":1433919529000},{"_id":"themes/coney/layout/_partial/footer.ejs","shasum":"7ef11dbd8420c7f20f4817d84cd9e015b4200b83","modified":1433879928000},{"_id":"themes/coney/layout/_partial/google_analytics.ejs","shasum":"b6871f67c87c87acb5295ce4fb673b16a7296a01","modified":1433868217000},{"_id":"themes/coney/layout/_partial/header.ejs","shasum":"1715647c561f98471b686106b1d704d04b272a5e","modified":1434001822000},{"_id":"themes/coney/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1433868217000},{"_id":"themes/coney/layout/_partial/post/article.ejs","shasum":"3facf363563c349aa0007c4d2064382068f8fe12","modified":1433936917000},{"_id":"themes/coney/layout/_partial/post/catetags.ejs","shasum":"f6b107078094333b6567d4a97700f559159675e1","modified":1433868217000},{"_id":"themes/coney/layout/_partial/post/comment.ejs","shasum":"13d8720b311ddee20c4d29154cd8a460125e7a6c","modified":1433868217000},{"_id":"themes/coney/layout/_partial/post/footer.ejs","shasum":"a9aeae612eb7085bbe74bd12086198320e6c3702","modified":1433868217000},{"_id":"themes/coney/layout/_partial/post/gallery.ejs","shasum":"7ca5b1db9439be61a8b77f6f7d857b56fdf1517f","modified":1433868217000},{"_id":"themes/coney/layout/_partial/post/header.ejs","shasum":"73aa8a410cc80277930acaec23003c30eeac6d79","modified":1433868217000},{"_id":"themes/coney/layout/_partial/post/pagination.ejs","shasum":"2dfe2b1f322b707179685a492e21a3b603fcfaf2","modified":1433945477000},{"_id":"themes/coney/layout/_partial/post/jiathis.ejs","shasum":"adc047d2bbd031092df86f3be2866ea9c3b5f3c9","modified":1433868217000},{"_id":"themes/coney/layout/_partial/search.ejs","shasum":"5fa605ced95fbf67f46fa62e6a26a348f42dcd07","modified":1434003298000},{"_id":"themes/coney/layout/_partial/sidebar.ejs","shasum":"3298799a7c787164f4efadeed24f33d92cbcc9da","modified":1433868217000},{"_id":"themes/coney/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1433868217000},{"_id":"themes/coney/layout/_widget/links.ejs","shasum":"ea4d4edcba185144246fd2315854519f6f2afa83","modified":1433881349000},{"_id":"themes/coney/layout/_widget/category.ejs","shasum":"9b4cc6be18aa6c5da4cf45913d5be83fc33081db","modified":1433868217000},{"_id":"themes/coney/layout/_widget/recent_comments.ejs","shasum":"3a475f29c4fa7dcb1bea0c0b8aa645fad2db168f","modified":1433868217000},{"_id":"themes/coney/layout/_widget/archive.ejs","shasum":"07443d9617611d51caba34d3b536ff34c4ecde5e","modified":1433868217000},{"_id":"themes/coney/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1433868217000},{"_id":"themes/coney/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1433868217000},{"_id":"themes/coney/layout/_widget/tag.ejs","shasum":"cc97db230f727c27519298166ad904358811fb53","modified":1433868217000},{"_id":"themes/coney/layout/_widget/recent_posts.ejs","shasum":"95085ee0c58a9d9ee1c1465681211763225aa4e9","modified":1433868217000},{"_id":"themes/coney/layout/archive.ejs","shasum":"b4fd8369c1480e4ad283be5947648630e8e7cc01","modified":1433868217000},{"_id":"themes/coney/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1433868217000},{"_id":"themes/coney/layout/index.ejs","shasum":"cbca1720a7e4c94233e17b45f0b46ab4fac5b765","modified":1433868217000},{"_id":"themes/coney/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1433868217000},{"_id":"themes/coney/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1433868217000},{"_id":"themes/coney/layout/layout.ejs","shasum":"8a86db06f8ec21c237930d37fa340f9638762dae","modified":1433921311000},{"_id":"themes/coney/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1433868217000},{"_id":"themes/coney/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1433868217000},{"_id":"themes/coney/package.json","shasum":"00357ef6f24eb049074da81809e98f973f528cca","modified":1433868217000},{"_id":"themes/coney/source/css/_base/code.styl","shasum":"cb95523618d6fc20b295078c82dea538fab7fdb3","modified":1434091483000},{"_id":"themes/coney/source/css/_base/font.styl","shasum":"75f264bc742888dbe192e8d19eda70705d13c709","modified":1433868217000},{"_id":"themes/coney/source/css/_base/public.styl","shasum":"268411cd2b852cc808e1a5affb2aaac2983a52d3","modified":1434090880000},{"_id":"themes/coney/source/css/_base/variable.styl","shasum":"daa6bc3ce8d58e6bcbfc66eca73a7cce64dd425d","modified":1434091977000},{"_id":"themes/coney/source/css/_partial/article.styl","shasum":"7b6f94fdf032f3e831181dd95386927c19a64691","modified":1434092288000},{"_id":"themes/coney/source/css/_partial/aside.styl","shasum":"d0d8f68cae0dd59d34b5f1f470acf573b166d4de","modified":1433868217000},{"_id":"themes/coney/source/css/_partial/body","shasum":"aee4dc75b8f32310889c33f61e33c2b2e7f942b7","modified":1433938810000},{"_id":"themes/coney/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1433868217000},{"_id":"themes/coney/source/css/_partial/footer.styl","shasum":"a84eba588408c654777f675df8bb2eb60a5d0f1c","modified":1433868217000},{"_id":"themes/coney/source/css/_partial/gallery.styl","shasum":"a544a58fdb4c8dd8274159323abd1e38cb03215e","modified":1433868217000},{"_id":"themes/coney/source/css/_partial/header.styl","shasum":"99bc986a365bc0056b92a4757707ff97d6a18450","modified":1433938805000},{"_id":"themes/coney/source/css/_partial/helper.styl","shasum":"52d4ee51b7087c2c2a7e7ded6f63270165d9de89","modified":1433868217000},{"_id":"themes/coney/source/css/_partial/index.styl","shasum":"f1e6b8843bfe1a7fbdcf018e95780b819aa32ab3","modified":1433868217000},{"_id":"themes/coney/source/css/style.styl","shasum":"5f47cf3378efa79ab9c72669eb60468212e8cb5a","modified":1433944828000},{"_id":"themes/coney/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1433868217000},{"_id":"themes/coney/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1433868217000},{"_id":"themes/coney/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1433868217000},{"_id":"themes/coney/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1433868217000},{"_id":"themes/coney/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1433868217000},{"_id":"themes/coney/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1433868217000},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1433868217000},{"_id":"themes/coney/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1433868217000},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1433868217000},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1433868217000},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1433868217000},{"_id":"themes/coney/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1433868217000},{"_id":"themes/coney/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1433868217000},{"_id":"themes/coney/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1433868217000},{"_id":"themes/coney/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1433868217000},{"_id":"themes/coney/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1433868217000},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1433868217000},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1433868217000},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1433868217000},{"_id":"themes/coney/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1433868217000},{"_id":"themes/coney/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1433868217000},{"_id":"themes/coney/source/img/author.jpg","shasum":"5d53bfe75d7aa0b4c49c4e1343a2410b3985f9f9","modified":1433868217000},{"_id":"themes/coney/source/img/coney.png","shasum":"2988bf2f10477ef8aa86fcae0d21790d7afebfba","modified":1433868217000},{"_id":"themes/coney/source/img/favicon.ico","shasum":"0c57dd7d0944b74be20dc99f1e6f77362ba0ed24","modified":1433868217000},{"_id":"themes/coney/source/img/logo.jpg","shasum":"2897a4a5c849a63bd7bab0da05e75b5e922e337d","modified":1433872200000},{"_id":"themes/coney/source/img/dots-2x.png","shasum":"2d900f9f8a0b53067401138d8cb411c83e747e8e","modified":1433868217000},{"_id":"themes/coney/source/img/logo.svg","shasum":"0eb0ae32d95c6f0b14adb9ab491775dcd1da3af3","modified":1433868217000},{"_id":"themes/coney/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1433868217000},{"_id":"themes/coney/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1433868217000},{"_id":"source/images/bianchenghappy/01.png","shasum":"d3bbaab300ca4d1ac11e4525a7a41cc450b69640","modified":1434057655000},{"_id":"themes/coney/source/js/jquery-2.1.0.min.js","shasum":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1433868217000},{"_id":"themes/coney/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1433868217000},{"_id":"source/images/xiulianzhidao.png","shasum":"56bd25d35baf2c7c614188a65c51bc80b9e74fbd","modified":1434051031000},{"_id":"public/js/jquery-2.1.0.min.js","modified":1434091195034,"shasum":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f"},{"_id":"public/img/logo.svg","modified":1434091195045,"shasum":"0eb0ae32d95c6f0b14adb9ab491775dcd1da3af3"},{"_id":"public/img/logo.jpg","modified":1434091195051,"shasum":"2897a4a5c849a63bd7bab0da05e75b5e922e337d"},{"_id":"public/img/favicon.ico","modified":1434091195053,"shasum":"0c57dd7d0944b74be20dc99f1e6f77362ba0ed24"},{"_id":"public/img/dots-2x.png","modified":1434091195054,"shasum":"2d900f9f8a0b53067401138d8cb411c83e747e8e"},{"_id":"public/img/coney.png","modified":1434091195056,"shasum":"2988bf2f10477ef8aa86fcae0d21790d7afebfba"},{"_id":"public/img/author.jpg","modified":1434091195060,"shasum":"5d53bfe75d7aa0b4c49c4e1343a2410b3985f9f9"},{"_id":"public/font/fontawesome-webfont.woff","modified":1434091195062,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/font/fontawesome-webfont.ttf","modified":1434091195065,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/font/fontawesome-webfont.svg","modified":1434091195069,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/font/fontawesome-webfont.eot","modified":1434091195073,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/font/coveredbyyourgrace-webfont.woff","modified":1434091195078,"shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e"},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","modified":1434091195079,"shasum":"194ccb4acf77a03dc25bcc174edb266143704fec"},{"_id":"public/font/coveredbyyourgrace-webfont.svg","modified":1434091195084,"shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53"},{"_id":"public/font/coveredbyyourgrace-webfont.eot","modified":1434091195088,"shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de"},{"_id":"public/font/FontAwesome.otf","modified":1434091195090,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1434091195093,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1434091195095,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1434091195097,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1434091195099,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1434091195102,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1434091195104,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1434091195107,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1434091195109,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1434091195111,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1434091195114,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1434091195116,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1434091195118,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1434091195121,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1434091195143,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1434091195146,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1434091196185,"shasum":"7eaa375599d76372fbaf5c6116f697736e2236ad"},{"_id":"public/images/xiulianzhidao.png","modified":1434091196705,"shasum":"56bd25d35baf2c7c614188a65c51bc80b9e74fbd"},{"_id":"public/images/websocket-01.png","modified":1434091196717,"shasum":"f579ad7633de3725ff9699441e77c8d2c8545479"},{"_id":"public/images/liuxing.jpg","modified":1434091196720,"shasum":"2897a4a5c849a63bd7bab0da05e75b5e922e337d"},{"_id":"public/images/jiagousheji/cover.jpg","modified":1434091196723,"shasum":"f152679edd67731dabe9c239f2212514c7ef2b00"},{"_id":"public/images/jiagousheji/03.jpg","modified":1434091196727,"shasum":"adc4e40e915dc6057fac30f87151f24378cb8de3"},{"_id":"public/images/jiagousheji/02.jpg","modified":1434091196729,"shasum":"5899c5b35944a6080d7af0e7491167ad161f54d6"},{"_id":"public/images/jiagousheji/01.jpg","modified":1434091196731,"shasum":"b7f470974974e00a0771a4fe978afdd78e10a2e2"},{"_id":"public/images/bianchenghappy/04.png","modified":1434091196734,"shasum":"9827115dab83b6b7fa5293046bfb5754c4aaafed"},{"_id":"public/images/bianchenghappy/03.png","modified":1434091196740,"shasum":"f66609f92b919fa03739fb56a24186d27c8cbd0f"},{"_id":"public/images/bianchenghappy/02.png","modified":1434091196742,"shasum":"62a58af47e6631ec605149454e4e52c3be17be1b"},{"_id":"public/images/bianchenghappy/01.png","modified":1434091196745,"shasum":"d3bbaab300ca4d1ac11e4525a7a41cc450b69640"},{"_id":"public/LICENSE","modified":1434091196748,"shasum":"30a6e0a424471d8ac874b5616dd5a18c45fd6046"},{"_id":"public/CNAME","modified":1434091196762,"shasum":"7b7ba814065271f7c13eec62f29f18db15e45ef1"},{"_id":"public/404.html","modified":1434091413739,"shasum":"a175bd3e911987be89e4e04387c9d1e386ee90c5"},{"_id":"public/tags/index.html","modified":1434091413752,"shasum":"0ff177c4e0170e888031b76a52c6c8253685cb3e"},{"_id":"public/search/index.html","modified":1434091413761,"shasum":"c2346d4750a834752381cc148cf4ae3826cb4cdc"},{"_id":"public/css/custom.css","modified":1434091196857,"shasum":"ac082b3ce8b820c418415d69ea6ade40eb1b307e"},{"_id":"public/categories/index.html","modified":1434091413777,"shasum":"4f21b48ef7246589c22c5940b49abbf2d652b9fb"},{"_id":"public/about/index.html","modified":1434091413783,"shasum":"64644f4af4b3a9f7c98638d90b947a2b91b43aaf"},{"_id":"public/2015/05/21/RestTemplate最佳实践/index.html","modified":1434091413846,"shasum":"d2ffd225d7f57fc57556b19005bdf20c44dc257f"},{"_id":"public/2015/04/21/使用spring4.x的websocket支持/index.html","modified":1434091413897,"shasum":"8e13f911a40d53754a996bfc2f8544bf36cfb7ce"},{"_id":"public/2015/04/21/spring4.x不兼容ibatis的解决方法 /index.html","modified":1434091413923,"shasum":"5a185086682f4d90c6b79c873927e93246bbae73"},{"_id":"public/2015/04/21/计算地图坐标是否在多边形内/index.html","modified":1434091413949,"shasum":"b6a11c3000cab27938b53f8703f6483d6883c672"},{"_id":"public/2015/04/21/java和数据库计算两个坐标的距离/index.html","modified":1434091413982,"shasum":"ced76beb20949765797f57abd2fa5b62c8d29c84"},{"_id":"public/2015/02/09/websocket-demo/index.html","modified":1434091414031,"shasum":"a9ffa1443aa8ef7e0913fa7ebefb15ec3f5396c2"},{"_id":"public/2015/02/01/jquery常用选择器/index.html","modified":1434091414050,"shasum":"8095c2e7475658dcd708ed9ee0ce7905b85d1cef"},{"_id":"public/2015/01/01/faqs/index.html","modified":1434091414069,"shasum":"43d64c2ecdab574d69bfe4f9a41d9c47c6caf515"},{"_id":"public/2014/12/10/我编程我快乐/index.html","modified":1434091414093,"shasum":"6aa88c8b8c8de26283c30938c330cca63049049e"},{"_id":"public/2014/09/25/Java7 Try-with-resources (TWR)/index.html","modified":1434091414126,"shasum":"86dfce5921ec02455ffcc57578e7b821f6d8b43c"},{"_id":"public/2014/04/25/linux软件的安装、更新与卸载/index.html","modified":1434091414152,"shasum":"e0498a2ea31ce8dcec51de33b2869db29be7481e"},{"_id":"public/2014/03/20/Windows 系统常用命令/index.html","modified":1434091414175,"shasum":"f42664c9ac97def184083cd2babdd00c469e4759"},{"_id":"public/2013/12/20/在windows和linux上安装ImageMagick与Jmagick/index.html","modified":1434091414221,"shasum":"257be0ffe117a8c295901677750fc40218ad6fbf"},{"_id":"public/2013/05/23/使用jmagick将CMYK转换为RGB/index.html","modified":1434091414239,"shasum":"a32c97b0fba9b67e78773b8461c9792e1c9c6451"},{"_id":"public/2012/09/08/一个简单的百度地图示例/index.html","modified":1434091414272,"shasum":"434c0e8f9a4c7a5e778856a106ff185fc853ed98"},{"_id":"public/2012/09/08/JS Hash对象/index.html","modified":1434091414296,"shasum":"9477ba42dba640b31f0d930c3485e3d5e182dcf4"},{"_id":"public/2012/08/16/使用pinyin4j将中文转换为拼音/index.html","modified":1434091414335,"shasum":"60fd6444e23788a666a2c6fdb93331bc792a0448"},{"_id":"public/2012/08/16/谷歌地图坐标转换百度地图坐标 /index.html","modified":1434091414358,"shasum":"1791cfae5fe5567cfcb937e7114e36607133337b"},{"_id":"public/2012/08/16/引入公共头部时，控制引入js、css、title/index.html","modified":1434091414389,"shasum":"393aec6a0443e4ca69787320456faba2fa997899"},{"_id":"public/2012/07/04/美到极致是疯狂/index.html","modified":1434091414411,"shasum":"488448f66b462e1c4e4f021c82ad5c0d4f55299b"},{"_id":"public/2012/07/04/逐步改善，设计优秀的API/index.html","modified":1434091414428,"shasum":"30dd9b0efede3abf2e6ffc9172274bd13626d5b7"},{"_id":"public/2012/07/04/面向对象js/index.html","modified":1434091414448,"shasum":"ea6111b68350f8c63cede8801c6a0f6f9fd3d285"},{"_id":"public/2012/07/04/优秀的开发者 vs. 差的开发者/index.html","modified":1434091414468,"shasum":"c8a92f71c16c1354213142a810054bb64615be71"},{"_id":"public/archives/index.html","modified":1434091414486,"shasum":"6fb791f3bbe1df5665587fd19c5b67536895b95f"},{"_id":"public/archives/page/2/index.html","modified":1434091414497,"shasum":"5630e34246e1a49256f3048ff47db4201699dafd"},{"_id":"public/archives/page/3/index.html","modified":1434091414508,"shasum":"731deb2209aa3e5c7f73dafcd4cde9ab4c268b7d"},{"_id":"public/archives/2012/index.html","modified":1434091414528,"shasum":"845a8a9fa8cbdfa16e22d0fe8b2df39bbff070c7"},{"_id":"public/archives/2012/07/index.html","modified":1434091414535,"shasum":"ff33d61c767c168ea58ace69ad5b5c2f91d48b2b"},{"_id":"public/archives/2012/08/index.html","modified":1434091414545,"shasum":"21dc3fa3da88ecd87537915198c1f3e6d0e0869f"},{"_id":"public/archives/2012/09/index.html","modified":1434091414552,"shasum":"46da71a33e2cd08543139e4219a4238f5eef78ac"},{"_id":"public/archives/2013/index.html","modified":1434091414560,"shasum":"0d1de71ad4d14d316f527cfe15b4d746eb3b8a8e"},{"_id":"public/archives/2013/05/index.html","modified":1434091414569,"shasum":"7ee2298e84bed35f88884294c34a571eb170c419"},{"_id":"public/archives/2013/12/index.html","modified":1434091414580,"shasum":"260f3b496ecfe4b5db8c552bcfb0b9237b4862fb"},{"_id":"public/archives/2014/index.html","modified":1434091414587,"shasum":"44b91570cab5ea3652cd5afc23f202dfc0c4a788"},{"_id":"public/archives/2014/03/index.html","modified":1434091414596,"shasum":"ab5154ea377dbcf6a9c501ab73ea7274b5c49a07"},{"_id":"public/archives/2014/04/index.html","modified":1434091414604,"shasum":"0ccb2fc130ce7503e0dded53d2542780146c8463"},{"_id":"public/archives/2014/09/index.html","modified":1434091414613,"shasum":"da93cba1292116805588b5fc0dffddcc80c00430"},{"_id":"public/archives/2014/12/index.html","modified":1434091414621,"shasum":"df6b8af9a4bfc1c4bdf4dd79698948291331430f"},{"_id":"public/archives/2015/index.html","modified":1434091414633,"shasum":"ab0eb37f6284577ab950c890fad1395c8b62410f"},{"_id":"public/archives/2015/01/index.html","modified":1434091414644,"shasum":"3910f20cd3465815bd8520804ab6cf197f64672c"},{"_id":"public/archives/2015/02/index.html","modified":1434091414656,"shasum":"211af5d7ce5d73f3340997384a9fc759c87da6b0"},{"_id":"public/archives/2015/04/index.html","modified":1434091414673,"shasum":"be4cd475fc252d3ac758035b5f75f67f2e68c00d"},{"_id":"public/archives/2015/05/index.html","modified":1434091414682,"shasum":"77068a8d308b20126f0ec7ad6ec59298d97df8c6"},{"_id":"public/categories/前端/index.html","modified":1434091414861,"shasum":"e0d56510fcd230bf5ca6a90ecb038302854fa6b6"},{"_id":"public/categories/心态/index.html","modified":1434091414866,"shasum":"5fc384caf99c298512fe30ecebfac8b9260b1e17"},{"_id":"public/categories/Java/index.html","modified":1434091414878,"shasum":"5a23f8c8dde15bbbd601500029941b90de18285f"},{"_id":"public/categories/Java/page/2/index.html","modified":1434091414884,"shasum":"0e599bf2cb9eeb6504232c9452cdb1009a339cb6"},{"_id":"public/categories/书摘/index.html","modified":1434091414889,"shasum":"32a76ad2275d18d1e230c6fffa6bbed4e73efaf8"},{"_id":"public/categories/系统配置/index.html","modified":1434091414896,"shasum":"e02425efd68b6d9485af8936fcfe397dc29733ac"},{"_id":"public/categories/其他/index.html","modified":1434091414900,"shasum":"0e5a3f65160e771fbb0f5aa15b056fe7bdf0a107"},{"_id":"public/atom.xml","modified":1434091197919,"shasum":"9a9dc410ce568e63226d069669e63ff3e2b9337e"},{"_id":"public/index.html","modified":1434091414828,"shasum":"c075cde284dc6ed6a55087e19c39ae65bd7d063c"},{"_id":"public/page/2/index.html","modified":1434091414843,"shasum":"114138ca8076c1ac46d26948fadb433eb9a60d6b"},{"_id":"public/page/3/index.html","modified":1434091414855,"shasum":"5a522fb59d3714a327aeb26ceee22518cbfbd036"},{"_id":"public/tags/js/index.html","modified":1434091414690,"shasum":"b1385b53ebd09f2c19d07253d027068b658a7f05"},{"_id":"public/tags/地图/index.html","modified":1434091414696,"shasum":"7f887bff74495165f43cd8d0b157bc9298b5e72d"},{"_id":"public/tags/编程/index.html","modified":1434091414703,"shasum":"29181774a954aa24b9e65f9037544a04c7aac4a5"},{"_id":"public/tags/心态/index.html","modified":1434091414708,"shasum":"59f6ab67d549250ed49c63ce9c81d758fc0df408"},{"_id":"public/tags/职业发展/index.html","modified":1434091414713,"shasum":"9a64c0497b88edbfe7e79b8ab09cc34bbce1748a"},{"_id":"public/tags/jmagick/index.html","modified":1434091414719,"shasum":"0dc650c6a46e5fb5ea05eb8c34e7a39ab68ac46b"},{"_id":"public/tags/linux/index.html","modified":1434091414724,"shasum":"0046966681a8d038cffb8522c96aed9b914fb4f2"},{"_id":"public/tags/windows/index.html","modified":1434091414731,"shasum":"1d74e8dfc970c447294060308083c8033c820bcb"},{"_id":"public/tags/spring/index.html","modified":1434091414735,"shasum":"9612403636a52ded310f4b1081c18b09cd4dbc1b"},{"_id":"public/tags/websocket/index.html","modified":1434091414741,"shasum":"918299889f1be41eb476518dc8d190f7c1886ac5"},{"_id":"public/tags/pinyin4j/index.html","modified":1434091414748,"shasum":"5f87e3df0784f17c95152ae5acd34c8ac67ac6b6"},{"_id":"public/tags/框架/index.html","modified":1434091414756,"shasum":"c1a3fd715b51b93188556895d61980fe80d594a5"},{"_id":"public/tags/ibatis/index.html","modified":1434091414760,"shasum":"831a5d20551b68e2d5c432bdba83923e1f615830"},{"_id":"public/tags/jquery/index.html","modified":1434091414767,"shasum":"44d73d3a2e77292fc890c2960a875d567096c57c"},{"_id":"public/tags/坐标运算/index.html","modified":1434091414772,"shasum":"ce8609f3dcf12d80aa3ae4a65cf56b1f0efc811f"},{"_id":"public/tags/距离/index.html","modified":1434091414780,"shasum":"6fb902f8c6947841f02e2f9dd3dc3e9e18dc0ab3"},{"_id":"public/tags/RestTemplate/index.html","modified":1434091414785,"shasum":"8e7f05288dbfc21a10b4433462b9e79a912a798f"},{"_id":"public/tags/HttpClient/index.html","modified":1434091414793,"shasum":"e8af8df38b8ac0a951d78255e59a4f6217af7549"},{"_id":"public/tags/Spring/index.html","modified":1434091414800,"shasum":"710bcba77c49b83cf3867e5cc091b99556d9c5e8"},{"_id":"public/tags/TWR/index.html","modified":1434091414807,"shasum":"f0c27e015b480ddc464f75295bfd3e6e0d97f92e"},{"_id":"public/tags/Java7/index.html","modified":1434091414812,"shasum":"754cfd10d72abe2975e91a3021605808bab21a7d"},{"_id":"public/sitemap.xml","modified":1434091414905,"shasum":"07010f7c920e71f2da03abd7b94a62c7eacc230a"}],"Category":[{"name":"前端","_id":"ciat8vb2r0007970q4ut2jelh"},{"name":"心态","_id":"ciat8vb2x000c970qdjs6phd4"},{"name":"Java","_id":"ciat8vb31000f970qlqkipb3x"},{"name":"书摘","_id":"ciat8vb3a000p970qyhcycsmj"},{"name":"系统配置","_id":"ciat8vb460020970qvenkmhh9"},{"name":"其他","_id":"ciat8vb4h002f970qwg0ukxqq"}],"Data":[],"Page":[{"layout":"default","_content":"<html>\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>404</title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"---\nlayout: default\n---\n<html>\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>404</title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2015-06-10T07:08:35.000Z","updated":"2015-06-10T07:08:35.000Z","path":"404.html","title":"","comments":1,"_id":"ciat8vb220000970qfrv2hfss"},{"layout":"tags","title":"tags","_content":"","source":"tags/index.md","raw":"layout: tags\ntitle: tags \n---","date":"2015-06-10T06:29:37.000Z","updated":"2015-06-09T17:24:10.000Z","path":"tags/index.html","comments":1,"_id":"ciat8vb250001970qnwsks2if"},{"title":"站内搜索","layout":"search","date":"2015-06-10T15:33:56.000Z","_content":"","source":"search/index.md","raw":"title: \"站内搜索\"\nlayout: search\ndate: 2015-06-10 23:33:56\n---","updated":"2015-06-11T06:10:41.000Z","path":"search/index.html","comments":1,"_id":"ciat8vb270002970qszkh142w"},{"layout":"categories","title":"categories","_content":"","source":"categories/index.md","raw":"layout: categories\ntitle: categories \n---","date":"2015-06-10T06:29:37.000Z","updated":"2015-06-09T17:24:05.000Z","path":"categories/index.html","comments":1,"_id":"ciat8vb2k0004970q2sruttp6"},{"date":"2015-06-09T15:33:56.000Z","title":"关于","_content":"####Basic Info\nMy name is Liu Xing, A software developer on Java platform, I'm living in jingan, shanghai, China.  \n\n####Links\nGitHub: <https://github.com/liuxing87327>  ","source":"about/index.md","raw":"date: 2015-06-09 23:33:56\ntitle: \"关于\"\n---\n####Basic Info\nMy name is Liu Xing, A software developer on Java platform, I'm living in jingan, shanghai, China.  \n\n####Links\nGitHub: <https://github.com/liuxing87327>  ","updated":"2015-06-09T18:38:28.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciat8vb2l0005970qhf60umfs"}],"Post":[{"title":"面向对象js","date":"2012-07-03T16:00:00.000Z","_content":"一些很久前写的东西\n\n##面向对象的好处\n代码以类为单元进行管理，把相关的数据和方法封装到类中。\n\n\n##js对象的本质\njs的对象实质就是java的map， 它是key和value对的集合\n```javascript\nvar estate = {};\nestate.estateName = '达安花园';\nestate.address = '静安区...';\n```\n\n访问对象属性，通过“.”或“[]”进行访问\n```javascript\nestate.estateName 或 estate.['estateName']\n```\n\n遍历\n```javascript\nfor(var propName in estate){\n    alert(propName+'='+estate[propName]);\n}\n```\n\n\n##如何在js中写类（constructor/prototype pattern）\n```javascript\n//实例属性，实例化的每个对象都会有自己的一份拷贝\nfunction Person(name, age){               //构造函数：用来构造对象\n     this.name = name;\n     this.age = age;\n}\n\n//原型（共享）属性， 所有的对象共享一份\nPerson.prototype = {\n     constructor: Person,\n     toString : function(){\n          return \"name=\"+this.name+',age='+this.age;\n     }\n};\n\n//当执行new操作的时候， 构造函数Person中的this即指向变量person，通过构造函数的语句，即给person变量添加了name和age属性\nvar person = new Person('zhangsan', 25); \nalert(person.toString());\n```\n\n\n##js中实现继承\n```javascript\nfunction Student(name, age, score){\n     Person.call(this, name, age);               //借用父类的构造函数：目的是通过父类的构造函数， 把父类中定义的属性复制到子类对象上\n     this.score = score;\n}\n\nStudent.prototype = new Person();               //子类的原型赋值为父类的对象： 目的是共享父类的方法\nStudent.prototype.toString= function(){\n     return Person.prototype.show.apply(this)+\",score=\"+this.score+\"\";\n}\n         \nvar student = new Student('zhanglg', 30, 98);\nalert(student.toString());\n```\n\n当在对象上访问某个属性时， 先从对象上找该属性，找到则返回该属性， 否则向上回溯到原型中去找该属性， 找到则返回， 否则为undefined","source":"_posts/面向对象js.md","raw":"title: \"面向对象js\"\ndate: 2012-07-04 00:00:00\ncategory: [前端]\ntags: [js]\n---\n一些很久前写的东西\n\n##面向对象的好处\n代码以类为单元进行管理，把相关的数据和方法封装到类中。\n\n\n##js对象的本质\njs的对象实质就是java的map， 它是key和value对的集合\n```javascript\nvar estate = {};\nestate.estateName = '达安花园';\nestate.address = '静安区...';\n```\n\n访问对象属性，通过“.”或“[]”进行访问\n```javascript\nestate.estateName 或 estate.['estateName']\n```\n\n遍历\n```javascript\nfor(var propName in estate){\n    alert(propName+'='+estate[propName]);\n}\n```\n\n\n##如何在js中写类（constructor/prototype pattern）\n```javascript\n//实例属性，实例化的每个对象都会有自己的一份拷贝\nfunction Person(name, age){               //构造函数：用来构造对象\n     this.name = name;\n     this.age = age;\n}\n\n//原型（共享）属性， 所有的对象共享一份\nPerson.prototype = {\n     constructor: Person,\n     toString : function(){\n          return \"name=\"+this.name+',age='+this.age;\n     }\n};\n\n//当执行new操作的时候， 构造函数Person中的this即指向变量person，通过构造函数的语句，即给person变量添加了name和age属性\nvar person = new Person('zhangsan', 25); \nalert(person.toString());\n```\n\n\n##js中实现继承\n```javascript\nfunction Student(name, age, score){\n     Person.call(this, name, age);               //借用父类的构造函数：目的是通过父类的构造函数， 把父类中定义的属性复制到子类对象上\n     this.score = score;\n}\n\nStudent.prototype = new Person();               //子类的原型赋值为父类的对象： 目的是共享父类的方法\nStudent.prototype.toString= function(){\n     return Person.prototype.show.apply(this)+\",score=\"+this.score+\"\";\n}\n         \nvar student = new Student('zhanglg', 30, 98);\nalert(student.toString());\n```\n\n当在对象上访问某个属性时， 先从对象上找该属性，找到则返回该属性， 否则向上回溯到原型中去找该属性， 找到则返回， 否则为undefined","slug":"面向对象js","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb2n0006970q095d1xqv"},{"title":"逐步改善，设计优秀的API","date":"2012-07-03T16:03:00.000Z","_content":"\n*判断一个API是否优秀，并不是简单地根据第一个版本给出判断的，而是要看多年后，该API是否还能存在，是否仍旧保持得不错。*\n \n \n##第一个版本远非完美\n第一个版本总是来得特别容易，不仅容易开发，而且容易发布。API的需求会随着时间而变，那些过去有效的API可能现在已经不再适用了。而且每个程序中都会存在Bug，需要不断地来修复，这样做带来的副作用人所共知：修复一个Bug的同时会引入两个新Bug。这些观点普遍适用于所有软件系统，API也不例外。\n\n\n但我们没必要为这个结论而感到悲观。API因为需要不断改进的事实算不上什么坏事，只是对现实的一种坦诚。每一个API的作者都应该为未来的改进做出计划。这种计划是一种比较高层次的，要考虑未来版本会对API中哪些内容加以改进。这种计划可能会用到两种方式。一种极端的方式是放弃老的版本，重新开始做一套新系统。还有一种方式则是修正用户提出的问题，并强化现有的API，保证兼容性，从而使得现有客户端的功能不会有所改变。\n\n\n放弃现有的API，并从头开始编写一个新的API来完成同样的任务，可以避免不兼容问题。这样做唯一的问题就在于：那些使用旧API的客户端只能继续沿用老的API，除非重新编写他们的代码，以升级到API的新版本上。所以这样做的缺点也是不容忽视的。\n\n\n完全重新编写API的优点在于避免了细微的不兼容问题，但让客户端被锁定在一个特定的版本中，即使新的版本提供了大量的改进，这些客户端也无法从新版本中获益。虽然对API进行改进固然是一件重要的事情，但相比之下，兼容性更为重要。只有在这两者之间巧妙地取得平衡才能让一个API成为可用的API。\n\n \n##向后兼容\n对于每一个API的设计者来说，都渴望做到“向后兼容”，因为不管是现在的API用户，还是潜在的API用户，都只信任那些可兼容的API。但向后兼容有多个层次上的意义，而且不同层次的向后兼容，也意味着不同的重要性和复杂度。\n\n\n###源代码兼容\n说到兼容性，最先要面对的问题，就是保证源代码编译时的兼容。如果基于Java 1.3版本开发程序，那么可以用Java 1.4版本来编译这些程序的源代码吗？如果能做到这一点，那么可以说Java 1.3和Java 1.4这两个版本是源代码兼容的。但源代码兼容是非常难以达到的。之所以出现这种问题，主要是因为每个新版本的Java语言都会添加一些语法上面的新功能，这种改变往往都会体现在执行文件的格式上，也就是Class文件的格式会有所调整。\n\n\n###二进制兼容\n如果一个基于老版本类库开发的程序，在不需要重新编译的前提下，可以和新版本类库进行正常连接并执行，那么这种情况可以称作二进制兼容。因为有两种场景需要这种兼容性方面的支持，所以要做到这一点也是非常重要的。首先，用户基于某个版本的类库编写了一个程序以后，原先开发的程序应该都可以一直正常运行，不管用户手中的类库是哪个版本，是否升级到了最新版本，程序的运行都应该是正常的。这样做可以极大地简化程序的维护、打包和发布工作。其次，如果用户只有一个老版本的二进制类库，也同样可以开发程序，随后再移植到新版本上，这样就无须用户来重新编译程序 。这两种场景都有各自的用途，它们提升了配置方面的灵活性，并赋予模块开发人员和用户更多的自由。为了达到这种相互调用的灵活性，开发人员至少需要了解一些源代码编译后生成的二进制格式。对于Java语言来说，就表示开发人员需要去了解Class文件的格式，以及Java虚拟机如何加载Class文件。\n\n\n二进制字节码的格式与Java源代码的格式非常相似，这有好的方面，也有坏的一面。说它好，是因为这样的格式很容易理解。说它坏，是因为它会引发一些误解。但大家应该记住，在编写API的时候，只有通过二进制格式才能最终判断不同版本的API是否兼容，也就是说代码执行时的兼容性才是最根本的。所以一定要了解Java源代码是编译成何种样子的字节码。如果有疑问的话，最好反编译一下Class文件，检查一下到底是不是自己期望的样子。有可能你会为反编译的结果大吃一惊!\n\n\n###功能兼容——阿米巴变形虫效应\n如果一个类库在运行时，不管所引用的是老版本还是新版本的类库，其产生的结果完全相同，那么这两个版本可以称为功能兼容。这个定义看起来简单，但背后的含义却不简单。\n\n\n作为开发人员，你可能会清楚地知道你所开发类库都提供了哪些功能，假设你提供了优秀的规范和完善的文档还有其他的信息，从而能够清楚地对类库的功能加以说明。\n当然这只是一个假设，从来都没有什么优秀的文档可以做到上面所说的目标。\n在现实世界中，文档总是比程序慢上一步，而且其描述的信息也只是整个程序的一部分内容。\n但还是先假设有一些开发人员已经完美地分析了程序，并清楚地知道程序的所有功能。如图 1中所描绘的那样。\n\n\n![图1](/images/jiagousheji/01.jpg)\n\n\n但大家都很清楚地知道软件开发中的一条金科玉律：每个程序至少都有一个Bug。什么意思呢？\n所谓的Bug其实就是程序的功能不符合预期定义的内容。\n即使开发人员愿意相信程序的行为如图1中定义的那样完美，而现实中，程序的功能与其预期定义的内容都是存在出入的。\n在特定情况下，代码并没有实现预期的功能，而在其他情况下，所完成的功能要超出预期。如图2所展示的样。\n\n\n![图2](/images/jiagousheji/02.jpg)\n\n\n问题就隐藏在这张图的背后！假设这张图同时描述了现实世界与理想世界中的程序功能。\n那么圆是一个清楚的功能定义，而具体程序则有所出入，有时没有完成规范中定义的某些功能，有时却又超出了规范中定义的某些功能。\n而程序员在开发代码时，往往不会去阅读相应的规范。\n事实上，几乎没有哪个开发人员会去读这些API的规范，直到出现严重的问题。\n他们会用“编码/运行”这样的方式来完成自己的工作。比如说开发人员写了一些代码，运行之后发现完成了自己需要的功能。此时，他们关注的是那些API背后具体实现所完成的功能，并不关心规范怎么说。\n这样做，其实是让代码依赖于具体的实现，而这些实现内容并不会写到规范中。\n显然，不管是少提供了功能，还是多提供了功能，这两种情况都是非常危险的，会影响到未来类库版本的共存，更会影响使用这些类库的程序。\n一旦该类库有新版本发布，修正了某些bug，或者再添加一些功能，都有可能会影响你的程序，就像图3一样，从圆变成了不规则形状。\n\n\n![图3](/images/jiagousheji/02.jpg)\n\n\n要为自己的行为负上责任也不是一件容易的事。\n所以API设计者首要的目标就是要减少阿米巴变形虫效应，要让API的功能行为尽可能地与规范保持一致。这事做起来决不简单。\n需要开发人员对API要完成的功能有清楚的认识，同样还要有良好的技术水平，才能将自己的意图贯彻到代码上，此外还得评估一下API的用户会如何来使用（还要想一下这些用户如何来误用API）。\n \n\n##面向用例的重要性\n请记住，如果一个API被广泛使用了，那么就不可能了解所有使用该API的用户。比如说，Linux内核的作者不可能知道所有使用该内核的开发人员以及他们使用内核的动机所在，也不清楚地球上有多少人使用了ioctl 这个方法从内核得到相应的内容。所以，如果设计者希望能够设计出像Linux和Java这样被广泛使用的API，那么必须站在用户的角度来理解如何设计API库，以及如何才能设计出这样的API库。\n\n\n既然不知道自己的客户，自然也无法进行交流，那么就有两种解决方案：一是找一些用户，对其进行研究，还是一种方式就是基于用例。基于用例也就表示站在用户的视角，然后再对部分用例进行针对性的处理。从用户处取得反馈信息，并对可用性进行研究，这是一种很好的工作方式，可以通过反馈来检验设计的用例是否正确。在做设计之前，必须进行分析，明确为什么要写这样的API，API应该长什么样，以及如何才能完成目标。\n\n\n当然这些用例都是编的。当API有了真实的用户时，才会发现这些用例与与真实情况可能相距甚远，与真实需求也有很多不同之处。从这一点上来说，第一个版本决不可能完美。但可以减少API中存在的错误。说到API设计错误，并不是指这些API不能满足用户需求，这是很正常的，因为在整个系统的生命周期中，会不断地有用户提出新的需求。所谓的错误是指API不能在后续的版本中以扩展的方式来满足用户的这些需求。但如果你学习了本书，在设计API时，不仅可以通过扩展的方式满足新需求，而且新版本也不会破坏客户基于第一个版本开发的那些代码。\n\n\n前文展示的阿米巴变形虫模型说明了对外的功能描述和其内在实现之间是存在着差异的，正是这种“差异”引发了API维护中的主要问题。所以要尽可能地减少这种不一致。但想要实现这个目标也要有一个前提，就是能对外提供一个定义清楚而且明确的规范，否则没有规范，拿什么来进行比较呢！\n\n\n##API设计评审\n过去，人们一直认为设计工作是不能由一个集体来完成的，它需要一个架构师对所有的设计进行决策。当然，这样做可以简化很多事情，但仍然有一个规模上的限制。就算不考虑模块规模大小这方面的限制，这位首席架构师的压力也是非常庞大的，其责任包括设计、维护API，还要告诉别人API应该怎么使用，这些工作内容都需要占用大量的时间，毕竟这位架构师一天只有24小时，不可能无限制地工作。\n\n\n解决方法就是从团队成员中选择一些技术最好的人，指导他们来设计自己所需要的API。但这样做会造成一致性方面的问题，因为每个人在设计API时都有其个人风格。肯定无益于API的质量，必须解决这一问题。\n\n\n但每一个设计良好的API，都有着相同的动机。所以要有一个团队来配合API的作者对API进行评审工作。\n\n\n一旦有一个API需要改动，任何人都可以提交一个改变的请求。其他人则需要在代码正式提交前，进行一次评审，检查新调整的内容是否符合一个优秀API的基本要求。比如说，我们会按照“优秀API规则”进行检查，保证能够满足这些规则。下面详细地列出了这些规则。\n\n\n用例驱动的API设计：设计API时，要基于一些具体的场景和对API的认识进行抽象分析，最终给出设计。\n\n\nAPI设计的一致性：API往往是由多位设计者来完成的，但整个团队中必须能够保持“最佳实践”的一些基本原则。一个接口设计得再好，只要它违反整个团队的一致性，就宁愿退而求其次。\n\n\n简单明了的API：简单而且常见的任务应该更容易处理。如果基于用例驱动的方式进行设计，就可以很容易地通过那些可以简单实现的场景来验证这些API是否可以完成那些重要的用例。\n\n\n少即是多：一个API对外提供的功能应该只包括用例中说明的功能。这样可以避免出现需要的功能与实际提供的功能两者之间出现差异。\n\n\n支持改进：以后也必须能够维护这个类库。如果出现新的需求，或者原作者离开，都不会出现放弃这个类库的情况。\n \n\n##一个API的生命周期\n开发API的过程其实就是一个沟通交流的过程。沟通的双方就是API用户和API设计者。\n\n\nAPI有可能是这样产生的，有些人写了一些代码，而另外的人发现这些代码的价值，就开始使用这些代码。在这种情况下，API是以一种自然的方式产生的。随后API用户和API作者有了相互沟通的渠道，开始交流经验，可能发现这个功能一开始的设计并不是很通用，或者说一开始时，作者并没有把这个功能当成一个API来设计。为了让这个功能成为一个API，他们开始讨论如何进行调整才能改善这个功能。经过几轮的迭代，才会带来一个有用而且稳定的API。\n\n\n但再换一个角度来看，API设计者希望在没有对外提供一个API之前就能和相关的用户进行沟通。这种API的开发方式更接近于基于业务的设计方式。在这种场景下，系统中的两个组件间的协定是已经明确的，至少说也是已经有了需求。收集需求，定义问题域，明确用例，再由指定人员来设计API。现在，其他人员就可以使用这个API，并可以给出自己的建议，列出Bug，提出一些功能方面的改进意见。这些建议都有助于改进API，使其用途更广，也更稳定。\n\n\n尽管这些API的案例各有其不同的缘由，但有相同的特点：每一个都需要时间来让用户进行试用，并进行反馈，然后才能宣称这个API是可以正常运行的。当然不是说这样做就可以带来稳定的API，有时候，也有可能最终什么都得不到。如果出现这种情况，最好还是放弃这个API吧。有时候，可能交流的双方无法进行高质量的正式交流。在开始的时候可以简单地聊一下，交流相应的需求，但如果新发布的版本也证明了这种简单的沟通方式并不合适，那么双方也许应该更进一步地进行交流，使得沟通能更简单更有效一些。\n\n\n一切皆有可能。但对于那种开发人员之间的沟通问题，最好还是要描述清楚。如果你要设计一个API，那么在这个API没有成熟前，最好能够清楚地告诉其用户：“这个API还没有完善，你可以尝试使用这个API，但一定要小心。”在有了稳定的版本以后，还可以骄傲地告诉用户：“这是我开发过的最好的API！放心使用这些API，我可以保证它能一直提供支持。”这样做可以俘获API用户的“芳心”，让他们“拜倒在你的石榴裙”下。但请一定要注意，对于API，要能够清楚地标识其当前状态，以便用户了解相应版本是否可以稳定使用。\n\n\n如果想告诉类库的用户当前发布的版本还不稳定，那么最简单的方式就是把其版本标识为0.x。因为它还没有到达1.0版本，表示还在开发中，也就可能还会有所变化。不管用哪种版本标识方式，最重要的是要让API的用户清楚地知道当前版本的状态，以便他们决定如何使用该API。\n\n\n##逐步改善\n我已经提过多次，这里再多重复一次，第一个版本远非完美。事实上，不仅第一个版本，哪个版本都不会是一个完美的版本。不管怎么样，设计的场景不可能完全准确，不可能完全符合之前的方案。对于版本间的变化，也有两种极端的处理方式：一种是逐步改善，还是一种则是完全重写。\n\n\n什么叫逐步改善呢？比如说，增加了一个方法或一个类，或者是向DTD文件中加了一个新的元素，又或者是增加了一个能够影响类库功能的属性。在保证老版本API能正常运行的情况下，演化出新版本API。这种改进是一步步进行的。\n\n\n关于“逐步改善”有一个谬论，就是说“因为只有少许的改动，所以以前用户使用老版本API编写的程序可以在新版本上继续运行”。每一个改变都有潜在的风险，因为它可能引发一个甚至更多的不兼容问题。每一个不兼容问题（即使看似微不足道）都会反映到客户开发的程序中，可能就会产生非常严重的后果。开始时，要能够把真正的内容与最初的设想保持一致，而且任何一个小的改变都不会引发任何问题，这样才可能避免阿米巴虫模型出现。\n\n\n如果考虑到向后兼容性问题，那么也许重写一个全新的版本可能是更现实一些，这样可以清楚地告诉类库的用户，如果要移植到一个新版本上，就要花费一些时间进行代码迁移工作。与前面“逐步改善”的方式相比，这样做显得更诚实一些。但这样做也在很多方面都存在问题。首先，如果新旧版本保持兼容，那么迁移的工作量就非常小，否则完全重写一个实现需要投入大量的时间，还需要一个充分的理由来说服用户接受这样的方式。如果没有令人信服的原因来说服用户，相信用户宁愿守着老的版本。要知道，每个项目最重要的问题就是日程计划的安排。如果没有一个充分的理由，没有人愿意花费大量的时间将代码升级到新版本上，他们会去做其他更重要的事情。\n\n\n如果用这种态度为API的客户提供服务，那么就不会带来一个好的合作氛围。但还有更坏的合作方式，就是完全不提供迁移的方案。有时候，对于一个愿意迁移到新版本的API客户来说，还是可以接受一个API完全重写。但如果说让所有的用户都只使用老的版本或者强迫他们立即都升级到最新版本，对于分布式开发来说，这两种方式都不现实，正如本书一开始所说的那样。如果API经常产生重大的变化，而且要强迫用户随之迁移，那么客户就会转向其他的方案，而放弃现有的API。\n\n\n总而言之，还是要准备使用增量改进的方式！人们需要软件加以改进，但改进时引入的伤害也应该最小化，特别是要避免重新编写的那种大变化。如果因为API设计上的问题，使得无法增量改进，那么也许会有充足的理由进行一次重新编写，但这种大的变化应该限定于开发方式上的一些基础性变化。本书的大部分篇幅都会讨论用于API增量改进的设计实践。如果出现了很大的变化，我们会同时强调要为一个API提供多个大版本类库。只有这种方式才能保证API能够变得更好，而且使API用户的痛苦最小化。\n\n\n![软件框架设计的艺术](/images/jiagousheji/cover.jpg)\n本文摘选自《软件框架设计的艺术》（Practical API Design: Confessions of  a  Java  Framework Architect）一书，中文版由人民邮电出版社图灵公司推出，特此感谢图灵公司的授权支持。","source":"_posts/逐步改善，设计优秀的API.md","raw":"title: \"逐步改善，设计优秀的API\"\ndate: 2012-07-04 00:03\ncategory: [心态]\ntags: []\n---\n\n*判断一个API是否优秀，并不是简单地根据第一个版本给出判断的，而是要看多年后，该API是否还能存在，是否仍旧保持得不错。*\n \n \n##第一个版本远非完美\n第一个版本总是来得特别容易，不仅容易开发，而且容易发布。API的需求会随着时间而变，那些过去有效的API可能现在已经不再适用了。而且每个程序中都会存在Bug，需要不断地来修复，这样做带来的副作用人所共知：修复一个Bug的同时会引入两个新Bug。这些观点普遍适用于所有软件系统，API也不例外。\n\n\n但我们没必要为这个结论而感到悲观。API因为需要不断改进的事实算不上什么坏事，只是对现实的一种坦诚。每一个API的作者都应该为未来的改进做出计划。这种计划是一种比较高层次的，要考虑未来版本会对API中哪些内容加以改进。这种计划可能会用到两种方式。一种极端的方式是放弃老的版本，重新开始做一套新系统。还有一种方式则是修正用户提出的问题，并强化现有的API，保证兼容性，从而使得现有客户端的功能不会有所改变。\n\n\n放弃现有的API，并从头开始编写一个新的API来完成同样的任务，可以避免不兼容问题。这样做唯一的问题就在于：那些使用旧API的客户端只能继续沿用老的API，除非重新编写他们的代码，以升级到API的新版本上。所以这样做的缺点也是不容忽视的。\n\n\n完全重新编写API的优点在于避免了细微的不兼容问题，但让客户端被锁定在一个特定的版本中，即使新的版本提供了大量的改进，这些客户端也无法从新版本中获益。虽然对API进行改进固然是一件重要的事情，但相比之下，兼容性更为重要。只有在这两者之间巧妙地取得平衡才能让一个API成为可用的API。\n\n \n##向后兼容\n对于每一个API的设计者来说，都渴望做到“向后兼容”，因为不管是现在的API用户，还是潜在的API用户，都只信任那些可兼容的API。但向后兼容有多个层次上的意义，而且不同层次的向后兼容，也意味着不同的重要性和复杂度。\n\n\n###源代码兼容\n说到兼容性，最先要面对的问题，就是保证源代码编译时的兼容。如果基于Java 1.3版本开发程序，那么可以用Java 1.4版本来编译这些程序的源代码吗？如果能做到这一点，那么可以说Java 1.3和Java 1.4这两个版本是源代码兼容的。但源代码兼容是非常难以达到的。之所以出现这种问题，主要是因为每个新版本的Java语言都会添加一些语法上面的新功能，这种改变往往都会体现在执行文件的格式上，也就是Class文件的格式会有所调整。\n\n\n###二进制兼容\n如果一个基于老版本类库开发的程序，在不需要重新编译的前提下，可以和新版本类库进行正常连接并执行，那么这种情况可以称作二进制兼容。因为有两种场景需要这种兼容性方面的支持，所以要做到这一点也是非常重要的。首先，用户基于某个版本的类库编写了一个程序以后，原先开发的程序应该都可以一直正常运行，不管用户手中的类库是哪个版本，是否升级到了最新版本，程序的运行都应该是正常的。这样做可以极大地简化程序的维护、打包和发布工作。其次，如果用户只有一个老版本的二进制类库，也同样可以开发程序，随后再移植到新版本上，这样就无须用户来重新编译程序 。这两种场景都有各自的用途，它们提升了配置方面的灵活性，并赋予模块开发人员和用户更多的自由。为了达到这种相互调用的灵活性，开发人员至少需要了解一些源代码编译后生成的二进制格式。对于Java语言来说，就表示开发人员需要去了解Class文件的格式，以及Java虚拟机如何加载Class文件。\n\n\n二进制字节码的格式与Java源代码的格式非常相似，这有好的方面，也有坏的一面。说它好，是因为这样的格式很容易理解。说它坏，是因为它会引发一些误解。但大家应该记住，在编写API的时候，只有通过二进制格式才能最终判断不同版本的API是否兼容，也就是说代码执行时的兼容性才是最根本的。所以一定要了解Java源代码是编译成何种样子的字节码。如果有疑问的话，最好反编译一下Class文件，检查一下到底是不是自己期望的样子。有可能你会为反编译的结果大吃一惊!\n\n\n###功能兼容——阿米巴变形虫效应\n如果一个类库在运行时，不管所引用的是老版本还是新版本的类库，其产生的结果完全相同，那么这两个版本可以称为功能兼容。这个定义看起来简单，但背后的含义却不简单。\n\n\n作为开发人员，你可能会清楚地知道你所开发类库都提供了哪些功能，假设你提供了优秀的规范和完善的文档还有其他的信息，从而能够清楚地对类库的功能加以说明。\n当然这只是一个假设，从来都没有什么优秀的文档可以做到上面所说的目标。\n在现实世界中，文档总是比程序慢上一步，而且其描述的信息也只是整个程序的一部分内容。\n但还是先假设有一些开发人员已经完美地分析了程序，并清楚地知道程序的所有功能。如图 1中所描绘的那样。\n\n\n![图1](/images/jiagousheji/01.jpg)\n\n\n但大家都很清楚地知道软件开发中的一条金科玉律：每个程序至少都有一个Bug。什么意思呢？\n所谓的Bug其实就是程序的功能不符合预期定义的内容。\n即使开发人员愿意相信程序的行为如图1中定义的那样完美，而现实中，程序的功能与其预期定义的内容都是存在出入的。\n在特定情况下，代码并没有实现预期的功能，而在其他情况下，所完成的功能要超出预期。如图2所展示的样。\n\n\n![图2](/images/jiagousheji/02.jpg)\n\n\n问题就隐藏在这张图的背后！假设这张图同时描述了现实世界与理想世界中的程序功能。\n那么圆是一个清楚的功能定义，而具体程序则有所出入，有时没有完成规范中定义的某些功能，有时却又超出了规范中定义的某些功能。\n而程序员在开发代码时，往往不会去阅读相应的规范。\n事实上，几乎没有哪个开发人员会去读这些API的规范，直到出现严重的问题。\n他们会用“编码/运行”这样的方式来完成自己的工作。比如说开发人员写了一些代码，运行之后发现完成了自己需要的功能。此时，他们关注的是那些API背后具体实现所完成的功能，并不关心规范怎么说。\n这样做，其实是让代码依赖于具体的实现，而这些实现内容并不会写到规范中。\n显然，不管是少提供了功能，还是多提供了功能，这两种情况都是非常危险的，会影响到未来类库版本的共存，更会影响使用这些类库的程序。\n一旦该类库有新版本发布，修正了某些bug，或者再添加一些功能，都有可能会影响你的程序，就像图3一样，从圆变成了不规则形状。\n\n\n![图3](/images/jiagousheji/02.jpg)\n\n\n要为自己的行为负上责任也不是一件容易的事。\n所以API设计者首要的目标就是要减少阿米巴变形虫效应，要让API的功能行为尽可能地与规范保持一致。这事做起来决不简单。\n需要开发人员对API要完成的功能有清楚的认识，同样还要有良好的技术水平，才能将自己的意图贯彻到代码上，此外还得评估一下API的用户会如何来使用（还要想一下这些用户如何来误用API）。\n \n\n##面向用例的重要性\n请记住，如果一个API被广泛使用了，那么就不可能了解所有使用该API的用户。比如说，Linux内核的作者不可能知道所有使用该内核的开发人员以及他们使用内核的动机所在，也不清楚地球上有多少人使用了ioctl 这个方法从内核得到相应的内容。所以，如果设计者希望能够设计出像Linux和Java这样被广泛使用的API，那么必须站在用户的角度来理解如何设计API库，以及如何才能设计出这样的API库。\n\n\n既然不知道自己的客户，自然也无法进行交流，那么就有两种解决方案：一是找一些用户，对其进行研究，还是一种方式就是基于用例。基于用例也就表示站在用户的视角，然后再对部分用例进行针对性的处理。从用户处取得反馈信息，并对可用性进行研究，这是一种很好的工作方式，可以通过反馈来检验设计的用例是否正确。在做设计之前，必须进行分析，明确为什么要写这样的API，API应该长什么样，以及如何才能完成目标。\n\n\n当然这些用例都是编的。当API有了真实的用户时，才会发现这些用例与与真实情况可能相距甚远，与真实需求也有很多不同之处。从这一点上来说，第一个版本决不可能完美。但可以减少API中存在的错误。说到API设计错误，并不是指这些API不能满足用户需求，这是很正常的，因为在整个系统的生命周期中，会不断地有用户提出新的需求。所谓的错误是指API不能在后续的版本中以扩展的方式来满足用户的这些需求。但如果你学习了本书，在设计API时，不仅可以通过扩展的方式满足新需求，而且新版本也不会破坏客户基于第一个版本开发的那些代码。\n\n\n前文展示的阿米巴变形虫模型说明了对外的功能描述和其内在实现之间是存在着差异的，正是这种“差异”引发了API维护中的主要问题。所以要尽可能地减少这种不一致。但想要实现这个目标也要有一个前提，就是能对外提供一个定义清楚而且明确的规范，否则没有规范，拿什么来进行比较呢！\n\n\n##API设计评审\n过去，人们一直认为设计工作是不能由一个集体来完成的，它需要一个架构师对所有的设计进行决策。当然，这样做可以简化很多事情，但仍然有一个规模上的限制。就算不考虑模块规模大小这方面的限制，这位首席架构师的压力也是非常庞大的，其责任包括设计、维护API，还要告诉别人API应该怎么使用，这些工作内容都需要占用大量的时间，毕竟这位架构师一天只有24小时，不可能无限制地工作。\n\n\n解决方法就是从团队成员中选择一些技术最好的人，指导他们来设计自己所需要的API。但这样做会造成一致性方面的问题，因为每个人在设计API时都有其个人风格。肯定无益于API的质量，必须解决这一问题。\n\n\n但每一个设计良好的API，都有着相同的动机。所以要有一个团队来配合API的作者对API进行评审工作。\n\n\n一旦有一个API需要改动，任何人都可以提交一个改变的请求。其他人则需要在代码正式提交前，进行一次评审，检查新调整的内容是否符合一个优秀API的基本要求。比如说，我们会按照“优秀API规则”进行检查，保证能够满足这些规则。下面详细地列出了这些规则。\n\n\n用例驱动的API设计：设计API时，要基于一些具体的场景和对API的认识进行抽象分析，最终给出设计。\n\n\nAPI设计的一致性：API往往是由多位设计者来完成的，但整个团队中必须能够保持“最佳实践”的一些基本原则。一个接口设计得再好，只要它违反整个团队的一致性，就宁愿退而求其次。\n\n\n简单明了的API：简单而且常见的任务应该更容易处理。如果基于用例驱动的方式进行设计，就可以很容易地通过那些可以简单实现的场景来验证这些API是否可以完成那些重要的用例。\n\n\n少即是多：一个API对外提供的功能应该只包括用例中说明的功能。这样可以避免出现需要的功能与实际提供的功能两者之间出现差异。\n\n\n支持改进：以后也必须能够维护这个类库。如果出现新的需求，或者原作者离开，都不会出现放弃这个类库的情况。\n \n\n##一个API的生命周期\n开发API的过程其实就是一个沟通交流的过程。沟通的双方就是API用户和API设计者。\n\n\nAPI有可能是这样产生的，有些人写了一些代码，而另外的人发现这些代码的价值，就开始使用这些代码。在这种情况下，API是以一种自然的方式产生的。随后API用户和API作者有了相互沟通的渠道，开始交流经验，可能发现这个功能一开始的设计并不是很通用，或者说一开始时，作者并没有把这个功能当成一个API来设计。为了让这个功能成为一个API，他们开始讨论如何进行调整才能改善这个功能。经过几轮的迭代，才会带来一个有用而且稳定的API。\n\n\n但再换一个角度来看，API设计者希望在没有对外提供一个API之前就能和相关的用户进行沟通。这种API的开发方式更接近于基于业务的设计方式。在这种场景下，系统中的两个组件间的协定是已经明确的，至少说也是已经有了需求。收集需求，定义问题域，明确用例，再由指定人员来设计API。现在，其他人员就可以使用这个API，并可以给出自己的建议，列出Bug，提出一些功能方面的改进意见。这些建议都有助于改进API，使其用途更广，也更稳定。\n\n\n尽管这些API的案例各有其不同的缘由，但有相同的特点：每一个都需要时间来让用户进行试用，并进行反馈，然后才能宣称这个API是可以正常运行的。当然不是说这样做就可以带来稳定的API，有时候，也有可能最终什么都得不到。如果出现这种情况，最好还是放弃这个API吧。有时候，可能交流的双方无法进行高质量的正式交流。在开始的时候可以简单地聊一下，交流相应的需求，但如果新发布的版本也证明了这种简单的沟通方式并不合适，那么双方也许应该更进一步地进行交流，使得沟通能更简单更有效一些。\n\n\n一切皆有可能。但对于那种开发人员之间的沟通问题，最好还是要描述清楚。如果你要设计一个API，那么在这个API没有成熟前，最好能够清楚地告诉其用户：“这个API还没有完善，你可以尝试使用这个API，但一定要小心。”在有了稳定的版本以后，还可以骄傲地告诉用户：“这是我开发过的最好的API！放心使用这些API，我可以保证它能一直提供支持。”这样做可以俘获API用户的“芳心”，让他们“拜倒在你的石榴裙”下。但请一定要注意，对于API，要能够清楚地标识其当前状态，以便用户了解相应版本是否可以稳定使用。\n\n\n如果想告诉类库的用户当前发布的版本还不稳定，那么最简单的方式就是把其版本标识为0.x。因为它还没有到达1.0版本，表示还在开发中，也就可能还会有所变化。不管用哪种版本标识方式，最重要的是要让API的用户清楚地知道当前版本的状态，以便他们决定如何使用该API。\n\n\n##逐步改善\n我已经提过多次，这里再多重复一次，第一个版本远非完美。事实上，不仅第一个版本，哪个版本都不会是一个完美的版本。不管怎么样，设计的场景不可能完全准确，不可能完全符合之前的方案。对于版本间的变化，也有两种极端的处理方式：一种是逐步改善，还是一种则是完全重写。\n\n\n什么叫逐步改善呢？比如说，增加了一个方法或一个类，或者是向DTD文件中加了一个新的元素，又或者是增加了一个能够影响类库功能的属性。在保证老版本API能正常运行的情况下，演化出新版本API。这种改进是一步步进行的。\n\n\n关于“逐步改善”有一个谬论，就是说“因为只有少许的改动，所以以前用户使用老版本API编写的程序可以在新版本上继续运行”。每一个改变都有潜在的风险，因为它可能引发一个甚至更多的不兼容问题。每一个不兼容问题（即使看似微不足道）都会反映到客户开发的程序中，可能就会产生非常严重的后果。开始时，要能够把真正的内容与最初的设想保持一致，而且任何一个小的改变都不会引发任何问题，这样才可能避免阿米巴虫模型出现。\n\n\n如果考虑到向后兼容性问题，那么也许重写一个全新的版本可能是更现实一些，这样可以清楚地告诉类库的用户，如果要移植到一个新版本上，就要花费一些时间进行代码迁移工作。与前面“逐步改善”的方式相比，这样做显得更诚实一些。但这样做也在很多方面都存在问题。首先，如果新旧版本保持兼容，那么迁移的工作量就非常小，否则完全重写一个实现需要投入大量的时间，还需要一个充分的理由来说服用户接受这样的方式。如果没有令人信服的原因来说服用户，相信用户宁愿守着老的版本。要知道，每个项目最重要的问题就是日程计划的安排。如果没有一个充分的理由，没有人愿意花费大量的时间将代码升级到新版本上，他们会去做其他更重要的事情。\n\n\n如果用这种态度为API的客户提供服务，那么就不会带来一个好的合作氛围。但还有更坏的合作方式，就是完全不提供迁移的方案。有时候，对于一个愿意迁移到新版本的API客户来说，还是可以接受一个API完全重写。但如果说让所有的用户都只使用老的版本或者强迫他们立即都升级到最新版本，对于分布式开发来说，这两种方式都不现实，正如本书一开始所说的那样。如果API经常产生重大的变化，而且要强迫用户随之迁移，那么客户就会转向其他的方案，而放弃现有的API。\n\n\n总而言之，还是要准备使用增量改进的方式！人们需要软件加以改进，但改进时引入的伤害也应该最小化，特别是要避免重新编写的那种大变化。如果因为API设计上的问题，使得无法增量改进，那么也许会有充足的理由进行一次重新编写，但这种大的变化应该限定于开发方式上的一些基础性变化。本书的大部分篇幅都会讨论用于API增量改进的设计实践。如果出现了很大的变化，我们会同时强调要为一个API提供多个大版本类库。只有这种方式才能保证API能够变得更好，而且使API用户的痛苦最小化。\n\n\n![软件框架设计的艺术](/images/jiagousheji/cover.jpg)\n本文摘选自《软件框架设计的艺术》（Practical API Design: Confessions of  a  Java  Framework Architect）一书，中文版由人民邮电出版社图灵公司推出，特此感谢图灵公司的授权支持。","slug":"逐步改善，设计优秀的API","published":1,"updated":"2015-06-12T02:45:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb2v000b970qvdbnutht"},{"title":"谷歌地图坐标转换百度地图坐标 ","date":"2012-08-15T16:16:00.000Z","_content":"\n##功能代码\n\nhttpclient方式请求百度的转换地址\nhttp://api.map.baidu.com/ag/coord/convert?from=2&to=4&x=&y=\n拿到的是转换后的json数据，但是坐标值是base64加密过的字符，需要解密一下\n\n```java\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.methods.GetMethod;\n\npublic class BaiduMapUtils {\n\t\n\tpublic static final String googleToBaiduUrl = \"http://api.map.baidu.com/ag/coord/convert?from=2&to=4&x=#x#&y=#y#\";\n\t\n\tpublic static String httpClientForGet(String url){\n\t\tHttpClient client = new HttpClient();\n\t\tGetMethod getMethod = new GetMethod(url);\n\t\tgetMethod.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\"); \n\t\t\n\t\ttry {\n\t\t\tclient.executeMethod(getMethod);\n\t\t\tif (getMethod.getStatusCode() == HttpStatus.SC_OK) {\n\t\t\t\treturn getMethod.getResponseBodyAsString();\n\t\t\t}\n\t\t} catch (HttpException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tgetMethod.releaseConnection();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 转换谷歌为百度坐标\n\t * @param x 经度\n\t * @param y\t纬度\n\t * @return 获取转换过的百度坐标\n\t */\n\tpublic static Map<String, Object> googleToBaidu(Double x, Double y){\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\t\n\t\tString relt = httpClientForGet(getGoogleToBaiduUrl(String.valueOf(x), String.valueOf(y)));\n\t\tif(DyString.isNotEmpty(relt))\n\t\t\tmap = JsonUtils.parserToMap(relt);\n\t\t\n\t\tmap.put(\"x\", Base64Utils.decode(map.get(\"x\")));\n\t\tmap.put(\"y\", Base64Utils.decode(map.get(\"y\")));\n\t\t\n\t\treturn map;\n\t}\n\t\n\t/**\n\t * 获取请求地址\n\t * \n\t * @param x\n\t * @param y\n\t * @return\n\t */\n\tpublic static String getGoogleToBaiduUrl(String x, String y){\n\t\treturn googleToBaiduUrl.replace(\"#x#\", x).replace(\"#y#\", y);\n\t}\n\t\n\t/**\n\t * URL中文字符编码\n\t * @param url\n\t * @return\n\t */\n\tpublic static String encode(String s){\n\t\treturn URLEncoder.encode(s);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(googleToBaidu(31.2306192233586, 121.446663737297));\n\t}\n}\n```\n\n##Base64Utils\n使用apache的commons包下面的base64工具类\n\n```java\nimport org.apache.commons.codec.binary.Base64;\n\n/**\n * base64加密解密工具 使用apache工具包\n * \n * @author 刘兴\n * \n */\npublic class Base64Utils {\n\n\t/**\n\t * base64加密字符串\n\t * \n\t * @param s\n\t * @return\n\t */\n\tpublic static String encode(Object s) {\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tBase64 base64 = new Base64();\n\t\tbyte[] enbytes = base64.encode(String.valueOf(s).getBytes());\n\t\treturn new String(enbytes);\n\t}\n\n\t/**\n\t * base64解密字符串\n\t * \n\t * @param s\n\t * @return\n\t */\n\tpublic static String decode(Object s) {\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tBase64 base64 = new Base64();\n\t\tbyte[] debytes = base64.decode(String.valueOf(s).getBytes());\n\t\treturn new String(debytes);\n\t}\n\n\tpublic static void main(String[] a) {\n\t\tSystem.out.println(Base64Utils.decode(\"MTE2LjI2MTA5OTEyMjE=\"));\n\t}\n}\n```\n\nDyString类是一个自定义的字符串处理工具类，可以调用apache的工具类StringUtils.isEmpty或isNotEmpty\nJsonUtils类是自定义的json字符串处理工具类，内部功能是将json字符串转换成map对象","source":"_posts/谷歌地图坐标转换百度地图坐标 .md","raw":"title: \"谷歌地图坐标转换百度地图坐标 \"\ndate: 2012-08-16 00:16\ncategory: [Java]\ntags: [地图]\n---\n\n##功能代码\n\nhttpclient方式请求百度的转换地址\nhttp://api.map.baidu.com/ag/coord/convert?from=2&to=4&x=&y=\n拿到的是转换后的json数据，但是坐标值是base64加密过的字符，需要解密一下\n\n```java\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.methods.GetMethod;\n\npublic class BaiduMapUtils {\n\t\n\tpublic static final String googleToBaiduUrl = \"http://api.map.baidu.com/ag/coord/convert?from=2&to=4&x=#x#&y=#y#\";\n\t\n\tpublic static String httpClientForGet(String url){\n\t\tHttpClient client = new HttpClient();\n\t\tGetMethod getMethod = new GetMethod(url);\n\t\tgetMethod.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\"); \n\t\t\n\t\ttry {\n\t\t\tclient.executeMethod(getMethod);\n\t\t\tif (getMethod.getStatusCode() == HttpStatus.SC_OK) {\n\t\t\t\treturn getMethod.getResponseBodyAsString();\n\t\t\t}\n\t\t} catch (HttpException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tgetMethod.releaseConnection();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 转换谷歌为百度坐标\n\t * @param x 经度\n\t * @param y\t纬度\n\t * @return 获取转换过的百度坐标\n\t */\n\tpublic static Map<String, Object> googleToBaidu(Double x, Double y){\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\t\n\t\tString relt = httpClientForGet(getGoogleToBaiduUrl(String.valueOf(x), String.valueOf(y)));\n\t\tif(DyString.isNotEmpty(relt))\n\t\t\tmap = JsonUtils.parserToMap(relt);\n\t\t\n\t\tmap.put(\"x\", Base64Utils.decode(map.get(\"x\")));\n\t\tmap.put(\"y\", Base64Utils.decode(map.get(\"y\")));\n\t\t\n\t\treturn map;\n\t}\n\t\n\t/**\n\t * 获取请求地址\n\t * \n\t * @param x\n\t * @param y\n\t * @return\n\t */\n\tpublic static String getGoogleToBaiduUrl(String x, String y){\n\t\treturn googleToBaiduUrl.replace(\"#x#\", x).replace(\"#y#\", y);\n\t}\n\t\n\t/**\n\t * URL中文字符编码\n\t * @param url\n\t * @return\n\t */\n\tpublic static String encode(String s){\n\t\treturn URLEncoder.encode(s);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(googleToBaidu(31.2306192233586, 121.446663737297));\n\t}\n}\n```\n\n##Base64Utils\n使用apache的commons包下面的base64工具类\n\n```java\nimport org.apache.commons.codec.binary.Base64;\n\n/**\n * base64加密解密工具 使用apache工具包\n * \n * @author 刘兴\n * \n */\npublic class Base64Utils {\n\n\t/**\n\t * base64加密字符串\n\t * \n\t * @param s\n\t * @return\n\t */\n\tpublic static String encode(Object s) {\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tBase64 base64 = new Base64();\n\t\tbyte[] enbytes = base64.encode(String.valueOf(s).getBytes());\n\t\treturn new String(enbytes);\n\t}\n\n\t/**\n\t * base64解密字符串\n\t * \n\t * @param s\n\t * @return\n\t */\n\tpublic static String decode(Object s) {\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tBase64 base64 = new Base64();\n\t\tbyte[] debytes = base64.decode(String.valueOf(s).getBytes());\n\t\treturn new String(debytes);\n\t}\n\n\tpublic static void main(String[] a) {\n\t\tSystem.out.println(Base64Utils.decode(\"MTE2LjI2MTA5OTEyMjE=\"));\n\t}\n}\n```\n\nDyString类是一个自定义的字符串处理工具类，可以调用apache的工具类StringUtils.isEmpty或isNotEmpty\nJsonUtils类是自定义的json字符串处理工具类，内部功能是将json字符串转换成map对象","slug":"谷歌地图坐标转换百度地图坐标 ","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb2z000e970qvjycb1hy"},{"title":"计算地图坐标是否在多边形内","date":"2015-04-20T16:44:00.000Z","_content":"\n##使用百度地图计算\nhttp://api.map.baidu.com/library/GeoUtils/1.2/examples/simple.html\nhttp://api.map.baidu.com/library/GeoUtils/1.2/docs/symbols/BMapLib.GeoUtils.html\n\n##使用java计算\n\n```java\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 功能说明：坐标几何运算\n * 作者：liuxing(2015-04-20 22:19)\n */\npublic class GeoUtils {\n\n    /**\n     * 检查一个坐标是否在多边形内\n     * @param x 纬度 31.000...\n     * @param y 经度 121.000...\n     * @param polygonPoints 多边形边界的经纬度数组\n     * @return\n     */\n    public static boolean isPointInPolygon(double x, double y, List<Map<String, Double>> polygonPoints) {\n        Point2D.Double geoPoint = buildPoint(x, y);\n        List<Point2D.Double> geoPolygon = buildPolygon(polygonPoints);\n        return GeoUtils.isPointInPolygon(geoPoint, geoPolygon);\n    }\n\n    /**\n     * 检查一个坐标是否在多边形内\n     * @param point 检查的点坐标\n     * @param polygon 参照的多边形\n     * @return\n     */\n    public static boolean isPointInPolygon(Point2D.Double point, List<Point2D.Double> polygon) {\n        GeneralPath p = new GeneralPath();\n\n        Point2D.Double first = polygon.get(0);\n        p.moveTo(first.x, first.y);\n        polygon.remove(0);\n\n        polygon.forEach(d -> p.lineTo(d.x, d.y));\n\n        p.lineTo(first.x, first.y);\n\n        p.closePath();\n\n        return p.contains(point);\n    }\n\n    /**\n     * 构建一个坐标点\n     * @param x 纬度 31.000...\n     * @param y 经度 121.000...\n     * @return\n     */\n    public static Point2D.Double buildPoint(double x, double y) {\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * 构建一个多边形\n     * @param polygonPoints\n     * @return\n     */\n    public static List<Point2D.Double> buildPolygon(List<Map<String, Double>> polygonPoints) {\n        List<Point2D.Double> geoPolygon = new ArrayList<>();\n\n        polygonPoints.forEach(map -> geoPolygon.add(buildPoint(map.get(\"x\"), map.get(\"y\"))));\n\n        return geoPolygon;\n    }\n\n}\n```\n\n更多运算场景请参考：\nhttp://docs.oracle.com/javase/8/docs/api/java/awt/Polygon.html\n\n##使用数据库计算\nSqlServer2008以上，暂未尝试","source":"_posts/计算地图坐标是否在多边形内.md","raw":"title: \"计算地图坐标是否在多边形内\"\ndate: 2015-04-21 00:44\ncategory: [Java]\ntags: [地图]\n---\n\n##使用百度地图计算\nhttp://api.map.baidu.com/library/GeoUtils/1.2/examples/simple.html\nhttp://api.map.baidu.com/library/GeoUtils/1.2/docs/symbols/BMapLib.GeoUtils.html\n\n##使用java计算\n\n```java\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 功能说明：坐标几何运算\n * 作者：liuxing(2015-04-20 22:19)\n */\npublic class GeoUtils {\n\n    /**\n     * 检查一个坐标是否在多边形内\n     * @param x 纬度 31.000...\n     * @param y 经度 121.000...\n     * @param polygonPoints 多边形边界的经纬度数组\n     * @return\n     */\n    public static boolean isPointInPolygon(double x, double y, List<Map<String, Double>> polygonPoints) {\n        Point2D.Double geoPoint = buildPoint(x, y);\n        List<Point2D.Double> geoPolygon = buildPolygon(polygonPoints);\n        return GeoUtils.isPointInPolygon(geoPoint, geoPolygon);\n    }\n\n    /**\n     * 检查一个坐标是否在多边形内\n     * @param point 检查的点坐标\n     * @param polygon 参照的多边形\n     * @return\n     */\n    public static boolean isPointInPolygon(Point2D.Double point, List<Point2D.Double> polygon) {\n        GeneralPath p = new GeneralPath();\n\n        Point2D.Double first = polygon.get(0);\n        p.moveTo(first.x, first.y);\n        polygon.remove(0);\n\n        polygon.forEach(d -> p.lineTo(d.x, d.y));\n\n        p.lineTo(first.x, first.y);\n\n        p.closePath();\n\n        return p.contains(point);\n    }\n\n    /**\n     * 构建一个坐标点\n     * @param x 纬度 31.000...\n     * @param y 经度 121.000...\n     * @return\n     */\n    public static Point2D.Double buildPoint(double x, double y) {\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * 构建一个多边形\n     * @param polygonPoints\n     * @return\n     */\n    public static List<Point2D.Double> buildPolygon(List<Map<String, Double>> polygonPoints) {\n        List<Point2D.Double> geoPolygon = new ArrayList<>();\n\n        polygonPoints.forEach(map -> geoPolygon.add(buildPoint(map.get(\"x\"), map.get(\"y\"))));\n\n        return geoPolygon;\n    }\n\n}\n```\n\n更多运算场景请参考：\nhttp://docs.oracle.com/javase/8/docs/api/java/awt/Polygon.html\n\n##使用数据库计算\nSqlServer2008以上，暂未尝试","slug":"计算地图坐标是否在多边形内","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb34000j970qeg5frpgy"},{"title":"美到极致是疯狂","date":"2012-07-04T15:57:00.000Z","_content":"看到一篇很有共鸣的文章，写此自省！也希望对大家有意！\n\n##什么是代码高手？你怎么证明自己是代码高手？\n知道许多代码技巧、JS炫彩技巧的人大有人在。你知道多少个java函数，这一点都没有意义。你知道多少个新鲜IT名词，多少技术介绍，这也没有意义。做，真正做一个原型，做一个项目，解决你手头棘手的问题，这才有意义。\n- 快速准确的理解别人说的。\n- 快速的开发，还准确的反映了别人的需求。\n- 稳定，最少出BUG。\n- 高性能，10万条记录你能顶住，1000万条记录你能顶住吗？这就是技术功底的考验。\n- 这还不够，你的代码是否能让别人快速的理解了。\n- 你的代码是否能比较容易的接受不同客户的需求差异。\n这都是处处要你的分析功底、架构功底、编码功底。\n\n##怎么炼成高手？\n- 阅读优秀的开源源代码。先找代码量不大的。要彻底的阅读，剖析清楚有多少个类，这些类的关系。为什么要设计这样的类架构，为什么要这样设计接口。这些思考相当有深度。\n- 根据你的需求，把开源源代码进行修改。因为开源源代码是浑然一体，你加的功能是否很好和现有代码融合。这相当考验功底。\n- 读书，谁发明的这个东西就读谁的书。如想学 SQLSERVER，就一定要读SQLSERVER开发经理或技术小组写的书。别人写的书都会有歧义。要读透，反复阅读它的设计原理。不要只学会使用。比如说SQLSERVER，写SQL和SP就是懂SQLSERVER？我们一定要明白到SQLSERVER的数据页面是如何组织的，为什么要这样组织，它是怎样被载入内存中，它又是怎样回写到物理设备上。我们要到这个深度。否则，你只能是知道个皮毛，平时看是高手，一到真正难关立马歇菜。\n如果你学的技术还不能帮助你解决你目前手头的问题，说明你还学的不到位。\n- 找到你的师傅。一个人的成长，很难是自己一个人苦苦学习摸索修炼。这样提升很慢。你如果想快速发展，你必须找到你在这家公司中的引路人。他可能是你的入职指引人，也可能是别人。你一定要好好观察，看中了就一定要积极联系上他紧紧的跟随着他，平时多请教多观察他的思考方式做事方式。\n- 给自己树立一个信念：我要在X年中成为公司所有人公认的技术高手。我要在X年终成为中国软件业一流的程序员。必须设立目标，而且时时刻刻为这个目标奋斗，坚持每天阅读、思考、开发、修改代码达到13-16个小时以上。有一个故事讲的就是每件事要想做专业必须要经过1万个小时的反复练习才能成功。对，我说的就是这个意思。不疯魔不成活。\n\n##最后一句话！\n美到极致是疯狂。希望大家在平时工作中开发每一个产品时，都能暗下决心：It's My Baby!\n对，它就是你创造的孩子，你要用心去雕琢它呵护它。","source":"_posts/美到极致是疯狂.md","raw":"title: \"美到极致是疯狂\"\ndate: 2012-07-04 23:57\ncategory: [心态]\ntags: []\n---\n看到一篇很有共鸣的文章，写此自省！也希望对大家有意！\n\n##什么是代码高手？你怎么证明自己是代码高手？\n知道许多代码技巧、JS炫彩技巧的人大有人在。你知道多少个java函数，这一点都没有意义。你知道多少个新鲜IT名词，多少技术介绍，这也没有意义。做，真正做一个原型，做一个项目，解决你手头棘手的问题，这才有意义。\n- 快速准确的理解别人说的。\n- 快速的开发，还准确的反映了别人的需求。\n- 稳定，最少出BUG。\n- 高性能，10万条记录你能顶住，1000万条记录你能顶住吗？这就是技术功底的考验。\n- 这还不够，你的代码是否能让别人快速的理解了。\n- 你的代码是否能比较容易的接受不同客户的需求差异。\n这都是处处要你的分析功底、架构功底、编码功底。\n\n##怎么炼成高手？\n- 阅读优秀的开源源代码。先找代码量不大的。要彻底的阅读，剖析清楚有多少个类，这些类的关系。为什么要设计这样的类架构，为什么要这样设计接口。这些思考相当有深度。\n- 根据你的需求，把开源源代码进行修改。因为开源源代码是浑然一体，你加的功能是否很好和现有代码融合。这相当考验功底。\n- 读书，谁发明的这个东西就读谁的书。如想学 SQLSERVER，就一定要读SQLSERVER开发经理或技术小组写的书。别人写的书都会有歧义。要读透，反复阅读它的设计原理。不要只学会使用。比如说SQLSERVER，写SQL和SP就是懂SQLSERVER？我们一定要明白到SQLSERVER的数据页面是如何组织的，为什么要这样组织，它是怎样被载入内存中，它又是怎样回写到物理设备上。我们要到这个深度。否则，你只能是知道个皮毛，平时看是高手，一到真正难关立马歇菜。\n如果你学的技术还不能帮助你解决你目前手头的问题，说明你还学的不到位。\n- 找到你的师傅。一个人的成长，很难是自己一个人苦苦学习摸索修炼。这样提升很慢。你如果想快速发展，你必须找到你在这家公司中的引路人。他可能是你的入职指引人，也可能是别人。你一定要好好观察，看中了就一定要积极联系上他紧紧的跟随着他，平时多请教多观察他的思考方式做事方式。\n- 给自己树立一个信念：我要在X年中成为公司所有人公认的技术高手。我要在X年终成为中国软件业一流的程序员。必须设立目标，而且时时刻刻为这个目标奋斗，坚持每天阅读、思考、开发、修改代码达到13-16个小时以上。有一个故事讲的就是每件事要想做专业必须要经过1万个小时的反复练习才能成功。对，我说的就是这个意思。不疯魔不成活。\n\n##最后一句话！\n美到极致是疯狂。希望大家在平时工作中开发每一个产品时，都能暗下决心：It's My Baby!\n对，它就是你创造的孩子，你要用心去雕琢它呵护它。","slug":"美到极致是疯狂","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb37000m970qzp02v7nd"},{"title":"我编程我快乐","date":"2014-12-10T06:51:20.000Z","_content":"\n感觉还不错，分享一下！\n\n![01](/images/bianchenghappy/01.png)\n\n![02](/images/bianchenghappy/02.png)\n\n![03](/images/bianchenghappy/03.png)\n\n![04](/images/bianchenghappy/04.png)\n\n**你懂的！**\n\n链接: http://pan.baidu.com/s/1nqpGE 密码: k2un","source":"_posts/我编程我快乐.md","raw":"title: \"我编程我快乐\"\ndate: 2014-12-10 14:51:20\ncategory: [书摘]\ntags: [编程,心态,职业发展]\n---\n\n感觉还不错，分享一下！\n\n![01](/images/bianchenghappy/01.png)\n\n![02](/images/bianchenghappy/02.png)\n\n![03](/images/bianchenghappy/03.png)\n\n![04](/images/bianchenghappy/04.png)\n\n**你懂的！**\n\n链接: http://pan.baidu.com/s/1nqpGE 密码: k2un","slug":"我编程我快乐","published":1,"updated":"2015-06-11T21:24:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb39000o970qim873640"},{"title":"引入公共头部时，控制引入js、css、title","date":"2012-08-15T16:10:00.000Z","_content":"\n引入公共头部时，控制引入js、css、title，避免重复造轮子，能少敲点代码就少敲点\n\n1.头部或底部文件中引入jstl的标签库\n\n```xml\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>  \n<%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %>  \n```\n\n2.这一部分放入公共的头或底部文件中，放置在待引入css和js的位置，两种方式具体应用中有细微差别\n\n```xml\n<!-- 1.可以分开引入 -->\n<c:if test=\"${ not empty param.css}\">\n\t<c:forEach var=\"css\" items=\"${fn:split(param.css, ',')}\">\n        <c:if test=\"${not empty css}\">\n\t\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"/static/css/${css}\">\n        </c:if>\n\t</c:forEach>\n</c:if>\n\n<c:if test=\"${ not empty param.js || not empty param.ajs}\">\n\t<c:forEach var=\"js\" items=\"${fn:split(param.js, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t    <script type=\"text/javascript\" src=\"/static/js/${js }\"></script>\n        </c:if>\n\t</c:forEach>\n\n    <c:forEach var=\"js\" items=\"${fn:split(param.ajs, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t\t<script type=\"text/javascript\" src=\"${js }\"></script>\n        </c:if>\n\t</c:forEach>\n</c:if>\n\n<!-- 2.或者可以一起引入 -->\n<c:if test=\"${not empty param.css || not empty param.js || not empty param.ajs}\">\n\t<c:forEach var=\"css\" items=\"${fn:split(param.css, ',')}\">\n        <c:if test=\"${not empty css}\">\n\t\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"/static/css/${css}\">\n        </c:if>\n\t</c:forEach>\n\n\t<c:forEach var=\"js\" items=\"${fn:split(param.js, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t    <script type=\"text/javascript\" src=\"/static/js/${js }\"></script>\n        </c:if>\n\t</c:forEach>\n\n    <c:forEach var=\"js\" items=\"${fn:split(param.ajs, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t\t<script type=\"text/javascript\" src=\"${js }\"></script>\n        </c:if>\n\t</c:forEach>\n</c:if>\n```\n\n3.这一部分放置在引入公共头部或底部的页面中\n\n```xml\n<!-- ajs表示引入外部的js，在实现中是直接src=ajs；js表示引入系统内部的js，在实现中是直接src=\"公共的路径\"+ajs -->\n<!-- 这里还可以声明头部的title等其他的参数,参数是自定义的 在头部或底部文件里直接使用”${param.参数 }“就可以拿到 -->\n<jsp:include page=\"../common/header.jsp\">\n    <jsp:param name=\"css\" value=\"test.css\"/>\n    <jsp:param name=\"js\" value=\"test.js,test2.js\"/>\n    <jsp:param name=\"ajs\" value=\"http://test.js, http://test2.js\"/>\n</jsp:include>\n```\n\ncss也可以使用类似js的方式。","source":"_posts/引入公共头部时，控制引入js、css、title.md","raw":"title: \"引入公共头部时，控制引入js、css、title\"\ndate: 2012-08-16 00:10\ncategory: [Java]\ntags: []\n---\n\n引入公共头部时，控制引入js、css、title，避免重复造轮子，能少敲点代码就少敲点\n\n1.头部或底部文件中引入jstl的标签库\n\n```xml\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>  \n<%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %>  \n```\n\n2.这一部分放入公共的头或底部文件中，放置在待引入css和js的位置，两种方式具体应用中有细微差别\n\n```xml\n<!-- 1.可以分开引入 -->\n<c:if test=\"${ not empty param.css}\">\n\t<c:forEach var=\"css\" items=\"${fn:split(param.css, ',')}\">\n        <c:if test=\"${not empty css}\">\n\t\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"/static/css/${css}\">\n        </c:if>\n\t</c:forEach>\n</c:if>\n\n<c:if test=\"${ not empty param.js || not empty param.ajs}\">\n\t<c:forEach var=\"js\" items=\"${fn:split(param.js, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t    <script type=\"text/javascript\" src=\"/static/js/${js }\"></script>\n        </c:if>\n\t</c:forEach>\n\n    <c:forEach var=\"js\" items=\"${fn:split(param.ajs, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t\t<script type=\"text/javascript\" src=\"${js }\"></script>\n        </c:if>\n\t</c:forEach>\n</c:if>\n\n<!-- 2.或者可以一起引入 -->\n<c:if test=\"${not empty param.css || not empty param.js || not empty param.ajs}\">\n\t<c:forEach var=\"css\" items=\"${fn:split(param.css, ',')}\">\n        <c:if test=\"${not empty css}\">\n\t\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"/static/css/${css}\">\n        </c:if>\n\t</c:forEach>\n\n\t<c:forEach var=\"js\" items=\"${fn:split(param.js, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t    <script type=\"text/javascript\" src=\"/static/js/${js }\"></script>\n        </c:if>\n\t</c:forEach>\n\n    <c:forEach var=\"js\" items=\"${fn:split(param.ajs, ',')}\">\n        <c:if test=\"${not empty js}\">\n\t\t\t<script type=\"text/javascript\" src=\"${js }\"></script>\n        </c:if>\n\t</c:forEach>\n</c:if>\n```\n\n3.这一部分放置在引入公共头部或底部的页面中\n\n```xml\n<!-- ajs表示引入外部的js，在实现中是直接src=ajs；js表示引入系统内部的js，在实现中是直接src=\"公共的路径\"+ajs -->\n<!-- 这里还可以声明头部的title等其他的参数,参数是自定义的 在头部或底部文件里直接使用”${param.参数 }“就可以拿到 -->\n<jsp:include page=\"../common/header.jsp\">\n    <jsp:param name=\"css\" value=\"test.css\"/>\n    <jsp:param name=\"js\" value=\"test.js,test2.js\"/>\n    <jsp:param name=\"ajs\" value=\"http://test.js, http://test2.js\"/>\n</jsp:include>\n```\n\ncss也可以使用类似js的方式。","slug":"引入公共头部时，控制引入js、css、title","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3c000x970q1rt5ovg4"},{"title":"在windows和linux上安装ImageMagick与Jmagick","date":"2013-12-19T16:29:00.000Z","_content":"\n##Linux安装Jmagick\n###下载JMagick和ImageMagick\nhttp://downloads.jmagick.org/6.4.0/jmagick-6.4.0-src.tar.gz  \nhttp://downloads.jmagick.org/6.4.0/ImageMagick-6.4.0-0.tar.gz  \n\n文件存到一个指定目录，如/usr/local/ImageMagick，该目录就是后续的安装目录\n\n###安装依赖包\nyum install libpng \nyum install libpng-devel \nyum install libjpeg \nyum install libjpeg-devel \nyum install gd \nyum install gd-devel \nyum install libtiff \nyum install libtiff-devel \nyum install gcc （很重要）\nyum install zlib(可选)\n是zlib通用压缩库，图形格式png使用zlib中的deflate压缩算法\n\n\n###安装ImageMagick\n\n`cd /usr/local/ImageMagick`\n \n1.解压\n\n`tar zxf ImageMagick-6.4.0-0.tar.gz `\n\n2.切换到解压目录\n\n`cd ImageMagick-6.4.0`\n\n3.编译源文件\n\n`./configure --prefix=/usr/local/ImageMagick --enable-shared --without-perl --with-quantum-depth=8`\n\nconfigure参数说明：\n--enable-shared 编译成共享库(建议)\n--disable-static 不编译成静态库\n--with-quantum-depth=8 使用8位色深。我的1200万像素数码相机，照出的图片就是8位色深。(建议)\n--with-windows-font-dir=目录 ，指明字体文件的目录（后面将人工复制中文字体文件到这个目录）(可选)\n--disable-openmp 禁用多线程，使用多线程性能并没有提高，但CPU占用达到了100%，所以禁用了。(可选)\n\n\n###安装（需要几分钟时间）\n`make && make install`\n\n \n由于ImageMagic被安装在我们自行指定的/usr/local/ImageMagick，后面安装JMagic会找不到需要用到的ImageMagic的命令和库，因此需要配置一下操作系统： \n\n\n1.编辑/etc/profile里面的PATH环境变量：\n`vi /etc/profile`\n\n结尾加入：\n`export PATH=/usr/local/ImageMagick/bin:$PATH `\n\n2.编辑/etc/ld.so.conf\n`vi /etc/ld.so.conf`\n\n加入：\n`/usr/local/ImageMagick/lib `\n\n3.执行命令，将ImageMagick的库加入系统联接库：\n`ldconfig `\n\n4.重新登录\n5.查看版本：\n`convert --version`\n\n \n例如：\n\n`convert —version`\n`Version: ImageMagick 6.4.0 12/27/11 Q16 http://www.imagemagick.org`\n`Copyright: Copyright (C) 1999-2008 ImageMagick Studio LLC`\n\n\n###安装并配置JMagick\n\n\n1.解压\n`tar xzvf jmagick-6.4.0-src.tar.gz `\n\n2.解压源码移入/usr/local/jmagick\n`mv 6.4.0/ /usr/local/jmagick`\n\n3.切换到目录\n`cd /usr/local/jmagick/`\n\n4.查看所有环境变量\n`env`\n\n5.编译源文件\n`./configure --with-java-home=/usr/java/jdk1.7.0/ --with-magick-home=/usr/local/ImageMagick`\n\n6.安装（需要几分钟）\n`make && make install`\n\n7.保证已经配置好环境变量\n`$JAVA_HOME 和  $JRE_HOME`\n切换到用户根目录查看\n`vi /.bash_profile`\n`vi /home/loupan/.bash_profile`\n...\n\n如：\n`export JAVA_HOME=/usr/local/java/jdk1.7.0_45`\n`export JRE_HOME=/usr/local/java/jdk1.7.0_45/jre`\n`export PATH=$JAVA_HOME/bin:$PATH`\n`export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar `\n\n\n8.拷贝依赖文件到jdk\n`cp /usr/local/jmagick/lib/libJMagick-6.4.0.so $JAVA_HOME/jre/lib/amd64/libJMagick.so`\n`cp /usr/local/jmagick/lib/jmagick-6.4.0.jar $JRE_HOME/lib/jmagick.jar`\n\n\n备注：\n\n`$JAVA_HOME=/usr/java/jdk1.7.0/`\n`$JRE_HOME=$JAVA_HOME/jre`\n\n##windows安装Jmagick \n\n以ImageMagick-6.3.9-0-Q16-windows-dll.exe安装到windows为例，\n\n下载ImageMagick-6.3.9-0-Q16-windows-dll.exe和jmagick-win-6.3.9-Q16.zip\n\n1.下载ImageMagick-6.3.9-0-Q16-windows-dll.exe安装，在那个多选界面请选择所有内容(是一些依赖的库，避免出现不可预知的错误)。\n2.检查看系统环境变量PATH里面是否添加了环境变量，如果没有需要添加安装路径。\n3.将jmagick.dll拷贝到C:/windows/system32目录下。\n4.将jmagick.dll拷贝到%TOMECAT%/bin目录下。\n5.将jmagick.dll拷贝到%JAVA_HOME%/bin目录下。\n6.还要把jmagick.jar复制到%JAVA_HOME%/jre/lib/ext下\n7.还要把jmagick.jar复制到%TOMCAT%/lib下\n8.使用时将jmagick.jar拷贝到项目，在类里加上静态块，用系统的类加载器指定，否则会出现类无法加载。\n\n```java\nstatic {\n     // 如果部署到WEB应用，就要加下面这句。不然会报“UnsatisfiedLinkError: no JMagick in\n    // java.library.path”。\n    System. setProperty(\"jmagick.systemclassloader\", \"no\");\n}\n```\n \n##参考\nhttp://xlogin.blog.51cto.com/3473583/717321\nhttp://elf8848.iteye.com/blog/455675","source":"_posts/在windows和linux上安装ImageMagick与Jmagick.md","raw":"title: \"在windows和linux上安装ImageMagick与Jmagick\"\ndate: 2013-12-20 00:29\ncategory: [Java]\ntags: [jmagick,linux,windows]\n---\n\n##Linux安装Jmagick\n###下载JMagick和ImageMagick\nhttp://downloads.jmagick.org/6.4.0/jmagick-6.4.0-src.tar.gz  \nhttp://downloads.jmagick.org/6.4.0/ImageMagick-6.4.0-0.tar.gz  \n\n文件存到一个指定目录，如/usr/local/ImageMagick，该目录就是后续的安装目录\n\n###安装依赖包\nyum install libpng \nyum install libpng-devel \nyum install libjpeg \nyum install libjpeg-devel \nyum install gd \nyum install gd-devel \nyum install libtiff \nyum install libtiff-devel \nyum install gcc （很重要）\nyum install zlib(可选)\n是zlib通用压缩库，图形格式png使用zlib中的deflate压缩算法\n\n\n###安装ImageMagick\n\n`cd /usr/local/ImageMagick`\n \n1.解压\n\n`tar zxf ImageMagick-6.4.0-0.tar.gz `\n\n2.切换到解压目录\n\n`cd ImageMagick-6.4.0`\n\n3.编译源文件\n\n`./configure --prefix=/usr/local/ImageMagick --enable-shared --without-perl --with-quantum-depth=8`\n\nconfigure参数说明：\n--enable-shared 编译成共享库(建议)\n--disable-static 不编译成静态库\n--with-quantum-depth=8 使用8位色深。我的1200万像素数码相机，照出的图片就是8位色深。(建议)\n--with-windows-font-dir=目录 ，指明字体文件的目录（后面将人工复制中文字体文件到这个目录）(可选)\n--disable-openmp 禁用多线程，使用多线程性能并没有提高，但CPU占用达到了100%，所以禁用了。(可选)\n\n\n###安装（需要几分钟时间）\n`make && make install`\n\n \n由于ImageMagic被安装在我们自行指定的/usr/local/ImageMagick，后面安装JMagic会找不到需要用到的ImageMagic的命令和库，因此需要配置一下操作系统： \n\n\n1.编辑/etc/profile里面的PATH环境变量：\n`vi /etc/profile`\n\n结尾加入：\n`export PATH=/usr/local/ImageMagick/bin:$PATH `\n\n2.编辑/etc/ld.so.conf\n`vi /etc/ld.so.conf`\n\n加入：\n`/usr/local/ImageMagick/lib `\n\n3.执行命令，将ImageMagick的库加入系统联接库：\n`ldconfig `\n\n4.重新登录\n5.查看版本：\n`convert --version`\n\n \n例如：\n\n`convert —version`\n`Version: ImageMagick 6.4.0 12/27/11 Q16 http://www.imagemagick.org`\n`Copyright: Copyright (C) 1999-2008 ImageMagick Studio LLC`\n\n\n###安装并配置JMagick\n\n\n1.解压\n`tar xzvf jmagick-6.4.0-src.tar.gz `\n\n2.解压源码移入/usr/local/jmagick\n`mv 6.4.0/ /usr/local/jmagick`\n\n3.切换到目录\n`cd /usr/local/jmagick/`\n\n4.查看所有环境变量\n`env`\n\n5.编译源文件\n`./configure --with-java-home=/usr/java/jdk1.7.0/ --with-magick-home=/usr/local/ImageMagick`\n\n6.安装（需要几分钟）\n`make && make install`\n\n7.保证已经配置好环境变量\n`$JAVA_HOME 和  $JRE_HOME`\n切换到用户根目录查看\n`vi /.bash_profile`\n`vi /home/loupan/.bash_profile`\n...\n\n如：\n`export JAVA_HOME=/usr/local/java/jdk1.7.0_45`\n`export JRE_HOME=/usr/local/java/jdk1.7.0_45/jre`\n`export PATH=$JAVA_HOME/bin:$PATH`\n`export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar `\n\n\n8.拷贝依赖文件到jdk\n`cp /usr/local/jmagick/lib/libJMagick-6.4.0.so $JAVA_HOME/jre/lib/amd64/libJMagick.so`\n`cp /usr/local/jmagick/lib/jmagick-6.4.0.jar $JRE_HOME/lib/jmagick.jar`\n\n\n备注：\n\n`$JAVA_HOME=/usr/java/jdk1.7.0/`\n`$JRE_HOME=$JAVA_HOME/jre`\n\n##windows安装Jmagick \n\n以ImageMagick-6.3.9-0-Q16-windows-dll.exe安装到windows为例，\n\n下载ImageMagick-6.3.9-0-Q16-windows-dll.exe和jmagick-win-6.3.9-Q16.zip\n\n1.下载ImageMagick-6.3.9-0-Q16-windows-dll.exe安装，在那个多选界面请选择所有内容(是一些依赖的库，避免出现不可预知的错误)。\n2.检查看系统环境变量PATH里面是否添加了环境变量，如果没有需要添加安装路径。\n3.将jmagick.dll拷贝到C:/windows/system32目录下。\n4.将jmagick.dll拷贝到%TOMECAT%/bin目录下。\n5.将jmagick.dll拷贝到%JAVA_HOME%/bin目录下。\n6.还要把jmagick.jar复制到%JAVA_HOME%/jre/lib/ext下\n7.还要把jmagick.jar复制到%TOMCAT%/lib下\n8.使用时将jmagick.jar拷贝到项目，在类里加上静态块，用系统的类加载器指定，否则会出现类无法加载。\n\n```java\nstatic {\n     // 如果部署到WEB应用，就要加下面这句。不然会报“UnsatisfiedLinkError: no JMagick in\n    // java.library.path”。\n    System. setProperty(\"jmagick.systemclassloader\", \"no\");\n}\n```\n \n##参考\nhttp://xlogin.blog.51cto.com/3473583/717321\nhttp://elf8848.iteye.com/blog/455675","slug":"在windows和linux上安装ImageMagick与Jmagick","published":1,"updated":"2015-06-11T08:15:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3f000z970q88ln2d62"},{"title":"使用spring4.x的websocket支持","date":"2015-04-20T16:48:00.000Z","_content":"\nJ2EE7版（JSR-356） \nhttp://liuxing.info/2015/02/09/websocket-demo\n\n相关依赖请参考上文，spring需要4.x\n\n\n##websocket处理器\n\n```java\nimport org.apache.commons.collections.MapUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.socket.CloseStatus;\nimport org.springframework.web.socket.TextMessage;\nimport org.springframework.web.socket.WebSocketHandler;\nimport org.springframework.web.socket.WebSocketSession;\nimport org.springframework.web.socket.handler.BinaryWebSocketHandler;\nimport org.springframework.web.socket.handler.TextWebSocketHandler;\n\n/**\n * 功能说明：WebSocket处理器\n * 可以继承 {@link TextWebSocketHandler}/{@link BinaryWebSocketHandler}，\n * 或者简单的实现{@link WebSocketHandler}接口\n * 作者：liuxing(2015-01-25 03:42)\n */\npublic class TelWebSocketHandler extends TextWebSocketHandler {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TelWebSocketHandler.class);\n\n    /**\n     * 建立连接\n     * @param session\n     * @throws Exception\n     */\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n        TelSocketSessionUtils.add(inquiryId, empNo, session);\n    }\n\n    /**\n     * 收到客户端消息\n     * @param session\n     * @param message\n     * @throws Exception\n     */\n    @Override\n    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n        TelSocketSessionUtils.sendMessage(inquiryId, empNo, \"【来自服务器的复读机】：\" + message.getPayload().toString());\n    }\n\n    /**\n     * 出现异常\n     * @param session\n     * @param exception\n     * @throws Exception\n     */\n    @Override\n    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n\n        LOGGER.error(\"websocket connection exception: \" + TelSocketSessionUtils.getKey(inquiryId, empNo));\n        LOGGER.error(exception.getMessage(), exception);\n\n        TelSocketSessionUtils.remove(inquiryId, empNo);\n    }\n\n    /**\n     * 连接关闭\n     * @param session\n     * @param closeStatus\n     * @throws Exception\n     */\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n        TelSocketSessionUtils.remove(inquiryId, empNo);\n    }\n\n    /**\n     * 是否分段发送消息\n     * @return\n     */\n    @Override\n    public boolean supportsPartialMessages() {\n        return false;\n    }\n\n}\n```\n\n##websocket连接的拦截器\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.server.ServerHttpRequest;\nimport org.springframework.http.server.ServerHttpResponse;\nimport org.springframework.http.server.ServletServerHttpRequest;\nimport org.springframework.web.socket.WebSocketHandler;\nimport org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.util.Map;\n\n/**\n * 功能说明：websocket连接的拦截器\n * 有两种方式\n *          一种是实现接口HandshakeInterceptor，实现beforeHandshake和afterHandshake函数\n *          一种是继承HttpSessionHandshakeInterceptor，重载beforeHandshake和afterHandshake函数\n * 我这里是参照spring官方文档中的继承HttpSessionHandshakeInterceptor的方式\n * 作者：liuxing(2015-01-25 03:46)\n */\npublic class TelWebSocketHandshakeInterceptor extends HttpSessionHandshakeInterceptor {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TelWebSocketHandshakeInterceptor.class);\n\n    /**\n     * 从请求中获取唯一标记参数，填充到数据传递容器attributes\n     * @param serverHttpRequest\n     * @param serverHttpResponse\n     * @param wsHandler\n     * @param attributes\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public boolean beforeHandshake(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {\n        if (getSession(serverHttpRequest) != null) {\n            ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) serverHttpRequest;\n            HttpServletRequest request = servletRequest.getServletRequest();\n            attributes.put(\"inquiryId\", request.getParameter(\"inquiryId\"));\n            attributes.put(\"empNo\", request.getParameter(\"empNo\"));\n        }\n\n        super.beforeHandshake(serverHttpRequest, serverHttpResponse, wsHandler, attributes);\n\n        return true;\n    }\n\n    @Override\n    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) {\n        super.afterHandshake(request, response, wsHandler, ex);\n    }\n\n    private HttpSession getSession(ServerHttpRequest request) {\n        if (request instanceof ServletServerHttpRequest) {\n            ServletServerHttpRequest serverRequest = (ServletServerHttpRequest) request;\n            return serverRequest.getServletRequest().getSession(false);\n        }\n        return null;\n    }\n\n}\n```\n\n##session工具类\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.socket.TextMessage;\nimport org.springframework.web.socket.WebSocketSession;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 功能说明：TelSocketSessionUtils\n * 作者：liuxing(2014-12-26 02:32)\n */\npublic class TelSocketSessionUtils {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TelSocketSessionUtils.class);\n\n    private static Map<String, WebSocketSession> clients = new ConcurrentHashMap<>();\n\n    /**\n     * 保存一个连接\n     * @param inquiryId\n     * @param empNo\n     * @param session\n     */\n    public static void add(String inquiryId, int empNo, WebSocketSession session){\n        clients.put(getKey(inquiryId, empNo), session);\n    }\n\n    /**\n     * 获取一个连接\n     * @param inquiryId\n     * @param empNo\n     * @return\n     */\n    public static WebSocketSession get(String inquiryId, int empNo){\n        return clients.get(getKey(inquiryId, empNo));\n    }\n\n    /**\n     * 移除一个连接\n     * @param inquiryId\n     * @param empNo\n     */\n    public static void remove(String inquiryId, int empNo) throws IOException {\n        clients.remove(getKey(inquiryId, empNo));\n    }\n\n    /**\n     * 组装sessionId\n     * @param inquiryId\n     * @param empNo\n     * @return\n     */\n    public static String getKey(String inquiryId, int empNo) {\n        return inquiryId + \"_\" + empNo;\n    }\n\n    /**\n     * 判断是否有效连接\n     * 判断是否存在\n     * 判断连接是否开启\n     * 无效的进行清除\n     * @param inquiryId\n     * @param empNo\n     * @return\n     */\n    public static boolean hasConnection(String inquiryId, int empNo) {\n        String key = getKey(inquiryId, empNo);\n        if (clients.containsKey(key)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * 获取连接数的数量\n     * @return\n     */\n    public static int getSize() {\n        return clients.size();\n    }\n\n    /**\n     * 发送消息到客户端\n     * @param inquiryId\n     * @param empNo\n     * @param message\n     * @throws Exception\n     */\n    public static void sendMessage(String inquiryId, int empNo, String message) throws Exception {\n        if (!hasConnection(inquiryId, empNo)) {\n            throw new NullPointerException(getKey(inquiryId, empNo) + \" connection does not exist\");\n        }\n\n        WebSocketSession session = get(inquiryId, empNo);\n        try {\n            session.sendMessage(new TextMessage(message));\n        } catch (IOException e) {\n            LOGGER.error(\"websocket sendMessage exception: \" + getKey(inquiryId, empNo));\n            LOGGER.error(e.getMessage(), e);\n            clients.remove(getKey(inquiryId, empNo));\n        }\n    }\n\n}\n```\n\n##初始化配置\n```xml\n<!--websocket配置-->\n<bean id=\"telWebSocketHandler\" class=\"包.websocket.handler.TelWebSocketHandler\"/>\n\n<websocket:handlers allowed-origins=\"*\">\n    <websocket:mapping path=\"webSocketStatus\" handler=\"telWebSocketHandler\"/>\n    <websocket:handshake-interceptors>\n        <bean class=\"包.websocket.interceptor.TelWebSocketHandshakeInterceptor\"/>\n    </websocket:handshake-interceptors>\n</websocket:handlers>\n\n<bean class=\"org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean\">\n    <property name=\"maxTextMessageBufferSize\" value=\"8192\"/>\n    <property name=\"maxBinaryMessageBufferSize\" value=\"8192\"/>\n    <property name=\"maxSessionIdleTimeout\" value=\"900000\"/>\n    <property name=\"asyncSendTimeout\" value=\"5000\"/>\n</bean>\n```\n\nspring官方文档已经写得很齐全了，更多场景和说明请参阅下文大笑\nhttp://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#websocket\n","source":"_posts/使用spring4.x的websocket支持.md","raw":"title: \"使用spring4.x的websocket支持\"\ndate: 2015-04-21 00:48\ncategory: [Java]\ntags: [spring,websocket]\n---\n\nJ2EE7版（JSR-356） \nhttp://liuxing.info/2015/02/09/websocket-demo\n\n相关依赖请参考上文，spring需要4.x\n\n\n##websocket处理器\n\n```java\nimport org.apache.commons.collections.MapUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.socket.CloseStatus;\nimport org.springframework.web.socket.TextMessage;\nimport org.springframework.web.socket.WebSocketHandler;\nimport org.springframework.web.socket.WebSocketSession;\nimport org.springframework.web.socket.handler.BinaryWebSocketHandler;\nimport org.springframework.web.socket.handler.TextWebSocketHandler;\n\n/**\n * 功能说明：WebSocket处理器\n * 可以继承 {@link TextWebSocketHandler}/{@link BinaryWebSocketHandler}，\n * 或者简单的实现{@link WebSocketHandler}接口\n * 作者：liuxing(2015-01-25 03:42)\n */\npublic class TelWebSocketHandler extends TextWebSocketHandler {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TelWebSocketHandler.class);\n\n    /**\n     * 建立连接\n     * @param session\n     * @throws Exception\n     */\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n        TelSocketSessionUtils.add(inquiryId, empNo, session);\n    }\n\n    /**\n     * 收到客户端消息\n     * @param session\n     * @param message\n     * @throws Exception\n     */\n    @Override\n    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n        TelSocketSessionUtils.sendMessage(inquiryId, empNo, \"【来自服务器的复读机】：\" + message.getPayload().toString());\n    }\n\n    /**\n     * 出现异常\n     * @param session\n     * @param exception\n     * @throws Exception\n     */\n    @Override\n    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n\n        LOGGER.error(\"websocket connection exception: \" + TelSocketSessionUtils.getKey(inquiryId, empNo));\n        LOGGER.error(exception.getMessage(), exception);\n\n        TelSocketSessionUtils.remove(inquiryId, empNo);\n    }\n\n    /**\n     * 连接关闭\n     * @param session\n     * @param closeStatus\n     * @throws Exception\n     */\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n        String inquiryId = MapUtils.getString(session.getAttributes(), \"inquiryId\");\n        int empNo = MapUtils.getInteger(session.getAttributes(), \"empNo\");\n        TelSocketSessionUtils.remove(inquiryId, empNo);\n    }\n\n    /**\n     * 是否分段发送消息\n     * @return\n     */\n    @Override\n    public boolean supportsPartialMessages() {\n        return false;\n    }\n\n}\n```\n\n##websocket连接的拦截器\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.server.ServerHttpRequest;\nimport org.springframework.http.server.ServerHttpResponse;\nimport org.springframework.http.server.ServletServerHttpRequest;\nimport org.springframework.web.socket.WebSocketHandler;\nimport org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.util.Map;\n\n/**\n * 功能说明：websocket连接的拦截器\n * 有两种方式\n *          一种是实现接口HandshakeInterceptor，实现beforeHandshake和afterHandshake函数\n *          一种是继承HttpSessionHandshakeInterceptor，重载beforeHandshake和afterHandshake函数\n * 我这里是参照spring官方文档中的继承HttpSessionHandshakeInterceptor的方式\n * 作者：liuxing(2015-01-25 03:46)\n */\npublic class TelWebSocketHandshakeInterceptor extends HttpSessionHandshakeInterceptor {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TelWebSocketHandshakeInterceptor.class);\n\n    /**\n     * 从请求中获取唯一标记参数，填充到数据传递容器attributes\n     * @param serverHttpRequest\n     * @param serverHttpResponse\n     * @param wsHandler\n     * @param attributes\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public boolean beforeHandshake(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {\n        if (getSession(serverHttpRequest) != null) {\n            ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) serverHttpRequest;\n            HttpServletRequest request = servletRequest.getServletRequest();\n            attributes.put(\"inquiryId\", request.getParameter(\"inquiryId\"));\n            attributes.put(\"empNo\", request.getParameter(\"empNo\"));\n        }\n\n        super.beforeHandshake(serverHttpRequest, serverHttpResponse, wsHandler, attributes);\n\n        return true;\n    }\n\n    @Override\n    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) {\n        super.afterHandshake(request, response, wsHandler, ex);\n    }\n\n    private HttpSession getSession(ServerHttpRequest request) {\n        if (request instanceof ServletServerHttpRequest) {\n            ServletServerHttpRequest serverRequest = (ServletServerHttpRequest) request;\n            return serverRequest.getServletRequest().getSession(false);\n        }\n        return null;\n    }\n\n}\n```\n\n##session工具类\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.socket.TextMessage;\nimport org.springframework.web.socket.WebSocketSession;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 功能说明：TelSocketSessionUtils\n * 作者：liuxing(2014-12-26 02:32)\n */\npublic class TelSocketSessionUtils {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TelSocketSessionUtils.class);\n\n    private static Map<String, WebSocketSession> clients = new ConcurrentHashMap<>();\n\n    /**\n     * 保存一个连接\n     * @param inquiryId\n     * @param empNo\n     * @param session\n     */\n    public static void add(String inquiryId, int empNo, WebSocketSession session){\n        clients.put(getKey(inquiryId, empNo), session);\n    }\n\n    /**\n     * 获取一个连接\n     * @param inquiryId\n     * @param empNo\n     * @return\n     */\n    public static WebSocketSession get(String inquiryId, int empNo){\n        return clients.get(getKey(inquiryId, empNo));\n    }\n\n    /**\n     * 移除一个连接\n     * @param inquiryId\n     * @param empNo\n     */\n    public static void remove(String inquiryId, int empNo) throws IOException {\n        clients.remove(getKey(inquiryId, empNo));\n    }\n\n    /**\n     * 组装sessionId\n     * @param inquiryId\n     * @param empNo\n     * @return\n     */\n    public static String getKey(String inquiryId, int empNo) {\n        return inquiryId + \"_\" + empNo;\n    }\n\n    /**\n     * 判断是否有效连接\n     * 判断是否存在\n     * 判断连接是否开启\n     * 无效的进行清除\n     * @param inquiryId\n     * @param empNo\n     * @return\n     */\n    public static boolean hasConnection(String inquiryId, int empNo) {\n        String key = getKey(inquiryId, empNo);\n        if (clients.containsKey(key)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * 获取连接数的数量\n     * @return\n     */\n    public static int getSize() {\n        return clients.size();\n    }\n\n    /**\n     * 发送消息到客户端\n     * @param inquiryId\n     * @param empNo\n     * @param message\n     * @throws Exception\n     */\n    public static void sendMessage(String inquiryId, int empNo, String message) throws Exception {\n        if (!hasConnection(inquiryId, empNo)) {\n            throw new NullPointerException(getKey(inquiryId, empNo) + \" connection does not exist\");\n        }\n\n        WebSocketSession session = get(inquiryId, empNo);\n        try {\n            session.sendMessage(new TextMessage(message));\n        } catch (IOException e) {\n            LOGGER.error(\"websocket sendMessage exception: \" + getKey(inquiryId, empNo));\n            LOGGER.error(e.getMessage(), e);\n            clients.remove(getKey(inquiryId, empNo));\n        }\n    }\n\n}\n```\n\n##初始化配置\n```xml\n<!--websocket配置-->\n<bean id=\"telWebSocketHandler\" class=\"包.websocket.handler.TelWebSocketHandler\"/>\n\n<websocket:handlers allowed-origins=\"*\">\n    <websocket:mapping path=\"webSocketStatus\" handler=\"telWebSocketHandler\"/>\n    <websocket:handshake-interceptors>\n        <bean class=\"包.websocket.interceptor.TelWebSocketHandshakeInterceptor\"/>\n    </websocket:handshake-interceptors>\n</websocket:handlers>\n\n<bean class=\"org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean\">\n    <property name=\"maxTextMessageBufferSize\" value=\"8192\"/>\n    <property name=\"maxBinaryMessageBufferSize\" value=\"8192\"/>\n    <property name=\"maxSessionIdleTimeout\" value=\"900000\"/>\n    <property name=\"asyncSendTimeout\" value=\"5000\"/>\n</bean>\n```\n\nspring官方文档已经写得很齐全了，更多场景和说明请参阅下文大笑\nhttp://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#websocket\n","slug":"使用spring4.x的websocket支持","published":1,"updated":"2015-06-11T20:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3j0017970qfpl1llda"},{"title":"使用pinyin4j将中文转换为拼音","date":"2012-08-15T16:20:00.000Z","_content":"直接代码\n\n##实现一\n\n```java\nimport net.sourceforge.pinyin4j.PinyinHelper;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinToneType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;\nimport net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;\n\npublic class SpellHelper {\n\n\t/**\n\t * 将中文转换为拼音\n\t * @param name\n\t * @return\n\t */\n\tpublic static String getEname(String name) {\n\t\tHanyuPinyinOutputFormat pyFormat = new HanyuPinyinOutputFormat();\n\t\tpyFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\tpyFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\tpyFormat.setVCharType(HanyuPinyinVCharType.WITH_V);\n\n\t\ttry {\n\t\t\treturn PinyinHelper.toHanyuPinyinString(name, pyFormat, \"\");\n\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 取字符拼音的第一个字母\n\t * @param name\n\t * @return\n\t */\n\tpublic static String getFirstEName(String name) {\n\t\tif(DyString.isEmpty(name))\n\t\t\treturn \"\";\n\t\t\n\t\tString spell = \"\";\n\t\tString _name = name.replaceAll(\"[　― …《》\\\\.,，。;`；\\\\!！\\\\?？‘’＜＞\\\"“”、■#★●【】\\\\{\\\\}\\\\[\\\\]（）+｛｝［］\\\\(\\\\)\\\\|\\\\-:：~～!@#$%^&*\\\\(\\\\)/\\\\,\\\\.￥——]\", \"\").trim();\n\t\t\n\t\tchar[] strs = _name.toCharArray();\n\t\tfor (int i = 0; i < strs.length; i++) {\n\t\t\tString upCaseText = getEname(\"\" + strs[i]);\n\t\t\tspell += upCaseText.substring(0, 1);\n\t\t}\n\t\treturn spell;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getEname(\"长沙阁酒店公寓（瑞苑）\"));\n\t\tSystem.out.println(getFirstEName(\"长沙阁酒店公寓（瑞苑）\"));\n\t}\n\n}\n```\n\n##实现二\n\n```java\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.sourceforge.pinyin4j.PinyinHelper;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinToneType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;\nimport net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;\n\n/**\n * 汉字转换拼音工具类\n * \n * @Author liuxing\n * @Date 2013-03-14\n */\npublic class PinYin4JCn {\n\t\n\tprivate static HanyuPinyinOutputFormat spellFormat = null;\n\tprivate static String reg = \"[　― …《》\\\\.,，。;`；\\\\!！\\\\?？‘’＜＞\\\"“”、■#★●【】\\\\{\\\\}\\\\[\\\\]（）+｛｝［］\\\\(\\\\)\\\\|\\\\-:：~～!@#$%^&*\\\\(\\\\)/\\\\,\\\\.￥——]\";\n\t\n\t/**\n\t * 将中文转换为拼音\n\t * 不区分多音字\n\t * @param name\n\t * @return\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static String converterNoSpaceSpell(String name) {\n\t\tif(spellFormat == null){\n\t\t\tspellFormat = new HanyuPinyinOutputFormat();\n\t\t\tspellFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\t\tspellFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\t\tspellFormat.setVCharType(HanyuPinyinVCharType.WITH_V);\n\t\t}\n\n\t\ttry {\n\t\t\treturn PinyinHelper.toHanyuPinyinString(name, spellFormat, \"\");\n\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 将中文转换为全拼（带空格）\n\t * 不区分多音字\n\t * @param name\n\t * @return\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static String converterSpell(String name) {\n\t\tif(spellFormat == null){\n\t\t\tspellFormat = new HanyuPinyinOutputFormat();\n\t\t\tspellFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\t\tspellFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\t\tspellFormat.setVCharType(HanyuPinyinVCharType.WITH_V);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\treturn PinyinHelper.toHanyuPinyinString(name, spellFormat, \" \");\n\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 取字符拼音的第一个字母\n\t * 不区分多音字\n\t * @param name\n\t * @return\n\t */\n\tpublic static String converterToFirstSpell(String name) {\n\t\tif(Strings.isEmpty(name)){\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\tString spell = \"\";\n\t\tString _name = name.replaceAll(reg, \"\").trim();\n\t\t\n\t\tchar[] strs = _name.toCharArray();\n\t\tString upCaseText = null;\n\t\tfor (int i = 0; i < strs.length; i++) {\n\t\t\tupCaseText = converterNoSpaceSpell(\"\" + strs[i]);\n\t\t\tspell += upCaseText.substring(0, 1);\n\t\t}\n\t\treturn spell;\n\t}\n\t\n\t/**\n\t * 汉字转换位汉语拼音首字母，英文字符不变，\n\t * 特殊字符丢失 支持多音字，生成方式如（重当参:cdc,zds,cds,zdc）\n\t * @param chines\n\t * @return\n\t */\n\tpublic static String converterToFirstSpellWithPolyphone(String chines) {\n\t\tStringBuffer pinyinName = new StringBuffer();\n\t\tchar[] nameChar = chines.toCharArray();\n\t\tHanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();\n\t\tdefaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\tdefaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\tfor (int i = 0; i < nameChar.length; i++) {\n\t\t\tif (nameChar[i] > 128) {\n\t\t\t\ttry {\n\t\t\t\t\t// 取得当前汉字的所有全拼\n\t\t\t\t\tString[] strs = PinyinHelper.toHanyuPinyinStringArray(nameChar[i], defaultFormat);\n\t\t\t\t\tif (strs != null) {\n\t\t\t\t\t\tfor (int j = 0; j < strs.length; j++) {\n\t\t\t\t\t\t\t// 取首字母\n\t\t\t\t\t\t\tpinyinName.append(strs[j].charAt(0));\n\t\t\t\t\t\t\tif (j != strs.length - 1) {\n\t\t\t\t\t\t\t\tpinyinName.append(\",\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tpinyinName.append(nameChar[i]);\n//\t\t\t\t\t}\n\t\t\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpinyinName.append(nameChar[i]);\n\t\t\t}\n\t\t\tpinyinName.append(\" \");\n\t\t}\n\t\treturn parseTheChineseByObject(discountTheChinese(pinyinName.toString()));\n\t}\n\n\t/**\n\t * 汉字转换位汉语全拼，英文字符不变，特殊字符丢失\n\t * 支持多音字，生成方式如（重当参:zhongdangcen,zhongdangcan,chongdangcen,chongdangshen,zhongdangshen,chongdangcan）\n\t * @param chines\n\t * @return\n\t */\n\tpublic static String converterToSpellWithPolyphone(String chines) {\n\t\tStringBuffer pinyinName = new StringBuffer();\n\t\tchar[] nameChar = chines.toCharArray();\n\t\tHanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();\n\t\tdefaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\tdefaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\tfor (int i = 0; i < nameChar.length; i++) {\n\t\t\tif (nameChar[i] > 128) {\n\t\t\t\ttry {\n\t\t\t\t\t// 取得当前汉字的所有全拼\n\t\t\t\t\tString[] strs = PinyinHelper.toHanyuPinyinStringArray(\n\t\t\t\t\t\t\tnameChar[i], defaultFormat);\n\t\t\t\t\tif (strs != null) {\n\t\t\t\t\t\tfor (int j = 0; j < strs.length; j++) {\n\t\t\t\t\t\t\tpinyinName.append(strs[j]);\n\t\t\t\t\t\t\tif (j != strs.length - 1) {\n\t\t\t\t\t\t\t\tpinyinName.append(\",\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpinyinName.append(nameChar[i]);\n\t\t\t}\n\t\t\tpinyinName.append(\" \");\n\t\t}\n\t\treturn parseTheChineseByObject(discountTheChinese(pinyinName.toString()));\n\t}\n\n\t/**\n\t * \n\t * 功能说明：获取所有的优化结果集\n\t * 刘兴  2013-8-7 下午5:19:24\n\t * 修改者名字：\n\t * 修改日期：\n\t * 修改内容：\n\t * @param str\n\t * @return\n\t */\n\tpublic static String converterToAllSpellWithPolyphone(String str){\n\t\tString firstSpell = converterToFirstSpellWithPolyphone(str);\n\t\tString spell = converterToSpellWithPolyphone(str);\n\t\t\n\t\tif(Strings.isNotEmpty(firstSpell)){\n\t\t\tfirstSpell = firstSpell + \",\";\n\t\t}\n\t\treturn firstSpell + spell;\n\t}\n\t\n\t/**\n\t * 去除多音字重复数据\n\t * @param theStr\n\t * @return\n\t */\n\tprivate static List<Map<String, Integer>> discountTheChinese(String theStr) {\n\t\t// 去除重复拼音后的拼音列表\n\t\tList<Map<String, Integer>> mapList = new ArrayList<Map<String, Integer>>();\n\t\t// 用于处理每个字的多音字，去掉重复\n\t\tMap<String, Integer> onlyOne = null;\n\t\tString[] firsts = theStr.split(\" \");\n\t\t// 读出每个汉字的拼音\n\t\tfor (String str : firsts) {\n\t\t\tonlyOne = new Hashtable<String, Integer>();\n\t\t\tString[] china = str.split(\",\");\n\t\t\t// 多音字处理\n\t\t\tfor (String s : china) {\n\t\t\t\tInteger count = onlyOne.get(s);\n\t\t\t\tif (count == null) {\n\t\t\t\t\tonlyOne.put(s, new Integer(1));\n\t\t\t\t} else {\n\t\t\t\t\tonlyOne.remove(s);\n\t\t\t\t\tcount++;\n\t\t\t\t\tonlyOne.put(s, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapList.add(onlyOne);\n\t\t}\n\t\treturn mapList;\n\t}\n\n\t/**\n\t * 解析并组合拼音，对象合并方案\n\t * @param list\n\t * @return\n\t */\n\tprivate static String parseTheChineseByObject(List<Map<String, Integer>> list) {\n\t\tMap<String, Integer> first = null; // 用于统计每一次,集合组合数据\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t// 每一组集合与上一次组合的Map\n\t\t\tMap<String, Integer> temp = new Hashtable<String, Integer>();\n\t\t\t\n\t\t\t// 第一次循环，first为空\n\t\t\tif (first != null) {\n\t\t\t\t// 取出上次组合与此次集合的字符，并保存\n\t\t\t\tfor (String s : first.keySet()) {\n\t\t\t\t\tfor (String s1 : list.get(i).keySet()) {\n\t\t\t\t\t\ttemp.put(s + s1, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 清理上一次组合数据\n\t\t\t\tif (temp != null && temp.size() > 0) {\n\t\t\t\t\tfirst.clear();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (String s : list.get(i).keySet()) {\n\t\t\t\t\ttemp.put(s, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// 保存组合数据以便下次循环使用\n\t\t\tif (temp != null && temp.size() > 0) {\n\t\t\t\tfirst = temp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (first == null) \n\t\t\treturn \"\";\n\t\t\n\t\tString reltStr = \"\";\n\t\t\n\t\tfor (String str : first.keySet()) {\n\t\t\treltStr += (\",\" + str);\n\t\t}\n\t\t\n\t\tif (Strings.isNotEmpty(reltStr)) {\n\t\t\treturn reltStr.replaceFirst(\",\", \"\");\n\t\t}\n\t\t\n\t\treturn reltStr;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString str = \"单田芳\";\n//\t\tSystem.out.println(converterToFirstSpellWithPolyphone(str));\n//\t\tSystem.out.println(converterToSpellWithPolyphone(str));\n//\t\tSystem.out.println(converterSpell(str));\n\t\tSystem.out.println(converterToFirstSpellWithPolyphone(str));\n\t}\n\n}\n```","source":"_posts/使用pinyin4j将中文转换为拼音.md","raw":"title: \"使用pinyin4j将中文转换为拼音\"\ndate: 2012-08-16 00:20\ncategory: [Java]\ntags: [pinyin4j]\n---\n直接代码\n\n##实现一\n\n```java\nimport net.sourceforge.pinyin4j.PinyinHelper;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinToneType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;\nimport net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;\n\npublic class SpellHelper {\n\n\t/**\n\t * 将中文转换为拼音\n\t * @param name\n\t * @return\n\t */\n\tpublic static String getEname(String name) {\n\t\tHanyuPinyinOutputFormat pyFormat = new HanyuPinyinOutputFormat();\n\t\tpyFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\tpyFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\tpyFormat.setVCharType(HanyuPinyinVCharType.WITH_V);\n\n\t\ttry {\n\t\t\treturn PinyinHelper.toHanyuPinyinString(name, pyFormat, \"\");\n\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 取字符拼音的第一个字母\n\t * @param name\n\t * @return\n\t */\n\tpublic static String getFirstEName(String name) {\n\t\tif(DyString.isEmpty(name))\n\t\t\treturn \"\";\n\t\t\n\t\tString spell = \"\";\n\t\tString _name = name.replaceAll(\"[　― …《》\\\\.,，。;`；\\\\!！\\\\?？‘’＜＞\\\"“”、■#★●【】\\\\{\\\\}\\\\[\\\\]（）+｛｝［］\\\\(\\\\)\\\\|\\\\-:：~～!@#$%^&*\\\\(\\\\)/\\\\,\\\\.￥——]\", \"\").trim();\n\t\t\n\t\tchar[] strs = _name.toCharArray();\n\t\tfor (int i = 0; i < strs.length; i++) {\n\t\t\tString upCaseText = getEname(\"\" + strs[i]);\n\t\t\tspell += upCaseText.substring(0, 1);\n\t\t}\n\t\treturn spell;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getEname(\"长沙阁酒店公寓（瑞苑）\"));\n\t\tSystem.out.println(getFirstEName(\"长沙阁酒店公寓（瑞苑）\"));\n\t}\n\n}\n```\n\n##实现二\n\n```java\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.sourceforge.pinyin4j.PinyinHelper;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinToneType;\nimport net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;\nimport net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;\n\n/**\n * 汉字转换拼音工具类\n * \n * @Author liuxing\n * @Date 2013-03-14\n */\npublic class PinYin4JCn {\n\t\n\tprivate static HanyuPinyinOutputFormat spellFormat = null;\n\tprivate static String reg = \"[　― …《》\\\\.,，。;`；\\\\!！\\\\?？‘’＜＞\\\"“”、■#★●【】\\\\{\\\\}\\\\[\\\\]（）+｛｝［］\\\\(\\\\)\\\\|\\\\-:：~～!@#$%^&*\\\\(\\\\)/\\\\,\\\\.￥——]\";\n\t\n\t/**\n\t * 将中文转换为拼音\n\t * 不区分多音字\n\t * @param name\n\t * @return\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static String converterNoSpaceSpell(String name) {\n\t\tif(spellFormat == null){\n\t\t\tspellFormat = new HanyuPinyinOutputFormat();\n\t\t\tspellFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\t\tspellFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\t\tspellFormat.setVCharType(HanyuPinyinVCharType.WITH_V);\n\t\t}\n\n\t\ttry {\n\t\t\treturn PinyinHelper.toHanyuPinyinString(name, spellFormat, \"\");\n\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 将中文转换为全拼（带空格）\n\t * 不区分多音字\n\t * @param name\n\t * @return\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static String converterSpell(String name) {\n\t\tif(spellFormat == null){\n\t\t\tspellFormat = new HanyuPinyinOutputFormat();\n\t\t\tspellFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\t\tspellFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\t\tspellFormat.setVCharType(HanyuPinyinVCharType.WITH_V);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\treturn PinyinHelper.toHanyuPinyinString(name, spellFormat, \" \");\n\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * 取字符拼音的第一个字母\n\t * 不区分多音字\n\t * @param name\n\t * @return\n\t */\n\tpublic static String converterToFirstSpell(String name) {\n\t\tif(Strings.isEmpty(name)){\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\tString spell = \"\";\n\t\tString _name = name.replaceAll(reg, \"\").trim();\n\t\t\n\t\tchar[] strs = _name.toCharArray();\n\t\tString upCaseText = null;\n\t\tfor (int i = 0; i < strs.length; i++) {\n\t\t\tupCaseText = converterNoSpaceSpell(\"\" + strs[i]);\n\t\t\tspell += upCaseText.substring(0, 1);\n\t\t}\n\t\treturn spell;\n\t}\n\t\n\t/**\n\t * 汉字转换位汉语拼音首字母，英文字符不变，\n\t * 特殊字符丢失 支持多音字，生成方式如（重当参:cdc,zds,cds,zdc）\n\t * @param chines\n\t * @return\n\t */\n\tpublic static String converterToFirstSpellWithPolyphone(String chines) {\n\t\tStringBuffer pinyinName = new StringBuffer();\n\t\tchar[] nameChar = chines.toCharArray();\n\t\tHanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();\n\t\tdefaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\tdefaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\tfor (int i = 0; i < nameChar.length; i++) {\n\t\t\tif (nameChar[i] > 128) {\n\t\t\t\ttry {\n\t\t\t\t\t// 取得当前汉字的所有全拼\n\t\t\t\t\tString[] strs = PinyinHelper.toHanyuPinyinStringArray(nameChar[i], defaultFormat);\n\t\t\t\t\tif (strs != null) {\n\t\t\t\t\t\tfor (int j = 0; j < strs.length; j++) {\n\t\t\t\t\t\t\t// 取首字母\n\t\t\t\t\t\t\tpinyinName.append(strs[j].charAt(0));\n\t\t\t\t\t\t\tif (j != strs.length - 1) {\n\t\t\t\t\t\t\t\tpinyinName.append(\",\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tpinyinName.append(nameChar[i]);\n//\t\t\t\t\t}\n\t\t\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpinyinName.append(nameChar[i]);\n\t\t\t}\n\t\t\tpinyinName.append(\" \");\n\t\t}\n\t\treturn parseTheChineseByObject(discountTheChinese(pinyinName.toString()));\n\t}\n\n\t/**\n\t * 汉字转换位汉语全拼，英文字符不变，特殊字符丢失\n\t * 支持多音字，生成方式如（重当参:zhongdangcen,zhongdangcan,chongdangcen,chongdangshen,zhongdangshen,chongdangcan）\n\t * @param chines\n\t * @return\n\t */\n\tpublic static String converterToSpellWithPolyphone(String chines) {\n\t\tStringBuffer pinyinName = new StringBuffer();\n\t\tchar[] nameChar = chines.toCharArray();\n\t\tHanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();\n\t\tdefaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);\n\t\tdefaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);\n\t\tfor (int i = 0; i < nameChar.length; i++) {\n\t\t\tif (nameChar[i] > 128) {\n\t\t\t\ttry {\n\t\t\t\t\t// 取得当前汉字的所有全拼\n\t\t\t\t\tString[] strs = PinyinHelper.toHanyuPinyinStringArray(\n\t\t\t\t\t\t\tnameChar[i], defaultFormat);\n\t\t\t\t\tif (strs != null) {\n\t\t\t\t\t\tfor (int j = 0; j < strs.length; j++) {\n\t\t\t\t\t\t\tpinyinName.append(strs[j]);\n\t\t\t\t\t\t\tif (j != strs.length - 1) {\n\t\t\t\t\t\t\t\tpinyinName.append(\",\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (BadHanyuPinyinOutputFormatCombination e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpinyinName.append(nameChar[i]);\n\t\t\t}\n\t\t\tpinyinName.append(\" \");\n\t\t}\n\t\treturn parseTheChineseByObject(discountTheChinese(pinyinName.toString()));\n\t}\n\n\t/**\n\t * \n\t * 功能说明：获取所有的优化结果集\n\t * 刘兴  2013-8-7 下午5:19:24\n\t * 修改者名字：\n\t * 修改日期：\n\t * 修改内容：\n\t * @param str\n\t * @return\n\t */\n\tpublic static String converterToAllSpellWithPolyphone(String str){\n\t\tString firstSpell = converterToFirstSpellWithPolyphone(str);\n\t\tString spell = converterToSpellWithPolyphone(str);\n\t\t\n\t\tif(Strings.isNotEmpty(firstSpell)){\n\t\t\tfirstSpell = firstSpell + \",\";\n\t\t}\n\t\treturn firstSpell + spell;\n\t}\n\t\n\t/**\n\t * 去除多音字重复数据\n\t * @param theStr\n\t * @return\n\t */\n\tprivate static List<Map<String, Integer>> discountTheChinese(String theStr) {\n\t\t// 去除重复拼音后的拼音列表\n\t\tList<Map<String, Integer>> mapList = new ArrayList<Map<String, Integer>>();\n\t\t// 用于处理每个字的多音字，去掉重复\n\t\tMap<String, Integer> onlyOne = null;\n\t\tString[] firsts = theStr.split(\" \");\n\t\t// 读出每个汉字的拼音\n\t\tfor (String str : firsts) {\n\t\t\tonlyOne = new Hashtable<String, Integer>();\n\t\t\tString[] china = str.split(\",\");\n\t\t\t// 多音字处理\n\t\t\tfor (String s : china) {\n\t\t\t\tInteger count = onlyOne.get(s);\n\t\t\t\tif (count == null) {\n\t\t\t\t\tonlyOne.put(s, new Integer(1));\n\t\t\t\t} else {\n\t\t\t\t\tonlyOne.remove(s);\n\t\t\t\t\tcount++;\n\t\t\t\t\tonlyOne.put(s, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapList.add(onlyOne);\n\t\t}\n\t\treturn mapList;\n\t}\n\n\t/**\n\t * 解析并组合拼音，对象合并方案\n\t * @param list\n\t * @return\n\t */\n\tprivate static String parseTheChineseByObject(List<Map<String, Integer>> list) {\n\t\tMap<String, Integer> first = null; // 用于统计每一次,集合组合数据\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t// 每一组集合与上一次组合的Map\n\t\t\tMap<String, Integer> temp = new Hashtable<String, Integer>();\n\t\t\t\n\t\t\t// 第一次循环，first为空\n\t\t\tif (first != null) {\n\t\t\t\t// 取出上次组合与此次集合的字符，并保存\n\t\t\t\tfor (String s : first.keySet()) {\n\t\t\t\t\tfor (String s1 : list.get(i).keySet()) {\n\t\t\t\t\t\ttemp.put(s + s1, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 清理上一次组合数据\n\t\t\t\tif (temp != null && temp.size() > 0) {\n\t\t\t\t\tfirst.clear();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (String s : list.get(i).keySet()) {\n\t\t\t\t\ttemp.put(s, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// 保存组合数据以便下次循环使用\n\t\t\tif (temp != null && temp.size() > 0) {\n\t\t\t\tfirst = temp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (first == null) \n\t\t\treturn \"\";\n\t\t\n\t\tString reltStr = \"\";\n\t\t\n\t\tfor (String str : first.keySet()) {\n\t\t\treltStr += (\",\" + str);\n\t\t}\n\t\t\n\t\tif (Strings.isNotEmpty(reltStr)) {\n\t\t\treturn reltStr.replaceFirst(\",\", \"\");\n\t\t}\n\t\t\n\t\treturn reltStr;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString str = \"单田芳\";\n//\t\tSystem.out.println(converterToFirstSpellWithPolyphone(str));\n//\t\tSystem.out.println(converterToSpellWithPolyphone(str));\n//\t\tSystem.out.println(converterSpell(str));\n\t\tSystem.out.println(converterToFirstSpellWithPolyphone(str));\n\t}\n\n}\n```","slug":"使用pinyin4j将中文转换为拼音","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3n001d970qrja3gt48"},{"title":"使用jmagick将CMYK转换为RGB","date":"2013-05-22T16:27:00.000Z","_content":"\n最近发现公司图片库中有些打水印的图片水印色彩和其他的不一样，后来发现是设计师上传的图片的色彩值是CMYK的，想要统一成RGB格式的。\n之前使用的是jmagick进行的图片压缩和水印，看了一下jmagick的官方介绍，是有提供转换图片色彩格式的方法。记录一下，给碰到类似问题的同学提供参考。\n \njmagick的ColorspaceType里面是色彩格式对应的常量。\n\n```java\npublic static final int GRAYColorspace = 2;\npublic static final int TransparentColorspace = 3;\npublic static final int OHTAColorspace = 4;\npublic static final int XYZColorspace = 5;\npublic static final int YCbCrColorspace = 6;\npublic static final int YCCColorspace = 7;\npublic static final int YIQColorspace = 8;\npublic static final int YPbPrColorspace = 9;\npublic static final int YUVColorspace = 10;\npublic static final int CMYKColorspace = 11;\npublic static final int sRGBColorspace = 12;\n```\n\n将图片创建成MagickImage对象\n \nImageInfo imageInfo = new ImageInfo(filePath);\nMagickImage fromImage = new MagickImage(imageInfo);\n \n然后通过fromImage.getColorspace()可以拿到色彩格式\n \n完整代码\n```java\n/**\n\t * jmagick 将所有图片色彩统一为RGB\n\t * @param filePath 原图路径\n\t * @param toFilePath 转换后的图片路径\n\t * @return\n\t * @throws Exception\n\t */\n    public static InputStream convert2RGB(String filePath, String toFilePath) throws Exception{\n        InputStream stream = null;\n        ImageInfo imageInfo = new ImageInfo(filePath);\n        MagickImage fromImage = new MagickImage(imageInfo);\n        if(fromImage.getColorspace() != ColorspaceType.RGBColorspace){\n            //因为是将所有其他格式转换为RGB格式，需要将当前文件的色彩格式传入\n            fromImage.transformRgbImage(fromImage.getColorspace());\n            fromImage.setFileName(toFilePath);\n            fromImage.writeImage(imageInfo);\n            stream = new FileInputStream(toFilePath);\n            return stream;\n        }\n        return new FileInputStream(new File(filePath));\n    }\n```","source":"_posts/使用jmagick将CMYK转换为RGB.md","raw":"title: \"使用jmagick将CMYK转换为RGB\"\ndate: 2013-05-23 00:27\ncategory: [Java]\ntags: [jmagick]\n---\n\n最近发现公司图片库中有些打水印的图片水印色彩和其他的不一样，后来发现是设计师上传的图片的色彩值是CMYK的，想要统一成RGB格式的。\n之前使用的是jmagick进行的图片压缩和水印，看了一下jmagick的官方介绍，是有提供转换图片色彩格式的方法。记录一下，给碰到类似问题的同学提供参考。\n \njmagick的ColorspaceType里面是色彩格式对应的常量。\n\n```java\npublic static final int GRAYColorspace = 2;\npublic static final int TransparentColorspace = 3;\npublic static final int OHTAColorspace = 4;\npublic static final int XYZColorspace = 5;\npublic static final int YCbCrColorspace = 6;\npublic static final int YCCColorspace = 7;\npublic static final int YIQColorspace = 8;\npublic static final int YPbPrColorspace = 9;\npublic static final int YUVColorspace = 10;\npublic static final int CMYKColorspace = 11;\npublic static final int sRGBColorspace = 12;\n```\n\n将图片创建成MagickImage对象\n \nImageInfo imageInfo = new ImageInfo(filePath);\nMagickImage fromImage = new MagickImage(imageInfo);\n \n然后通过fromImage.getColorspace()可以拿到色彩格式\n \n完整代码\n```java\n/**\n\t * jmagick 将所有图片色彩统一为RGB\n\t * @param filePath 原图路径\n\t * @param toFilePath 转换后的图片路径\n\t * @return\n\t * @throws Exception\n\t */\n    public static InputStream convert2RGB(String filePath, String toFilePath) throws Exception{\n        InputStream stream = null;\n        ImageInfo imageInfo = new ImageInfo(filePath);\n        MagickImage fromImage = new MagickImage(imageInfo);\n        if(fromImage.getColorspace() != ColorspaceType.RGBColorspace){\n            //因为是将所有其他格式转换为RGB格式，需要将当前文件的色彩格式传入\n            fromImage.transformRgbImage(fromImage.getColorspace());\n            fromImage.setFileName(toFilePath);\n            fromImage.writeImage(imageInfo);\n            stream = new FileInputStream(toFilePath);\n            return stream;\n        }\n        return new FileInputStream(new File(filePath));\n    }\n```","slug":"使用jmagick将CMYK转换为RGB","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3p001h970qzp6tk0rk"},{"title":"优秀的开发者 vs. 差的开发者","date":"2012-07-03T16:00:00.000Z","_content":"\n优秀的开发者是一个艺术家，一个享受创作过程的工匠；\n差的开发者只将自己当作负责产生代码的码农。\n\n优秀的开发者了解客户的问题；\n差的开发者只了解手头的技术问题。\n\n优秀的开发者会不断努力去理解“为什么”，然后去实现，同时能够把握大局；\n差的开发者专注于构建类、方法和配置文件，而不理会大局。\n\n优秀的开发者了解产品的完整架构；\n差的开发者只知道他写的组件。\n\n优秀的开发人员充分理解在产品中使用的技术，了解它们的用途，以及它们在内部如何工作。\n\n优秀的开发者不害怕新技术，并能够很快掌握；\n差的开发者只坚持他目前掌握的技术，对于任何技术变化持否定态度。\n\n优秀的开发者通过不断学习来提高自己的技能，他们经常阅读技术文章和书籍；\n差的开发者没有时间来学习，他们总是太忙了，以致于不能干其他事情。\n\n优秀的开发者关心产品的质量，同时也非常关注过程质量，他们努力创造无缺陷的代码；\n差的开发者将bug留给QA去发现，然后再修复。\n\n优秀的开发者为客户开发能够创造价值的功能；\n差的开发者只是想完成任务。\n\n优秀的开发者不会声称需求描述是不完整的，并确保充分理解这些特性；\n差的开发者会等到需求细节完善后才开始工作。\n\n优秀的开发者总是确保拥有产品功能的相关信息，一旦信息丢失，他会想办法再得到它。\n\n优秀的开发者不害怕在产品中加入其他人的代码，而差的开发者会担心别人使用他的代码。\n\n优秀的开发者永远不会觉得自己的代码已经足够好，相反会持续不断地整理和修复。他们始终致力于创造优雅的解决方案，认为他的工作是向客户提供价值；\n差的开发者只考虑自己代码是否优雅，将创造价值的工作留给别人。","source":"_posts/优秀的开发者 vs. 差的开发者.md","raw":"title: \"优秀的开发者 vs. 差的开发者\"\ndate: 2012-07-04 00:00:00\ncategory: [心态]\ntags: \n---\n\n优秀的开发者是一个艺术家，一个享受创作过程的工匠；\n差的开发者只将自己当作负责产生代码的码农。\n\n优秀的开发者了解客户的问题；\n差的开发者只了解手头的技术问题。\n\n优秀的开发者会不断努力去理解“为什么”，然后去实现，同时能够把握大局；\n差的开发者专注于构建类、方法和配置文件，而不理会大局。\n\n优秀的开发者了解产品的完整架构；\n差的开发者只知道他写的组件。\n\n优秀的开发人员充分理解在产品中使用的技术，了解它们的用途，以及它们在内部如何工作。\n\n优秀的开发者不害怕新技术，并能够很快掌握；\n差的开发者只坚持他目前掌握的技术，对于任何技术变化持否定态度。\n\n优秀的开发者通过不断学习来提高自己的技能，他们经常阅读技术文章和书籍；\n差的开发者没有时间来学习，他们总是太忙了，以致于不能干其他事情。\n\n优秀的开发者关心产品的质量，同时也非常关注过程质量，他们努力创造无缺陷的代码；\n差的开发者将bug留给QA去发现，然后再修复。\n\n优秀的开发者为客户开发能够创造价值的功能；\n差的开发者只是想完成任务。\n\n优秀的开发者不会声称需求描述是不完整的，并确保充分理解这些特性；\n差的开发者会等到需求细节完善后才开始工作。\n\n优秀的开发者总是确保拥有产品功能的相关信息，一旦信息丢失，他会想办法再得到它。\n\n优秀的开发者不害怕在产品中加入其他人的代码，而差的开发者会担心别人使用他的代码。\n\n优秀的开发者永远不会觉得自己的代码已经足够好，相反会持续不断地整理和修复。他们始终致力于创造优雅的解决方案，认为他的工作是向客户提供价值；\n差的开发者只考虑自己代码是否优雅，将创造价值的工作留给别人。","slug":"优秀的开发者 vs. 差的开发者","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3t001k970qxv11n1ea"},{"title":"一个简单的百度地图示例","date":"2012-09-07T16:25:00.000Z","_content":"\n##介绍\n百度地图API是一套由JavaScript语言编写的应用程序接口，它能够帮助您在网站中构建功能丰富、交互性强的地图应用。百度地图API包含了构建地图基本功能的各种接口，提供了诸如本地搜索、路线规划等数据服务。\n \n百度地图相对谷歌地图来说，提供的数据比较全面，比如交通路线。功能也比较多，基本上现在各大网站都是使用的百度地图，同时文档和API也做得不错。\n \n个人建议使用百度地图API开发时，详细阅读官方提供的类参考和官方示例。最好是对API中各个类的基本功能有个大致的了解。如果看到某些网站的地图很炫，也可以借助firebug或其他工具查看源码参考其实现。官网成功案例展示的那些网站的地图功能都可以参考。如果想要更高级绚丽的功能，官网的地图开源库也可以了解一下。\n \n贴出来的code是js的代码，可以运行的实例请下载文章的附件。有部分功能使用了jquery，不了解的童鞋请了解下jquery的使用语法。\n \n此demo主要实现了以下几个功能\n- 创建一个简单地图实例，配置了常用的地图上的控件，比如缩略地图、比例尺控件、缩放控件等。\n- 使用ajax查询后台数据，并将其标注到地图中（大众化需求）。\n- 拖拽地图后保存修改后的坐标（大众化需求）。\n- 通过地图外的html操作地图内的功能（demo中只提供了点击某个链接，在地图中对应标注上打开信息窗口，需要其他工的请参考类文档后自由发挥）。\n- 其他一些细微的功能，基本地图中要用到的。\n \ncode中使用js实现的hash完成了部分功能，不理解该原理的童鞋也请自己去补习相关知识，或者使用数组形式，官方示例中可以找到相关实现好的code。\n \n自己的js是已经使用闭包的形式了，这里还是普通形式，建议使用闭包方式，好处的话大家都懂得。最后还是那句话，请多看类参考文档和官方示例。\n\n##示例\n```js\n<!-- 开始加载地图的处理 -->\n<script type=\"text/javascript\">\n// 存储信息窗的hash表\nvar infoWindowMap = new Hash(); \n// 存储标注的hash表\nvar markerMap = new Hash();\t  \n\nvar buildingJsonStr = '[{\"buildingId\": \"0710101842282A67E3162603F6250D67\", \"name\": \"02\", \"x\": \"31.22127\", \"y\": \"121.398516\"}, {\"buildingId\": \"07101018422820AD64EAB3AC576FFD3E\", \"name\": \"03\", \"x\": \"31.221587\", \"y\": \"121.397745\"}, {\"buildingId\": \"07101018422845B31172C77A176BDB43\", \"name\": \"04\", \"x\": \"31.220695\", \"y\": \"121.39827\"}, {\"buildingId\": \"071010184228A7EF4B0094030694C1B5\", \"name\": \"05\", \"x\": \"31.220769\", \"y\": \"121.397956\"}, {\"buildingId\": \"071010184228057205C5220A4924B99F\", \"name\": \"06\", \"x\": \"31.220178\", \"y\": \"121.398149\"}, {\"buildingId\": \"07101018422891C6FB5F3838EA67AEB6\", \"name\": \"07\", \"x\": \"31.220236\", \"y\": \"121.397776\"}, {\"buildingId\": \"071010184228E99A96B62460853A93B0\", \"name\": \"08\", \"x\": \"31.220576\", \"y\": \"121.397269\"}, {\"buildingId\": \"071010184228F4A035D852D89F418667\", \"name\": \"09\", \"x\": \"31.220638\", \"y\": \"121.396932\"}, {\"buildingId\": \"071010184228869C8C3AA796DB2D6A17\", \"name\": \"10\", \"x\": \"31.22051\", \"y\": \"121.39633\"}, {\"buildingId\": \"0710101842288CD20D0E333F3D775AEE\", \"name\": \"11\", \"x\": \"31.220634\", \"y\": \"121.395917\"}, {\"buildingId\": \"071010184228465B808DF2361EF74872\", \"name\": \"12\", \"x\": \"31.221186\", \"y\": \"121.396132\"}, {\"buildingId\": \"07101018422876B9BD4DD764214A37EF\", \"name\": \"13\", \"x\": \"31.221151\", \"y\": \"121.396478\"}, {\"buildingId\": \"07101018422860A7AEE993AD2F3D254E\", \"name\": \"14\", \"x\": \"31.221923\", \"y\": \"121.396478\"}, {\"buildingId\": \"071010184228D993F7D6F104C6241EA0\", \"name\": \"15\", \"x\": \"31.221529\", \"y\": \"121.397035\"}, {\"buildingId\": \"071010184228C77408F277C2A0FFF9EA\", \"name\": \"16\", \"x\": \"31.222487\", \"y\": \"121.39682\"}, {\"buildingId\": \"07101018422850C5CEFCC37B745AE217\", \"name\": \"17\", \"x\": \"31.222155\", \"y\": \"121.397278\"}, {\"buildingId\": \"071010184228CE5998B16072B7EADAF0\", \"name\": \"18\", \"x\": \"31.222992\", \"y\": \"121.396829\"}, {\"buildingId\": \"071010184228C4AE0885ED1B1934CAC7\", \"name\": \"19\", \"x\": \"31.223008\", \"y\": \"121.397215\"}, {\"buildingId\": \"071010184228A28019A162C9F30FB412\", \"name\": \"20\", \"x\": \"31.223054\", \"y\": \"121.397745\"}, {\"buildingId\": \"071010184228BE86B8C490400D07A7D9\", \"name\": \"21\", \"x\": \"31.223039\", \"y\": \"121.398109\"}, {\"buildingId\": \"0710101842284F721F26E60E4AE38B78\", \"name\": \"22\", \"x\": \"31.223062\", \"y\": \"121.398702\"}, {\"buildingId\": \"07101018422835C890FA62A7AC3D7B4F\", \"name\": \"23\", \"x\": \"31.223077\", \"y\": \"121.399106\"}, {\"buildingId\": \"0710101842293A343A9B0EE1A2F87ED6\", \"name\": \"24\", \"x\": \"31.222533\", \"y\": \"121.398567\"}, {\"buildingId\": \"0710101842298447B5294F823BF14B2E\", \"name\": \"25\", \"x\": \"31.222128\", \"y\": \"121.398109\"}, {\"buildingId\": \"07101018422905330D8B854F88DD30DD\", \"name\": \"26\", \"x\": \"31.221888\", \"y\": \"121.398769\"}]';\n\nvar estateJsonStr = '[{\"estateId\": \"0705280229021824977FE8318D179397\", \"name\": \"天山河畔花园\", \"address\": \"水城路883弄/长宁路\", \"x\": \"31.221034\", \"y\": \"121.397223\"}]'\n\n/**\n * 获取相关的json数组\n * @returns\n */\nfunction getJsonData() {\n    var reltJson;\n    var url = \"Your url\"; \n\n\t// 此处注释请求后台程序获取json数组的方法，直接返回定义好的json数组\n//    $.ajax({\n//        type: 'GET',\n//        url: url,\n//        async: false,\n//        dataType: 'json',\n//        timeout: 50000,\n//        cache: false,\n//        error: function(XMLHttpRequest, status, thrownError) {\n//            alert('Error loading ' + url +', Please send it again!');\n//        },\n//        success: function(json) {\n//            reltJson = json;\n//        }\n//    });\n\t\n\t// 转换json数组字符串成json对象，正式使用时上述ajax方法直接拿到的是json对象，不需要这步操作\n\treltJson = eval(buildingJsonStr);\n\n    return reltJson;\n}\n\n// 全局变量\nvar map;\t\t\t// 地图对象\t\t\nvar estateJson;\t\t// 中心点json数据\nvar mouseoutIcon;   // 鼠标移出标注时的图像对象\nvar mouseoverIcon;  // 鼠标放在标注时的图像对象\n\n// 绘制地图\ndrawMap();\n\n/**\n * 绘制地图\n */\nfunction drawMap(){\n\testateJson = eval(estateJsonStr)[0];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 初始化中心点的json数据\n\tmap = new BMap.Map(\"container\",{mapType: BMAP_HYBRID_MAP, enableHighResolution: true});\t\t\t// 设置卫星图为底图\n\tinitIcon();\n\tconfiguration();\n\tbuildContextMenu();\n\tinitCenterMarker();\n\tinitOtherMarkers();\n}\n\n/**\n * 地图基本功能设置\n * @param map\n */\nfunction configuration(){\n\t// 初始化中心坐标\n\tvar point = getPoint(estateJson.y, estateJson.x);\t\t\t\t\n\t// 启用键盘操作\n\tmap.enableKeyboard();\t\t\t\t\t\t\t\t\n\t// 启用滚轮放大缩小\n\tmap.enableScrollWheelZoom();\t\t\n\t// 初始化地图,设置中心点坐标和地图级别\n\tmap.centerAndZoom(point, 18);                    \t\t\t\n\t// 添加比例尺控件\n\tmap.addControl(new BMap.ScaleControl());\t\t\n\t// 添加平移缩放控件\n\tmap.addControl(new BMap.NavigationControl());\t\t\t\t\t\t\t\t\t\t\t\n\t// 启用地图惯性拖拽\n\tmap.enableInertialDragging();\t\t\t\t\t\t\t\t\t\t\n\t// 展示普通街道、卫星和路网的混合视图\n\tmap.addControl(new BMap.MapTypeControl({mapTypes: [BMAP_NORMAL_MAP, BMAP_HYBRID_MAP]}));\t\n\t// 创建缩略地图控件\n\tvar control = new BMap.OverviewMapControl();\t\t\t\t\t\t\t\t\t\t\n\t// 展开缩略地图控件，默认不展开\n\tcontrol.changeView();\t\t\n\t// 添加缩略地图控件\n\tmap.addControl(control);  \n\t// 设置地图显示的城市 此项是必须设置的\n\tmap.setCurrentCity(\"上海\");          \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n/**\n * 创建右键菜单\n */\nfunction buildContextMenu(){\n\tvar contextMenu  = new BMap.ContextMenu();\n\tvar txtMenuItem = [\n\t  {\n\t   text:'放大',\n\t   callback:function(){map.zoomIn();}\n\t  },\n\t  {\n\t   text:'缩小',\n\t   callback:function(){map.zoomOut();}\n\t  },\n\t  {\n\t   text:'放置到最大级',\n\t   callback:function(){map.setZoom(20);}\n\t  }\n\t ];\n\n\tfor(var i=0; i < txtMenuItem.length; i++){\n\t\tcontextMenu.addItem(new BMap.MenuItem(txtMenuItem[i].text,txtMenuItem[i].callback,100));\n\t\tif(i==1 || i==3) {\n\t\t\tcontextMenu.addSeparator();\n\t\t}\n\t}\n\tmap.addContextMenu(contextMenu);\n}\n\n/**\n * 初始化标注图像\n */\nfunction initIcon(){\n\tmouseoutIcon = new BMap.Icon(\"images/marker-icon.gif\", new BMap.Size(12, 21), {imageOffset:new BMap.Size(-46,0)});\n\tmouseoverIcon = new BMap.Icon(\"images/marker-icon.gif\", new BMap.Size(12, 21), {imageOffset:new BMap.Size(-69,0)});\n}\n\n/**\n * 初始化中心点标注\n */\nfunction initCenterMarker(){\n\taddMarker(getPoint(estateJson.y, estateJson.x), estateJson.name, estateJson.estateId)\n}\n\n/**\n * 初始化其他标注\n */\nfunction initOtherMarkers(){\n\t// 获取其他json数据\n\tvar markersJson = getJsonData();\n\t$.each(markersJson, function(){\n\t\taddMarker(getPoint(this.y, this.x), this.name, this.buildingId);\n\t});\n}\n\n\n/**\n * 获取栋座坐标point对象\n * 无坐标时，随机生成在小区坐标附近\n * @param y\n * @param x\n */\nfunction getPoint(y, x){\n\t// 因为json字符串中定义的是字符串，需要转换成float\n\tvar _y = parseFloat(y);\n\tvar _x = parseFloat(x);\n\t\n\t// 如果是有效的坐标，则直接创建point\n\tif(_y > 0 || _x > 0)\n\t\treturn new BMap.Point(_y, _x);\n\t\n\t// 如果不是有效坐标，则创建中心点附近的随机坐标值\n\tvar bounds = map.getBounds();\n\tvar sw = bounds.getSouthWest();\n\tvar ne = bounds.getNorthEast();\n\tvar lngSpan = Math.abs(sw.lng - ne.lng);\n\tvar latSpan = Math.abs(ne.lat - sw.lat);\n\treturn new BMap.Point(sw.lng + lngSpan * (Math.random() * 0.8), ne.lat - latSpan * (Math.random() * 0.8));\n}\n\n/**\n * 添加多个标注\n * @param point 坐标\n * @param text 标注文本\n * @param buildingId 编号\n */\nfunction addMarker(point, text, id){\n\t// 创建标注\n\tvar marker = new BMap.Marker(point, {icon:mouseoutIcon});\n\tmarker.setLabel(new BMap.Label(text, {offset:new BMap.Size(9,-20)}));\n\tmarker.setTitle(text);\n\tmarker.enableDragging();\n\t\n\t// 标注拖拽结束后绑定的事件\n\tmarker.addEventListener(\"dragend\", function(e){\n\t\teditCoord(id, e.point.lat, e.point.lng, text);\n\t});\n\t\n\t// 鼠标离开标注时绑定的事件\n\tmarker.addEventListener(\"mouseout\", function(e){\n\t\tmarker.setIcon(mouseoutIcon);\n\t});\n\n\t// 鼠标移到标注时绑定的事件\n\tmarker.addEventListener(\"mouseover\", function(e){\n\t\tmarker.setIcon(mouseoverIcon);\n\t});\n\n\t// 鼠标点击标注时绑定的事件\n\tmarker.addEventListener(\"click\", function(e){ \n\t\tmarker.openInfoWindow(infoWindow);\n\t});\n\t\n\t// 信息窗关闭时绑定的事件\n\tmarker.addEventListener(\"infowindowclose\", function(e){ \n\t\tmarker.setIcon(mouseoutIcon);\n\t});\n\n\t// 信息窗打开时绑定的事件\n\tmarker.addEventListener(\"infowindowopen\", function(e){ \n\t\tmarker.setIcon(mouseoverIcon);\n\t});\n\t \n\t// 显示到地图中\n\tmap.addOverlay(marker);\n\n\t//创建信息窗\n\tvar infoWindow = new BMap.InfoWindow(getContent(text));\t\n\n\t// 存储到hash\n\tinfoWindowMap.put(id, infoWindow);\n\tmarkerMap.put(id, marker);\n\n\tvar link = '<li><a href=\"javascript:void(0);\" onclick=\"showInfoWindos(\\''+id+'\\')\">'+ text +'</a></li>';\n\t$('#a_view').append(link);\n}\n\n/**\n * 展示标注的信息窗\n * @param id\n */\nfunction showInfoWindos(id){\n\tvar marker = markerMap.get(id);\n\tif(infoWindowMap.get(id) != undefined){\n\t\tmarker.openInfoWindow(infoWindowMap.get(id));\n\t}\n}\n\n\n\n/**\n * 保存坐标编辑\n * @param id\n * @param x\n * @param y\n * @param name\n */\nfunction editCoord(id, x, y, name){\n//    $.ajax({\n//        type: 'POST',\n//        url: 'Your url',\n//        data: {\t\n//\t\t\t\t'id' : id, \n//\t\t\t\t'x' : x, \n//\t\t\t\t'y' : y\n//\t\t},\n//        success: function(data) {\n//            showMsg(\"<strong>\" + name + \"修改后的坐标已自动保存</strong>\");\n//        }\n//    });\n\n\tshowMsg('<strong>\"' + name + '\"修改后的坐标已自动保存</strong>');\n}\n\n/**\n * 获取信息窗html\n */\nfunction getContent(name){\n\tvar content = \"<div><p>{name}</p></div>\";\n\treturn content.replace(\"{name}\", name);\n}\n\n/**\n * 展示坐标修改后的提醒内容\n */\nfunction showMsg(msg){\n\t$('#msg_view').html(msg);\n}\n\n\n</script>\n```\n\n酸奶小妹的博客也提供了不少的实例：http://www.cnblogs.com/milkmap/tag/%E5%9C%B0%E5%9B%BEAPI/default.html?page=1","source":"_posts/一个简单的百度地图示例.md","raw":"title: \"一个简单的百度地图示例\"\ndate: 2012-09-08 00:25\ncategory: [前端]\ntags: [地图]\n---\n\n##介绍\n百度地图API是一套由JavaScript语言编写的应用程序接口，它能够帮助您在网站中构建功能丰富、交互性强的地图应用。百度地图API包含了构建地图基本功能的各种接口，提供了诸如本地搜索、路线规划等数据服务。\n \n百度地图相对谷歌地图来说，提供的数据比较全面，比如交通路线。功能也比较多，基本上现在各大网站都是使用的百度地图，同时文档和API也做得不错。\n \n个人建议使用百度地图API开发时，详细阅读官方提供的类参考和官方示例。最好是对API中各个类的基本功能有个大致的了解。如果看到某些网站的地图很炫，也可以借助firebug或其他工具查看源码参考其实现。官网成功案例展示的那些网站的地图功能都可以参考。如果想要更高级绚丽的功能，官网的地图开源库也可以了解一下。\n \n贴出来的code是js的代码，可以运行的实例请下载文章的附件。有部分功能使用了jquery，不了解的童鞋请了解下jquery的使用语法。\n \n此demo主要实现了以下几个功能\n- 创建一个简单地图实例，配置了常用的地图上的控件，比如缩略地图、比例尺控件、缩放控件等。\n- 使用ajax查询后台数据，并将其标注到地图中（大众化需求）。\n- 拖拽地图后保存修改后的坐标（大众化需求）。\n- 通过地图外的html操作地图内的功能（demo中只提供了点击某个链接，在地图中对应标注上打开信息窗口，需要其他工的请参考类文档后自由发挥）。\n- 其他一些细微的功能，基本地图中要用到的。\n \ncode中使用js实现的hash完成了部分功能，不理解该原理的童鞋也请自己去补习相关知识，或者使用数组形式，官方示例中可以找到相关实现好的code。\n \n自己的js是已经使用闭包的形式了，这里还是普通形式，建议使用闭包方式，好处的话大家都懂得。最后还是那句话，请多看类参考文档和官方示例。\n\n##示例\n```js\n<!-- 开始加载地图的处理 -->\n<script type=\"text/javascript\">\n// 存储信息窗的hash表\nvar infoWindowMap = new Hash(); \n// 存储标注的hash表\nvar markerMap = new Hash();\t  \n\nvar buildingJsonStr = '[{\"buildingId\": \"0710101842282A67E3162603F6250D67\", \"name\": \"02\", \"x\": \"31.22127\", \"y\": \"121.398516\"}, {\"buildingId\": \"07101018422820AD64EAB3AC576FFD3E\", \"name\": \"03\", \"x\": \"31.221587\", \"y\": \"121.397745\"}, {\"buildingId\": \"07101018422845B31172C77A176BDB43\", \"name\": \"04\", \"x\": \"31.220695\", \"y\": \"121.39827\"}, {\"buildingId\": \"071010184228A7EF4B0094030694C1B5\", \"name\": \"05\", \"x\": \"31.220769\", \"y\": \"121.397956\"}, {\"buildingId\": \"071010184228057205C5220A4924B99F\", \"name\": \"06\", \"x\": \"31.220178\", \"y\": \"121.398149\"}, {\"buildingId\": \"07101018422891C6FB5F3838EA67AEB6\", \"name\": \"07\", \"x\": \"31.220236\", \"y\": \"121.397776\"}, {\"buildingId\": \"071010184228E99A96B62460853A93B0\", \"name\": \"08\", \"x\": \"31.220576\", \"y\": \"121.397269\"}, {\"buildingId\": \"071010184228F4A035D852D89F418667\", \"name\": \"09\", \"x\": \"31.220638\", \"y\": \"121.396932\"}, {\"buildingId\": \"071010184228869C8C3AA796DB2D6A17\", \"name\": \"10\", \"x\": \"31.22051\", \"y\": \"121.39633\"}, {\"buildingId\": \"0710101842288CD20D0E333F3D775AEE\", \"name\": \"11\", \"x\": \"31.220634\", \"y\": \"121.395917\"}, {\"buildingId\": \"071010184228465B808DF2361EF74872\", \"name\": \"12\", \"x\": \"31.221186\", \"y\": \"121.396132\"}, {\"buildingId\": \"07101018422876B9BD4DD764214A37EF\", \"name\": \"13\", \"x\": \"31.221151\", \"y\": \"121.396478\"}, {\"buildingId\": \"07101018422860A7AEE993AD2F3D254E\", \"name\": \"14\", \"x\": \"31.221923\", \"y\": \"121.396478\"}, {\"buildingId\": \"071010184228D993F7D6F104C6241EA0\", \"name\": \"15\", \"x\": \"31.221529\", \"y\": \"121.397035\"}, {\"buildingId\": \"071010184228C77408F277C2A0FFF9EA\", \"name\": \"16\", \"x\": \"31.222487\", \"y\": \"121.39682\"}, {\"buildingId\": \"07101018422850C5CEFCC37B745AE217\", \"name\": \"17\", \"x\": \"31.222155\", \"y\": \"121.397278\"}, {\"buildingId\": \"071010184228CE5998B16072B7EADAF0\", \"name\": \"18\", \"x\": \"31.222992\", \"y\": \"121.396829\"}, {\"buildingId\": \"071010184228C4AE0885ED1B1934CAC7\", \"name\": \"19\", \"x\": \"31.223008\", \"y\": \"121.397215\"}, {\"buildingId\": \"071010184228A28019A162C9F30FB412\", \"name\": \"20\", \"x\": \"31.223054\", \"y\": \"121.397745\"}, {\"buildingId\": \"071010184228BE86B8C490400D07A7D9\", \"name\": \"21\", \"x\": \"31.223039\", \"y\": \"121.398109\"}, {\"buildingId\": \"0710101842284F721F26E60E4AE38B78\", \"name\": \"22\", \"x\": \"31.223062\", \"y\": \"121.398702\"}, {\"buildingId\": \"07101018422835C890FA62A7AC3D7B4F\", \"name\": \"23\", \"x\": \"31.223077\", \"y\": \"121.399106\"}, {\"buildingId\": \"0710101842293A343A9B0EE1A2F87ED6\", \"name\": \"24\", \"x\": \"31.222533\", \"y\": \"121.398567\"}, {\"buildingId\": \"0710101842298447B5294F823BF14B2E\", \"name\": \"25\", \"x\": \"31.222128\", \"y\": \"121.398109\"}, {\"buildingId\": \"07101018422905330D8B854F88DD30DD\", \"name\": \"26\", \"x\": \"31.221888\", \"y\": \"121.398769\"}]';\n\nvar estateJsonStr = '[{\"estateId\": \"0705280229021824977FE8318D179397\", \"name\": \"天山河畔花园\", \"address\": \"水城路883弄/长宁路\", \"x\": \"31.221034\", \"y\": \"121.397223\"}]'\n\n/**\n * 获取相关的json数组\n * @returns\n */\nfunction getJsonData() {\n    var reltJson;\n    var url = \"Your url\"; \n\n\t// 此处注释请求后台程序获取json数组的方法，直接返回定义好的json数组\n//    $.ajax({\n//        type: 'GET',\n//        url: url,\n//        async: false,\n//        dataType: 'json',\n//        timeout: 50000,\n//        cache: false,\n//        error: function(XMLHttpRequest, status, thrownError) {\n//            alert('Error loading ' + url +', Please send it again!');\n//        },\n//        success: function(json) {\n//            reltJson = json;\n//        }\n//    });\n\t\n\t// 转换json数组字符串成json对象，正式使用时上述ajax方法直接拿到的是json对象，不需要这步操作\n\treltJson = eval(buildingJsonStr);\n\n    return reltJson;\n}\n\n// 全局变量\nvar map;\t\t\t// 地图对象\t\t\nvar estateJson;\t\t// 中心点json数据\nvar mouseoutIcon;   // 鼠标移出标注时的图像对象\nvar mouseoverIcon;  // 鼠标放在标注时的图像对象\n\n// 绘制地图\ndrawMap();\n\n/**\n * 绘制地图\n */\nfunction drawMap(){\n\testateJson = eval(estateJsonStr)[0];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 初始化中心点的json数据\n\tmap = new BMap.Map(\"container\",{mapType: BMAP_HYBRID_MAP, enableHighResolution: true});\t\t\t// 设置卫星图为底图\n\tinitIcon();\n\tconfiguration();\n\tbuildContextMenu();\n\tinitCenterMarker();\n\tinitOtherMarkers();\n}\n\n/**\n * 地图基本功能设置\n * @param map\n */\nfunction configuration(){\n\t// 初始化中心坐标\n\tvar point = getPoint(estateJson.y, estateJson.x);\t\t\t\t\n\t// 启用键盘操作\n\tmap.enableKeyboard();\t\t\t\t\t\t\t\t\n\t// 启用滚轮放大缩小\n\tmap.enableScrollWheelZoom();\t\t\n\t// 初始化地图,设置中心点坐标和地图级别\n\tmap.centerAndZoom(point, 18);                    \t\t\t\n\t// 添加比例尺控件\n\tmap.addControl(new BMap.ScaleControl());\t\t\n\t// 添加平移缩放控件\n\tmap.addControl(new BMap.NavigationControl());\t\t\t\t\t\t\t\t\t\t\t\n\t// 启用地图惯性拖拽\n\tmap.enableInertialDragging();\t\t\t\t\t\t\t\t\t\t\n\t// 展示普通街道、卫星和路网的混合视图\n\tmap.addControl(new BMap.MapTypeControl({mapTypes: [BMAP_NORMAL_MAP, BMAP_HYBRID_MAP]}));\t\n\t// 创建缩略地图控件\n\tvar control = new BMap.OverviewMapControl();\t\t\t\t\t\t\t\t\t\t\n\t// 展开缩略地图控件，默认不展开\n\tcontrol.changeView();\t\t\n\t// 添加缩略地图控件\n\tmap.addControl(control);  \n\t// 设置地图显示的城市 此项是必须设置的\n\tmap.setCurrentCity(\"上海\");          \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n/**\n * 创建右键菜单\n */\nfunction buildContextMenu(){\n\tvar contextMenu  = new BMap.ContextMenu();\n\tvar txtMenuItem = [\n\t  {\n\t   text:'放大',\n\t   callback:function(){map.zoomIn();}\n\t  },\n\t  {\n\t   text:'缩小',\n\t   callback:function(){map.zoomOut();}\n\t  },\n\t  {\n\t   text:'放置到最大级',\n\t   callback:function(){map.setZoom(20);}\n\t  }\n\t ];\n\n\tfor(var i=0; i < txtMenuItem.length; i++){\n\t\tcontextMenu.addItem(new BMap.MenuItem(txtMenuItem[i].text,txtMenuItem[i].callback,100));\n\t\tif(i==1 || i==3) {\n\t\t\tcontextMenu.addSeparator();\n\t\t}\n\t}\n\tmap.addContextMenu(contextMenu);\n}\n\n/**\n * 初始化标注图像\n */\nfunction initIcon(){\n\tmouseoutIcon = new BMap.Icon(\"images/marker-icon.gif\", new BMap.Size(12, 21), {imageOffset:new BMap.Size(-46,0)});\n\tmouseoverIcon = new BMap.Icon(\"images/marker-icon.gif\", new BMap.Size(12, 21), {imageOffset:new BMap.Size(-69,0)});\n}\n\n/**\n * 初始化中心点标注\n */\nfunction initCenterMarker(){\n\taddMarker(getPoint(estateJson.y, estateJson.x), estateJson.name, estateJson.estateId)\n}\n\n/**\n * 初始化其他标注\n */\nfunction initOtherMarkers(){\n\t// 获取其他json数据\n\tvar markersJson = getJsonData();\n\t$.each(markersJson, function(){\n\t\taddMarker(getPoint(this.y, this.x), this.name, this.buildingId);\n\t});\n}\n\n\n/**\n * 获取栋座坐标point对象\n * 无坐标时，随机生成在小区坐标附近\n * @param y\n * @param x\n */\nfunction getPoint(y, x){\n\t// 因为json字符串中定义的是字符串，需要转换成float\n\tvar _y = parseFloat(y);\n\tvar _x = parseFloat(x);\n\t\n\t// 如果是有效的坐标，则直接创建point\n\tif(_y > 0 || _x > 0)\n\t\treturn new BMap.Point(_y, _x);\n\t\n\t// 如果不是有效坐标，则创建中心点附近的随机坐标值\n\tvar bounds = map.getBounds();\n\tvar sw = bounds.getSouthWest();\n\tvar ne = bounds.getNorthEast();\n\tvar lngSpan = Math.abs(sw.lng - ne.lng);\n\tvar latSpan = Math.abs(ne.lat - sw.lat);\n\treturn new BMap.Point(sw.lng + lngSpan * (Math.random() * 0.8), ne.lat - latSpan * (Math.random() * 0.8));\n}\n\n/**\n * 添加多个标注\n * @param point 坐标\n * @param text 标注文本\n * @param buildingId 编号\n */\nfunction addMarker(point, text, id){\n\t// 创建标注\n\tvar marker = new BMap.Marker(point, {icon:mouseoutIcon});\n\tmarker.setLabel(new BMap.Label(text, {offset:new BMap.Size(9,-20)}));\n\tmarker.setTitle(text);\n\tmarker.enableDragging();\n\t\n\t// 标注拖拽结束后绑定的事件\n\tmarker.addEventListener(\"dragend\", function(e){\n\t\teditCoord(id, e.point.lat, e.point.lng, text);\n\t});\n\t\n\t// 鼠标离开标注时绑定的事件\n\tmarker.addEventListener(\"mouseout\", function(e){\n\t\tmarker.setIcon(mouseoutIcon);\n\t});\n\n\t// 鼠标移到标注时绑定的事件\n\tmarker.addEventListener(\"mouseover\", function(e){\n\t\tmarker.setIcon(mouseoverIcon);\n\t});\n\n\t// 鼠标点击标注时绑定的事件\n\tmarker.addEventListener(\"click\", function(e){ \n\t\tmarker.openInfoWindow(infoWindow);\n\t});\n\t\n\t// 信息窗关闭时绑定的事件\n\tmarker.addEventListener(\"infowindowclose\", function(e){ \n\t\tmarker.setIcon(mouseoutIcon);\n\t});\n\n\t// 信息窗打开时绑定的事件\n\tmarker.addEventListener(\"infowindowopen\", function(e){ \n\t\tmarker.setIcon(mouseoverIcon);\n\t});\n\t \n\t// 显示到地图中\n\tmap.addOverlay(marker);\n\n\t//创建信息窗\n\tvar infoWindow = new BMap.InfoWindow(getContent(text));\t\n\n\t// 存储到hash\n\tinfoWindowMap.put(id, infoWindow);\n\tmarkerMap.put(id, marker);\n\n\tvar link = '<li><a href=\"javascript:void(0);\" onclick=\"showInfoWindos(\\''+id+'\\')\">'+ text +'</a></li>';\n\t$('#a_view').append(link);\n}\n\n/**\n * 展示标注的信息窗\n * @param id\n */\nfunction showInfoWindos(id){\n\tvar marker = markerMap.get(id);\n\tif(infoWindowMap.get(id) != undefined){\n\t\tmarker.openInfoWindow(infoWindowMap.get(id));\n\t}\n}\n\n\n\n/**\n * 保存坐标编辑\n * @param id\n * @param x\n * @param y\n * @param name\n */\nfunction editCoord(id, x, y, name){\n//    $.ajax({\n//        type: 'POST',\n//        url: 'Your url',\n//        data: {\t\n//\t\t\t\t'id' : id, \n//\t\t\t\t'x' : x, \n//\t\t\t\t'y' : y\n//\t\t},\n//        success: function(data) {\n//            showMsg(\"<strong>\" + name + \"修改后的坐标已自动保存</strong>\");\n//        }\n//    });\n\n\tshowMsg('<strong>\"' + name + '\"修改后的坐标已自动保存</strong>');\n}\n\n/**\n * 获取信息窗html\n */\nfunction getContent(name){\n\tvar content = \"<div><p>{name}</p></div>\";\n\treturn content.replace(\"{name}\", name);\n}\n\n/**\n * 展示坐标修改后的提醒内容\n */\nfunction showMsg(msg){\n\t$('#msg_view').html(msg);\n}\n\n\n</script>\n```\n\n酸奶小妹的博客也提供了不少的实例：http://www.cnblogs.com/milkmap/tag/%E5%9C%B0%E5%9B%BEAPI/default.html?page=1","slug":"一个简单的百度地图示例","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3w001m970q2ujrrokg"},{"title":"Java Websocket实例","date":"2015-02-09T15:33:56.000Z","_content":"记录下自己在用的websocket\n\n##介绍\n\n现在很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），\n由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。\n这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，\n然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。\n\n而最比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求。\n\n在 WebSocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\n    \n##运行环境：\n\n###客户端\n实现了websocket的浏览器\n\n|  |  |\n| :-------- | :--------|\n| Chrome | Supported in version 4+ |\n| Firefox | Supported in version 4+ |\n| Internet Explorer | Supported in version 10+ |\n| Opera |Supported in version 10+ |\n| Safari | Supported in version 5+ |\n\n\n###服务端\n\n####依赖\nTomcat 7.0.47以上 + J2EE7\n\n```xml\n<dependency>\n    <groupId>org.apache.tomcat</groupId>  \n    <artifactId>tomcat-websocket-api</artifactId>  \n    <version>7.0.47</version>  \n    <scope>provided</scope>  \n</dependency>  \n\n<dependency>  \n    <groupId>javax</groupId>  \n    <artifactId>javaee-api</artifactId>  \n    <version>7.0</version>  \n    <scope>provided</scope>  \n</dependency>\n\n```\n\n注意：早前业界没有统一的标准，各服务器都有各自的实现，现在J2EE7的JSR356已经定义了统一的标准，请尽量使用支持最新通用标准的服务器。\n\n详见：\nhttp://www.oracle.com/technetwork/articles/java/jsr356-1937161.html\nhttp://jinnianshilongnian.iteye.com/blog/1909962\n \n我是用的Tomcat 7.0.57 + Java7\n必须是Tomcat 7.0.47以上\n详见：http://www.iteye.com/news/28414\n \nps：最早我们是用的Tomcat 7自带的实现，后来要升级Tomcat 8，结果原来的实现方式在Tomcat 8不支持了，就只好切换到支持Websocket 1.0版本的Tomcat了。\n \n主流的java web服务器都有支持JSR365标准的版本了，请自行Google。 \n\n\n用nginx做反向代理的需要注意啦，socket请求需要做特殊配置的，切记！\n\n\nTomcat的处理方式建议修改为NIO的方式，同时修改连接数到合适的参数，请自行Google！\n\n服务端不需要在web.xml中做额外的配置，Tomcat启动后就可以直接连接了。\n\n\n####实现\n```java\nimport com.dooioo.websocket.utils.SessionUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\n\n/**\n * 功能说明：websocket处理类, 使用J2EE7的标准\n *         切忌直接在该连接处理类中加入业务处理代码\n * 作者：liuxing(2014-11-14 04:20)\n */\n//relationId和userCode是我的业务标识参数,websocket.ws是连接的路径，可以自行定义\n@ServerEndpoint(\"/websocket.ws/{relationId}/{userCode}\")\npublic class WebsocketEndPoint {\n\n    private static Log log = LogFactory.getLog(WebsocketEndPoint.class);\n\n    /**\n     * 打开连接时触发\n     * @param relationId\n     * @param userCode\n     * @param session\n     */\n    @OnOpen\n    public void onOpen(@PathParam(\"relationId\") String relationId,\n                       @PathParam(\"userCode\") int userCode,\n                       Session session){\n        log.info(\"Websocket Start Connecting: \" + SessionUtils.getKey(relationId, userCode));\n        SessionUtils.put(relationId, userCode, session);\n    }\n\n    /**\n     * 收到客户端消息时触发\n     * @param relationId\n     * @param userCode\n     * @param message\n     * @return\n     */\n    @OnMessage\n    public String onMessage(@PathParam(\"relationId\") String relationId,\n                            @PathParam(\"userCode\") int userCode,\n                            String message) {\n        return \"Got your message (\" + message + \").Thanks !\";\n    }\n\n    /**\n     * 异常时触发\n     * @param relationId\n     * @param userCode\n     * @param session\n     */\n    @OnError\n    public void onError(@PathParam(\"relationId\") String relationId,\n                        @PathParam(\"userCode\") int userCode,\n                        Throwable throwable,\n                        Session session) {\n        log.info(\"Websocket Connection Exception: \" + SessionUtils.getKey(relationId, userCode));\n        log.info(throwable.getMessage(), throwable);\n        SessionUtils.remove(relationId, userCode);\n    }\n\n    /**\n     * 关闭连接时触发\n     * @param relationId\n     * @param userCode\n     * @param session\n     */\n    @OnClose\n    public void onClose(@PathParam(\"relationId\") String relationId,\n                        @PathParam(\"userCode\") int userCode,\n                        Session session) {\n        log.info(\"Websocket Close Connection: \" + SessionUtils.getKey(relationId, userCode));\n        SessionUtils.remove(relationId, userCode);\n    }\n\n}\n    \n```\n \n工具类用来存储唯一key和连接\n\n这个是我业务的需要，我的业务是服务器有对应动作触发时，推送数据到客户端，没有接收客户端数据的操作。\n\n```java\nimport javax.websocket.Session;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 功能说明：用来存储业务定义的sessionId和连接的对应关系\n *          利用业务逻辑中组装的sessionId获取有效连接后进行后续操作\n * 作者：liuxing(2014-12-26 02:32)\n */\npublic class SessionUtils {\n\n    public static Map<String, Session> clients = new ConcurrentHashMap<>();\n\n    public static void put(String relationId, int userCode, Session session){\n        clients.put(getKey(relationId, userCode), session);\n    }\n\n    public static Session get(String relationId, int userCode){\n        return clients.get(getKey(relationId, userCode));\n    }\n\n    public static void remove(String relationId, int userCode){\n        clients.remove(getKey(relationId, userCode));\n    }\n\n    /**\n     * 判断是否有连接\n     * @param relationId\n     * @param userCode\n     * @return\n     */\n    public static boolean hasConnection(String relationId, int userCode) {\n        return clients.containsKey(getKey(relationId, userCode));\n    }\n\n    /**\n     * 组装唯一识别的key\n     * @param relationId\n     * @param userCode\n     * @return\n     */\n    public static String getKey(String relationId, int userCode) {\n        return relationId + \"_\" + userCode;\n    }\n\n}\n   \n```\n\n推送数据到客户端\n \n在其他业务方法中调用\n\n```java\n\n/**\n * 将数据传回客户端\n * 异步的方式\n * @param relationId\n * @param userCode\n * @param message\n */\npublic void broadcast(String relationId, int userCode, String message) {\n    if (TelSocketSessionUtils.hasConnection(relationId, userCode)) {\n        TelSocketSessionUtils.get(relationId, userCode).getAsyncRemote().sendText(message);\n    } else {\n        throw new NullPointerException(TelSocketSessionUtils.getKey(relationId, userCode) + \" Connection does not exist\");\n    }\n}\n\n```\n\n我是使用异步的方法推送数据，还有同步的方法\n\n详见：<http://docs.oracle.com/javaee/7/api/javax/websocket/Session.html>\n\n客户端代码\n\n```java\nvar webSocket = null;\nvar tryTime = 0;\n$(function () {\n    initSocket();\n\n    window.onbeforeunload = function () {\n        //离开页面时的其他操作\n    };\n});\n\n/**\n * 初始化websocket，建立连接\n */\nfunction initSocket() {\n    if (!window.WebSocket) {\n        alert(\"您的浏览器不支持websocket！\");\n        return false;\n    }\n\n    webSocket = new WebSocket(\"ws://127.0.0.1:8080/websocket.ws/\" + relationId + \"/\" + userCode);\n    \n    // 收到服务端消息\n    webSocket.onmessage = function (msg) {\n        console.log(msg);\n    };\n    \n    // 异常\n    webSocket.onerror = function (event) {\n        console.log(event);\n    };\n    \n    // 建立连接\n    webSocket.onopen = function (event) {\n        console.log(event);\n    };\n\n    // 断线重连\n    webSocket.onclose = function () {\n        // 重试10次，每次之间间隔10秒\n        if (tryTime < 10) {\n            setTimeout(function () {\n                webSocket = null;\n                tryTime++;\n                initSocket();\n            }, 500);\n        } else {\n            tryTime = 0;\n        }\n    };\n\n}\n\n```\n\n其他调试工具\n\nJava实现一个websocket的客户端\n\n依赖：\n\n```xml\n\n<dependency>\n    <groupId>org.java-websocket</groupId>\n    <artifactId>Java-WebSocket</artifactId>\n    <version>1.3.0</version>\n</dependency>\n\n```\n\n代码：\n\n```java\n\nimport java.io.IOException;  \nimport javax.websocket.ClientEndpoint;  \nimport javax.websocket.OnError;  \nimport javax.websocket.OnMessage;  \nimport javax.websocket.OnOpen;  \nimport javax.websocket.Session;  \n   \n@ClientEndpoint  \npublic class MyClient {  \n    @OnOpen  \n    public void onOpen(Session session) {  \n        System.out.println(\"Connected to endpoint: \" + session.getBasicRemote());  \n        try {  \n            session.getBasicRemote().sendText(\"Hello\");  \n        } catch (IOException ex) {  \n        }  \n    }  \n   \n    @OnMessage  \n    public void onMessage(String message) {  \n        System.out.println(message);  \n    }  \n   \n    @OnError  \n    public void onError(Throwable t) {  \n        t.printStackTrace();  \n    }  \n}  \n\n```\n\n\n```java\n    \nimport java.io.BufferedReader;  \nimport java.io.IOException;  \nimport java.io.InputStreamReader;  \nimport java.net.URI;  \nimport javax.websocket.ContainerProvider;  \nimport javax.websocket.DeploymentException;  \nimport javax.websocket.Session;  \nimport javax.websocket.WebSocketContainer;  \n   \npublic class MyClientApp {  \n   \n    public Session session;  \n   \n    protected void start()  \n             {  \n   \n            WebSocketContainer container = ContainerProvider.getWebSocketContainer();  \n   \n            String uri = \"ws://127.0.0.1:8080/websocket.ws/relationId/12345\";  \n            System.out.println(\"Connecting to \" + uri);  \n            try {  \n                session = container.connectToServer(MyClient.class, URI.create(uri));  \n            } catch (DeploymentException e) {  \n                e.printStackTrace();  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }               \n   \n    }  \n    public static void main(String args[]){  \n        MyClientApp client = new MyClientApp();  \n        client.start();  \n   \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String input = \"\";  \n        try {  \n            do{  \n                input = br.readLine();  \n                if(!input.equals(\"exit\"))  \n                    client.session.getBasicRemote().sendText(input);  \n   \n            }while(!input.equals(\"exit\"));  \n   \n        } catch (IOException e) {  \n            // TODO Auto-generated catch block  \n            e.printStackTrace();  \n        }  \n    }  \n}  \n\n```\n\nchrome安装一个websocket客户端调试 \n\n![websocket-01](/images/websocket-01.png)\n\n最后\n\n为了统一的操作体验，对于一些不支持websocket的浏览器，请使用socketjs技术做客户端开发。\n","source":"_posts/websocket-demo.md","raw":"title: Java Websocket实例\ndate: 2015-02-09 23:33:56\ncategory: [Java]\ntags: [websocket]\n---\n记录下自己在用的websocket\n\n##介绍\n\n现在很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），\n由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。\n这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，\n然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。\n\n而最比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求。\n\n在 WebSocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\n    \n##运行环境：\n\n###客户端\n实现了websocket的浏览器\n\n|  |  |\n| :-------- | :--------|\n| Chrome | Supported in version 4+ |\n| Firefox | Supported in version 4+ |\n| Internet Explorer | Supported in version 10+ |\n| Opera |Supported in version 10+ |\n| Safari | Supported in version 5+ |\n\n\n###服务端\n\n####依赖\nTomcat 7.0.47以上 + J2EE7\n\n```xml\n<dependency>\n    <groupId>org.apache.tomcat</groupId>  \n    <artifactId>tomcat-websocket-api</artifactId>  \n    <version>7.0.47</version>  \n    <scope>provided</scope>  \n</dependency>  \n\n<dependency>  \n    <groupId>javax</groupId>  \n    <artifactId>javaee-api</artifactId>  \n    <version>7.0</version>  \n    <scope>provided</scope>  \n</dependency>\n\n```\n\n注意：早前业界没有统一的标准，各服务器都有各自的实现，现在J2EE7的JSR356已经定义了统一的标准，请尽量使用支持最新通用标准的服务器。\n\n详见：\nhttp://www.oracle.com/technetwork/articles/java/jsr356-1937161.html\nhttp://jinnianshilongnian.iteye.com/blog/1909962\n \n我是用的Tomcat 7.0.57 + Java7\n必须是Tomcat 7.0.47以上\n详见：http://www.iteye.com/news/28414\n \nps：最早我们是用的Tomcat 7自带的实现，后来要升级Tomcat 8，结果原来的实现方式在Tomcat 8不支持了，就只好切换到支持Websocket 1.0版本的Tomcat了。\n \n主流的java web服务器都有支持JSR365标准的版本了，请自行Google。 \n\n\n用nginx做反向代理的需要注意啦，socket请求需要做特殊配置的，切记！\n\n\nTomcat的处理方式建议修改为NIO的方式，同时修改连接数到合适的参数，请自行Google！\n\n服务端不需要在web.xml中做额外的配置，Tomcat启动后就可以直接连接了。\n\n\n####实现\n```java\nimport com.dooioo.websocket.utils.SessionUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\n\n/**\n * 功能说明：websocket处理类, 使用J2EE7的标准\n *         切忌直接在该连接处理类中加入业务处理代码\n * 作者：liuxing(2014-11-14 04:20)\n */\n//relationId和userCode是我的业务标识参数,websocket.ws是连接的路径，可以自行定义\n@ServerEndpoint(\"/websocket.ws/{relationId}/{userCode}\")\npublic class WebsocketEndPoint {\n\n    private static Log log = LogFactory.getLog(WebsocketEndPoint.class);\n\n    /**\n     * 打开连接时触发\n     * @param relationId\n     * @param userCode\n     * @param session\n     */\n    @OnOpen\n    public void onOpen(@PathParam(\"relationId\") String relationId,\n                       @PathParam(\"userCode\") int userCode,\n                       Session session){\n        log.info(\"Websocket Start Connecting: \" + SessionUtils.getKey(relationId, userCode));\n        SessionUtils.put(relationId, userCode, session);\n    }\n\n    /**\n     * 收到客户端消息时触发\n     * @param relationId\n     * @param userCode\n     * @param message\n     * @return\n     */\n    @OnMessage\n    public String onMessage(@PathParam(\"relationId\") String relationId,\n                            @PathParam(\"userCode\") int userCode,\n                            String message) {\n        return \"Got your message (\" + message + \").Thanks !\";\n    }\n\n    /**\n     * 异常时触发\n     * @param relationId\n     * @param userCode\n     * @param session\n     */\n    @OnError\n    public void onError(@PathParam(\"relationId\") String relationId,\n                        @PathParam(\"userCode\") int userCode,\n                        Throwable throwable,\n                        Session session) {\n        log.info(\"Websocket Connection Exception: \" + SessionUtils.getKey(relationId, userCode));\n        log.info(throwable.getMessage(), throwable);\n        SessionUtils.remove(relationId, userCode);\n    }\n\n    /**\n     * 关闭连接时触发\n     * @param relationId\n     * @param userCode\n     * @param session\n     */\n    @OnClose\n    public void onClose(@PathParam(\"relationId\") String relationId,\n                        @PathParam(\"userCode\") int userCode,\n                        Session session) {\n        log.info(\"Websocket Close Connection: \" + SessionUtils.getKey(relationId, userCode));\n        SessionUtils.remove(relationId, userCode);\n    }\n\n}\n    \n```\n \n工具类用来存储唯一key和连接\n\n这个是我业务的需要，我的业务是服务器有对应动作触发时，推送数据到客户端，没有接收客户端数据的操作。\n\n```java\nimport javax.websocket.Session;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 功能说明：用来存储业务定义的sessionId和连接的对应关系\n *          利用业务逻辑中组装的sessionId获取有效连接后进行后续操作\n * 作者：liuxing(2014-12-26 02:32)\n */\npublic class SessionUtils {\n\n    public static Map<String, Session> clients = new ConcurrentHashMap<>();\n\n    public static void put(String relationId, int userCode, Session session){\n        clients.put(getKey(relationId, userCode), session);\n    }\n\n    public static Session get(String relationId, int userCode){\n        return clients.get(getKey(relationId, userCode));\n    }\n\n    public static void remove(String relationId, int userCode){\n        clients.remove(getKey(relationId, userCode));\n    }\n\n    /**\n     * 判断是否有连接\n     * @param relationId\n     * @param userCode\n     * @return\n     */\n    public static boolean hasConnection(String relationId, int userCode) {\n        return clients.containsKey(getKey(relationId, userCode));\n    }\n\n    /**\n     * 组装唯一识别的key\n     * @param relationId\n     * @param userCode\n     * @return\n     */\n    public static String getKey(String relationId, int userCode) {\n        return relationId + \"_\" + userCode;\n    }\n\n}\n   \n```\n\n推送数据到客户端\n \n在其他业务方法中调用\n\n```java\n\n/**\n * 将数据传回客户端\n * 异步的方式\n * @param relationId\n * @param userCode\n * @param message\n */\npublic void broadcast(String relationId, int userCode, String message) {\n    if (TelSocketSessionUtils.hasConnection(relationId, userCode)) {\n        TelSocketSessionUtils.get(relationId, userCode).getAsyncRemote().sendText(message);\n    } else {\n        throw new NullPointerException(TelSocketSessionUtils.getKey(relationId, userCode) + \" Connection does not exist\");\n    }\n}\n\n```\n\n我是使用异步的方法推送数据，还有同步的方法\n\n详见：<http://docs.oracle.com/javaee/7/api/javax/websocket/Session.html>\n\n客户端代码\n\n```java\nvar webSocket = null;\nvar tryTime = 0;\n$(function () {\n    initSocket();\n\n    window.onbeforeunload = function () {\n        //离开页面时的其他操作\n    };\n});\n\n/**\n * 初始化websocket，建立连接\n */\nfunction initSocket() {\n    if (!window.WebSocket) {\n        alert(\"您的浏览器不支持websocket！\");\n        return false;\n    }\n\n    webSocket = new WebSocket(\"ws://127.0.0.1:8080/websocket.ws/\" + relationId + \"/\" + userCode);\n    \n    // 收到服务端消息\n    webSocket.onmessage = function (msg) {\n        console.log(msg);\n    };\n    \n    // 异常\n    webSocket.onerror = function (event) {\n        console.log(event);\n    };\n    \n    // 建立连接\n    webSocket.onopen = function (event) {\n        console.log(event);\n    };\n\n    // 断线重连\n    webSocket.onclose = function () {\n        // 重试10次，每次之间间隔10秒\n        if (tryTime < 10) {\n            setTimeout(function () {\n                webSocket = null;\n                tryTime++;\n                initSocket();\n            }, 500);\n        } else {\n            tryTime = 0;\n        }\n    };\n\n}\n\n```\n\n其他调试工具\n\nJava实现一个websocket的客户端\n\n依赖：\n\n```xml\n\n<dependency>\n    <groupId>org.java-websocket</groupId>\n    <artifactId>Java-WebSocket</artifactId>\n    <version>1.3.0</version>\n</dependency>\n\n```\n\n代码：\n\n```java\n\nimport java.io.IOException;  \nimport javax.websocket.ClientEndpoint;  \nimport javax.websocket.OnError;  \nimport javax.websocket.OnMessage;  \nimport javax.websocket.OnOpen;  \nimport javax.websocket.Session;  \n   \n@ClientEndpoint  \npublic class MyClient {  \n    @OnOpen  \n    public void onOpen(Session session) {  \n        System.out.println(\"Connected to endpoint: \" + session.getBasicRemote());  \n        try {  \n            session.getBasicRemote().sendText(\"Hello\");  \n        } catch (IOException ex) {  \n        }  \n    }  \n   \n    @OnMessage  \n    public void onMessage(String message) {  \n        System.out.println(message);  \n    }  \n   \n    @OnError  \n    public void onError(Throwable t) {  \n        t.printStackTrace();  \n    }  \n}  \n\n```\n\n\n```java\n    \nimport java.io.BufferedReader;  \nimport java.io.IOException;  \nimport java.io.InputStreamReader;  \nimport java.net.URI;  \nimport javax.websocket.ContainerProvider;  \nimport javax.websocket.DeploymentException;  \nimport javax.websocket.Session;  \nimport javax.websocket.WebSocketContainer;  \n   \npublic class MyClientApp {  \n   \n    public Session session;  \n   \n    protected void start()  \n             {  \n   \n            WebSocketContainer container = ContainerProvider.getWebSocketContainer();  \n   \n            String uri = \"ws://127.0.0.1:8080/websocket.ws/relationId/12345\";  \n            System.out.println(\"Connecting to \" + uri);  \n            try {  \n                session = container.connectToServer(MyClient.class, URI.create(uri));  \n            } catch (DeploymentException e) {  \n                e.printStackTrace();  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }               \n   \n    }  \n    public static void main(String args[]){  \n        MyClientApp client = new MyClientApp();  \n        client.start();  \n   \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  \n        String input = \"\";  \n        try {  \n            do{  \n                input = br.readLine();  \n                if(!input.equals(\"exit\"))  \n                    client.session.getBasicRemote().sendText(input);  \n   \n            }while(!input.equals(\"exit\"));  \n   \n        } catch (IOException e) {  \n            // TODO Auto-generated catch block  \n            e.printStackTrace();  \n        }  \n    }  \n}  \n\n```\n\nchrome安装一个websocket客户端调试 \n\n![websocket-01](/images/websocket-01.png)\n\n最后\n\n为了统一的操作体验，对于一些不支持websocket的浏览器，请使用socketjs技术做客户端开发。\n","slug":"websocket-demo","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb3y001p970q2yvowl0p"},{"title":"spring4.x不兼容ibatis的解决方法 ","date":"2015-04-20T16:46:00.000Z","_content":"\n因为spring升级到4.x后，orm包里面移除了对ibatis的支持，\n如果orm使用4.x版本的话项目会启动失败。\n查看orm-3.x版本的SqlMapClientFactoryBean类，里面说的很清楚，只支持到3.x。\n如果可以升级到mybatis的话尽量升级，否则可以使用如下方法。\norm包单独使用3.x的版本，项目中正式在用，还没出现问题（或许还没爆出来哭）\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-orm</artifactId>\n    <version>3.2.13.RELEASE</version>\n</dependency>\n```","source":"_posts/spring4.x不兼容ibatis的解决方法 .md","raw":"title: \"spring4.x不兼容ibatis的解决方法 \"\ndate: 2015-04-21 00:46\ncategory: [Java]\ntags: [spring,框架,ibatis]\n---\n\n因为spring升级到4.x后，orm包里面移除了对ibatis的支持，\n如果orm使用4.x版本的话项目会启动失败。\n查看orm-3.x版本的SqlMapClientFactoryBean类，里面说的很清楚，只支持到3.x。\n如果可以升级到mybatis的话尽量升级，否则可以使用如下方法。\norm包单独使用3.x的版本，项目中正式在用，还没出现问题（或许还没爆出来哭）\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-orm</artifactId>\n    <version>3.2.13.RELEASE</version>\n</dependency>\n```","slug":"spring4.x不兼容ibatis的解决方法 ","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb41001s970qdnk1hpeb"},{"title":"linux软件的安装、更新与卸载","date":"2014-04-24T17:52:00.000Z","_content":"\n##介绍\nLinux常见的安装为tar，zip，gz，rpm，deb，bin等。可以简单的分为三类.\n\n> - 打包或压缩文件tar，zip，gz等，一般解压后即可，或者解压后运行sh文件；\n> - 对应的有管理工具的deb，rpm等，通常的这类安装文件可以通过第三方的命令行或UI来简单的安装。\n  例如Ubuntu中的apt来安装；deb，Redhat中的yum来安装rpm；\n> - 像.bin类，其实就是把sh和zip打包为bin，或把sh和rpm打包为bin等，当在命令行运行bin安装文件时，其实就是bin里面的sh来解压bin中的zip或安装rpm的过程\n\n<br/><br/>\n\n##安装\n###rpm安装，更新与卸载\n\n*RPM包，这种软件包就像windows的EXE安装文件一样，各种文件已经编译好，并打了包，哪个文件该放到哪个文件夹，都指定好了，安装非常方便，在图形界面里你只需要双击就能自动安装。但是有一点不好，就是包的依赖关系，很恶心。*\n\n```bash\nA. rpm安装\n\n  1) 找到相应的软件包，比如jmagick-6.4.0-3.src.rpm，下载到本机某个目录；\n  2) 打开一个终端，su 成root用户；\n  3) cd jmagick-6.4.0-3.src.rpm所在的目录；\n  4) 输入rpm -ivh jmagick-6.4.0-3.src.rpm\n\nB.rpm更新\n   #rpm -Uvh jmagick-6.4.0-3.src.rpm\n\nC.rpm卸载\n\n   1) 查找欲卸载的软件包 rpm -qa | grep ×XXX×\n   2) 例如找到软件mysql-4.1.22-2.el4_8.4 ，执行rpm -e mysql-4.1.22-2.el4_8.4\n\n 注意：查询软件的安装目录，用命令 rpm -ql mysql-4.1.22-2.el4_8.4\n```\n \n###以.bin结尾的安装包\n\n*bin类似rpm包安装，也比较简单*\n\n```bash\nbin安装\n    1) 打开一个SHELL，即终端\n    2) 用CD 命令进入源代码压缩包所在的目录\n    3) 给文件加上可执行属性：chmod +x ******.bin(中间是字母x，小写)\n    4) 执行命令：./******.bin 或者 直接执行 sh ******.bin\n\n   bin卸载\n     把安装时中选择的安装目录删除就OK\n```\n\n###tar.gz(bz或bz2等)结尾的源代码包\n\n*这种软件包里面都是源程序，没有编译过，需要编译后才能安装*\n\n```bash\n源代码安装\n    1) 打开一个SHELL，即终端\n    2) 用CD 命令进入源代码压缩包所在的目录\n    3) 根据压缩包类型解压缩文件(*代表压缩包名称)\n　　   tar -zxvf ****.tar.gz\n　　   tar -jxvf ****.tar.bz(或bz2)\n    4) 用CD命令进入解压缩后的目录\n    5) 输入编译文件命令：./configure(有的压缩包已经编译过，这一步可以省去)\n    6) 然后是命令：make\n    7) 再是安装文件命令：make install\n```\n\n###yum安装\n\n*yum是rpm的管理工具，管理一个软件库，可以很好的解决依赖关系*\n\n```bash\n1) yum安装\n    yum install -y 软件名\n\n2) yum更新\n    yum update -y  软件名\n\n3) yum卸载\n    yum remove -y 软件名\n    或\n    yum erase -y 软件名\n```\n\n###apt-get安装\n\n```bash\napt-get 是deb的管理工具，类似yum\napt-get install package 安装包\napt-get reinstall package  重新安装包\napt-get upgrade 更新已安装的包\napt-cache rdepends package 是查看该包被哪些包依赖\napt-cache depends package 了解使用依赖\napt-get clean &&  apt-get autoclean 清理无用的包\napt-cache show package 获取包的相关信息，如说明、大小、版本等\napt-get remove package 删除包\napt-get purge package  删除包，包括删除配置文件等\n```","source":"_posts/linux软件的安装、更新与卸载.md","raw":"title: \"linux软件的安装、更新与卸载\"\ndate: 2014-04-25 01:52\ncategory: [系统配置]\ntags: [linux]\n---\n\n##介绍\nLinux常见的安装为tar，zip，gz，rpm，deb，bin等。可以简单的分为三类.\n\n> - 打包或压缩文件tar，zip，gz等，一般解压后即可，或者解压后运行sh文件；\n> - 对应的有管理工具的deb，rpm等，通常的这类安装文件可以通过第三方的命令行或UI来简单的安装。\n  例如Ubuntu中的apt来安装；deb，Redhat中的yum来安装rpm；\n> - 像.bin类，其实就是把sh和zip打包为bin，或把sh和rpm打包为bin等，当在命令行运行bin安装文件时，其实就是bin里面的sh来解压bin中的zip或安装rpm的过程\n\n<br/><br/>\n\n##安装\n###rpm安装，更新与卸载\n\n*RPM包，这种软件包就像windows的EXE安装文件一样，各种文件已经编译好，并打了包，哪个文件该放到哪个文件夹，都指定好了，安装非常方便，在图形界面里你只需要双击就能自动安装。但是有一点不好，就是包的依赖关系，很恶心。*\n\n```bash\nA. rpm安装\n\n  1) 找到相应的软件包，比如jmagick-6.4.0-3.src.rpm，下载到本机某个目录；\n  2) 打开一个终端，su 成root用户；\n  3) cd jmagick-6.4.0-3.src.rpm所在的目录；\n  4) 输入rpm -ivh jmagick-6.4.0-3.src.rpm\n\nB.rpm更新\n   #rpm -Uvh jmagick-6.4.0-3.src.rpm\n\nC.rpm卸载\n\n   1) 查找欲卸载的软件包 rpm -qa | grep ×XXX×\n   2) 例如找到软件mysql-4.1.22-2.el4_8.4 ，执行rpm -e mysql-4.1.22-2.el4_8.4\n\n 注意：查询软件的安装目录，用命令 rpm -ql mysql-4.1.22-2.el4_8.4\n```\n \n###以.bin结尾的安装包\n\n*bin类似rpm包安装，也比较简单*\n\n```bash\nbin安装\n    1) 打开一个SHELL，即终端\n    2) 用CD 命令进入源代码压缩包所在的目录\n    3) 给文件加上可执行属性：chmod +x ******.bin(中间是字母x，小写)\n    4) 执行命令：./******.bin 或者 直接执行 sh ******.bin\n\n   bin卸载\n     把安装时中选择的安装目录删除就OK\n```\n\n###tar.gz(bz或bz2等)结尾的源代码包\n\n*这种软件包里面都是源程序，没有编译过，需要编译后才能安装*\n\n```bash\n源代码安装\n    1) 打开一个SHELL，即终端\n    2) 用CD 命令进入源代码压缩包所在的目录\n    3) 根据压缩包类型解压缩文件(*代表压缩包名称)\n　　   tar -zxvf ****.tar.gz\n　　   tar -jxvf ****.tar.bz(或bz2)\n    4) 用CD命令进入解压缩后的目录\n    5) 输入编译文件命令：./configure(有的压缩包已经编译过，这一步可以省去)\n    6) 然后是命令：make\n    7) 再是安装文件命令：make install\n```\n\n###yum安装\n\n*yum是rpm的管理工具，管理一个软件库，可以很好的解决依赖关系*\n\n```bash\n1) yum安装\n    yum install -y 软件名\n\n2) yum更新\n    yum update -y  软件名\n\n3) yum卸载\n    yum remove -y 软件名\n    或\n    yum erase -y 软件名\n```\n\n###apt-get安装\n\n```bash\napt-get 是deb的管理工具，类似yum\napt-get install package 安装包\napt-get reinstall package  重新安装包\napt-get upgrade 更新已安装的包\napt-cache rdepends package 是查看该包被哪些包依赖\napt-cache depends package 了解使用依赖\napt-get clean &&  apt-get autoclean 清理无用的包\napt-cache show package 获取包的相关信息，如说明、大小、版本等\napt-get remove package 删除包\napt-get purge package  删除包，包括删除配置文件等\n```","slug":"linux软件的安装、更新与卸载","published":1,"updated":"2015-06-11T08:09:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb45001z970qvfd1jbm5"},{"title":"jquery常用选择器","date":"2015-01-31T16:00:00.000Z","_content":"\n记录一下\n\n##选择器\n###基本选择器\n `#`id —— 根据指定的id匹配一个元素\n element —— 根据“元素名”匹配元素\n .class —— 根据指定的“类名”匹配元素\n selector1,selector2,selector3... —— 组合选择器，为并集关系\n * —— 通用选择器， 匹配所有元素\n\n###层次选择器\n $('ancestor descendant') —— 匹配ancestor下的所有descendant元素， 包括子孙节点\n $('parent > child') —— 匹配parent下的所有child元素， 注意child为parent的直接子节点， 即不包含子孙节点\n $('prev + next') —— 匹配pre元素后的next元素\n $('prev~siblings') —— 匹配prev元素后的所有siblings元素\n\n###基本过滤选择器（针对一个集合的操作，可以把这个集合想象成ArrayList）\n :first —— 选择第一个元素， 如$('div:first')， 选择第一个div元素\n :last —— 选择最后一个元素\n :not(selector) —— 过滤掉所有与给定selector匹配的元素，如$('input:not(.myClass)')选取class不是myClass的input元素\n :even —— 选取索引是偶数的所有元素， 索引从0开始\n :odd —— 选取索引是奇数的所有元素\n :eq(index)  —— 选取索引是index的元素\n :gt(index) —— 选取索引大于index的所有元素\n :header —— 选取所有的标题元素，如h1,h2,h3等\n :animated —— 选取当前正在进行动画的的所有元素\n\n###子元素过滤器（父元素的第几个孩子，故在使用时都会以父元素作为上下文）\n :nth-child —— 选取父元素的第几个孩子， 注意索引下标从1开始， 而:eq(index)是从0开始的\n :nth-child(even) 选取父元素下索引值是偶数的子元素\n :nth-child(odd) 选取父元素下索引值是奇数的子元素\n :nth-child(index) 选取父元素下索引值为index的子元素\n :nth-child(3n) 选取父元素下索引值是3的倍数的元素（n从0开始）\n :nth-child(3n+1) 选取父元素下索引值是3n+1的元素 （n从0开始）\n :first-child —— 父元素下的第一个孩子\n :last-child —— 父元素下的最后一个孩子\n :only-child —— 父元素下的唯一孩子（选中独生子）\n\n###内容过滤选择器\n :contains(text) —— 选取含有文本内容为\"text\"的元素\n :empty —— 选取不包含子元素或文本的空元素\n :has(selector) —— 选取含有选择器所匹配的元素的元素，如$('div:has(p)')选取含有p元素的所有div元素\n :parent —— 选取含有子元素或文本的元素，如$('div:parent')选取拥有子元素或文本元素的所有div元素\n\n###可见性过滤选择器\n :hidden ——  选取所有不可见元素，包括hidden， display:none，visibility:hidden元素，若只想选择input，则可用input:hidden\n :visible —— 选取所有可见元素\n\n###属性过滤选择器\n [attribute] —— 选取拥有此属性的元素\n [attribute=value] —— 选取属性值为value的元素\n [attribute!=value] —— 选取属性值不等于value的元素\n [attribute^=value] —— 选取属性值以value开头的元素\n [attribute$=value] —— 选取属性值以vlue结尾的元素\n [attribute*=value] —— 选取属性值包含value的元素\n [selector1][selector2][selector3] —— 复合属性选择器，交集关系， 如$(\"div[id][title$='test']\")选取拥有属性id，并且属性title以\"test\"结尾的div元素\n\n###表单对象属性过滤器\n :enabled —— 选取所有可用元素\n :disabled —— 选取所有不可用元素\n :checked —— 选取所有被选中的元素（单选和复选框）\n :selected —— 选取所有被选中的select元素\n\n###表单选择器\n :input —— 选取所有的input,textarea,select,button元素\n :text —— 选取所有的单行文本\n :password —— 选取所有的密码框\n :radio —— 选取所有的单选按钮\n :checkbox —— 选取所有的复选框\n :submit —— 选取所有的提交按钮\n :image —— 选取所有的图像按钮\n :reset —— 选取所有的重置按钮\n :button —— 选取所有的按钮\n :file —— 选取所有的上传文件域\n :hidden —— 选取所拥有不可见元素\n \n ##更多\n 更多语法参阅API文档\n \n http://jquery.cuishifeng.cn","source":"_posts/jquery常用选择器.md","raw":"title: \"jquery常用选择器\"\ndate: 2015-02-01 00:00:00\ncategory: [前端]\ntags: [jquery]\n---\n\n记录一下\n\n##选择器\n###基本选择器\n `#`id —— 根据指定的id匹配一个元素\n element —— 根据“元素名”匹配元素\n .class —— 根据指定的“类名”匹配元素\n selector1,selector2,selector3... —— 组合选择器，为并集关系\n * —— 通用选择器， 匹配所有元素\n\n###层次选择器\n $('ancestor descendant') —— 匹配ancestor下的所有descendant元素， 包括子孙节点\n $('parent > child') —— 匹配parent下的所有child元素， 注意child为parent的直接子节点， 即不包含子孙节点\n $('prev + next') —— 匹配pre元素后的next元素\n $('prev~siblings') —— 匹配prev元素后的所有siblings元素\n\n###基本过滤选择器（针对一个集合的操作，可以把这个集合想象成ArrayList）\n :first —— 选择第一个元素， 如$('div:first')， 选择第一个div元素\n :last —— 选择最后一个元素\n :not(selector) —— 过滤掉所有与给定selector匹配的元素，如$('input:not(.myClass)')选取class不是myClass的input元素\n :even —— 选取索引是偶数的所有元素， 索引从0开始\n :odd —— 选取索引是奇数的所有元素\n :eq(index)  —— 选取索引是index的元素\n :gt(index) —— 选取索引大于index的所有元素\n :header —— 选取所有的标题元素，如h1,h2,h3等\n :animated —— 选取当前正在进行动画的的所有元素\n\n###子元素过滤器（父元素的第几个孩子，故在使用时都会以父元素作为上下文）\n :nth-child —— 选取父元素的第几个孩子， 注意索引下标从1开始， 而:eq(index)是从0开始的\n :nth-child(even) 选取父元素下索引值是偶数的子元素\n :nth-child(odd) 选取父元素下索引值是奇数的子元素\n :nth-child(index) 选取父元素下索引值为index的子元素\n :nth-child(3n) 选取父元素下索引值是3的倍数的元素（n从0开始）\n :nth-child(3n+1) 选取父元素下索引值是3n+1的元素 （n从0开始）\n :first-child —— 父元素下的第一个孩子\n :last-child —— 父元素下的最后一个孩子\n :only-child —— 父元素下的唯一孩子（选中独生子）\n\n###内容过滤选择器\n :contains(text) —— 选取含有文本内容为\"text\"的元素\n :empty —— 选取不包含子元素或文本的空元素\n :has(selector) —— 选取含有选择器所匹配的元素的元素，如$('div:has(p)')选取含有p元素的所有div元素\n :parent —— 选取含有子元素或文本的元素，如$('div:parent')选取拥有子元素或文本元素的所有div元素\n\n###可见性过滤选择器\n :hidden ——  选取所有不可见元素，包括hidden， display:none，visibility:hidden元素，若只想选择input，则可用input:hidden\n :visible —— 选取所有可见元素\n\n###属性过滤选择器\n [attribute] —— 选取拥有此属性的元素\n [attribute=value] —— 选取属性值为value的元素\n [attribute!=value] —— 选取属性值不等于value的元素\n [attribute^=value] —— 选取属性值以value开头的元素\n [attribute$=value] —— 选取属性值以vlue结尾的元素\n [attribute*=value] —— 选取属性值包含value的元素\n [selector1][selector2][selector3] —— 复合属性选择器，交集关系， 如$(\"div[id][title$='test']\")选取拥有属性id，并且属性title以\"test\"结尾的div元素\n\n###表单对象属性过滤器\n :enabled —— 选取所有可用元素\n :disabled —— 选取所有不可用元素\n :checked —— 选取所有被选中的元素（单选和复选框）\n :selected —— 选取所有被选中的select元素\n\n###表单选择器\n :input —— 选取所有的input,textarea,select,button元素\n :text —— 选取所有的单行文本\n :password —— 选取所有的密码框\n :radio —— 选取所有的单选按钮\n :checkbox —— 选取所有的复选框\n :submit —— 选取所有的提交按钮\n :image —— 选取所有的图像按钮\n :reset —— 选取所有的重置按钮\n :button —— 选取所有的按钮\n :file —— 选取所有的上传文件域\n :hidden —— 选取所拥有不可见元素\n \n ##更多\n 更多语法参阅API文档\n \n http://jquery.cuishifeng.cn","slug":"jquery常用选择器","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb480023970qmvrwpfsn"},{"title":"java和数据库计算两个坐标的距离","date":"2015-04-20T16:41:00.000Z","_content":"\n##使用Java进行计算\n\n```java\n/**\n * 类功能说明：地图坐标距离计算工具类\n * Title: DistanceUtil.java\n * @author liuxing\n * @date 2013-9-8 下午10:36:03\n * @version V1.0\n */\npublic class DistanceUtil {\n\n\tprivate static double DEF_PI = Math.PI; // PI\n\tprivate static double DEF_2PI = Math.PI * 2; // 2*PI\n\tprivate static double DEF_PI180 = Math.PI / 180; // PI/180.0\n\tprivate static double DEF_R = 6370693.5; // 地球半径\n\n\t/**\n\t * \n\t * 功能说明：计算两个地图坐标点之间的距离（近距离计算）\n\t * liuxing 2013-9-8 下午10:42:17\n\t * @param lng1 起点经度\n\t * @param lat1 起点纬度\n\t * @param lng2 终点经度\n\t * @param lat2 终点纬度\n\t * @return\n\t */\n\tpublic static double getShortDistance(double lng1, double lat1, double lng2, double lat2) {\n\t\tdouble ew1, ns1, ew2, ns2;\n\t\tdouble dx, dy, dew;\n\t\tdouble distance;\n\t\t// 角度转换为弧度\n\t\tew1 = Math.toRadians(lng1);\n\t\tns1 = Math.toRadians(lat1);\n\t\tew2 = Math.toRadians(lng2);\n\t\tns2 = Math.toRadians(lat2);\n\t\t\n\t\t// 经度差\n\t\tdew = ew1 - ew2;\n\t\t// 若跨东经和西经180 度，进行调整\n\t\tif (dew > DEF_PI){\n\t\t\tdew = DEF_2PI - dew;\n\t\t} else if (dew < -DEF_PI){\n\t\t\tdew = DEF_2PI + dew;\n\t\t}\n\t\t\t\n\t\tdx = DEF_R * Math.cos(ns1) * dew; \t// 东西方向长度(在纬度圈上的投影长度)\n\t\tdy = DEF_R * (ns1 - ns2); \t\t\t// 南北方向长度(在经度圈上的投影长度)\n\t\t// 勾股定理求斜边长\n\t\tdistance = Math.sqrt(dx * dx + dy * dy);\n\t\treturn distance;\n\t}\n\n\t/**\n\t * \n\t * 功能说明：计算两个地图坐标点之间的距离（远距离计算）\n\t * liuxing 2013-9-8 下午10:43:21\n\t * @param lng1 起点经度\n\t * @param lat1 起点纬度\n\t * @param lng2 终点经度\n\t * @param lat2 终点纬度\n\t * @return\n\t */\n\tpublic static double getLongDistance(double lng1, double lat1, double lng2, double lat2) {\n\t\tdouble ew1, ns1, ew2, ns2;\n\t\tdouble distance;\n\t\t\n\t\t// 角度转换为弧度\n\t\tew1 = lng1 * DEF_PI180;\n\t\tns1 = lat1 * DEF_PI180;\n\t\tew2 = lng2 * DEF_PI180;\n\t\tns2 = lat2 * DEF_PI180;\n\t\t\n\t\t// 求大圆劣弧与球心所夹的角(弧度)\n\t\tdistance = Math.sin(ns1) * Math.sin(ns2) + Math.cos(ns1) * Math.cos(ns2) * Math.cos(ew1 - ew2);\n\t\t// 调整到[-1..1]范围内，避免溢出\n\t\tif (distance > 1.0){\n\t\t\tdistance = 1.0;\n\t\t} else if (distance < -1.0){\n\t\t\tdistance = -1.0;\n\t\t}\n\t\t\n\t\t// 求大圆劣弧长度\n\t\tdistance = DEF_R * Math.acos(distance);\n\t\treturn distance;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble mLat1 = 31.24081800000000; \t// point1纬度\n\t\tdouble mLng1 = 121.46541700000000; \t// point1经度\n\t\tdouble mLat2 = 31.239946;\t// point2纬度\n\t\tdouble mLng2 = 121.466417;\t// point2经度\n\t\t\n\t\tdouble distanceByShort = getShortDistance(mLng1, mLat1, mLng2, mLat2);\n\t\tSystem.out.println(distanceByShort);\n\t\t\n\t\tdouble distanceByLong = getLongDistance(mLng1, mLat1, mLng2, mLat2);\n\t\tSystem.out.println(distanceByLong);\n\t}\n\n}\n```\n\n##使用SqlServer函数计算\n\n其他数据库版本请找到相应的函数替换后移植\n\n```sql\n-- =============================================\n-- Author:      liuxing\n-- Create date: 2013-09-10\n-- Description:\t计算2个坐标点的距离（短距离计算）\n-- =============================================\nCREATE function dbo.fn_getShortDistance(\n\t @lng1 decimal(19,11)\n\t,@lat1 decimal(19,11)\n\t,@lng2 decimal(19,11)\n\t,@lat2 decimal(19,11)\n)\nreturns decimal(19,11)\nAS\nBEGIN\n\t--declare @lng1 decimal(19,11)\n\t--declare @lat1 decimal(19,11)\n\t--declare @lng2 decimal(19,11)\n\t--declare @lat2 decimal(19,11)\n\n\n\t--set @lat1 = 31.238662--; \t// point1纬度\n\t--set @lng1 = 121.466633--; // point1经度\n\t--set @lat2 = 31.239727--;\t// point2纬度\n\t--set @lng2 = 121.462745--;\t// point2经度\n\tdeclare @ew1 decimal(19,11)\n\t\t, @ns1 decimal(19,11)\n\t\t, @ew2 decimal(19,11)\n\t\t, @ns2 decimal(19,11)\n\t\t, @dx decimal(19,11)\n\t\t, @dy decimal(19,11)\n\t\t, @dew decimal(19,11)\n\t\t, @distance decimal(19,11)\n\t-- 角度转换为弧度\n\tset @ew1 = Radians(@lng1)-- * 0.01745329252;\n\tset @ns1 = Radians(@lat1)-- * 0.01745329252;\n\tset @ew2 = Radians(@lng2)-- * 0.01745329252;\n\tset @ns2 = Radians(@lat2)-- * 0.01745329252;\n\t-- 经度差\n\tset @dew = @ew1 - @ew2;\n\t-- 若跨东经和西经180 度，进行调整\n\tif (@dew > Pi())\n\tbegin\n\t\tset @dew = 2 * Pi() - @dew;\n\tend\n\telse if (@dew < -Pi())\n\tbegin\n\t\tset @dew = 2 * Pi() + @dew;\n\tend\n\t\t\n\tset @dx = 6370693.5 * Cos(@ns1) * @dew -- 东西方向长度(在纬度圈上的投影长度)\n\tset @dy = 6370693.5 * (@ns1 - @ns2)   -- 南北方向长度(在经度圈上的投影长度)\n\t-- 勾股定理求斜边长,开平方根\n\tset @distance = sqrt(@dx * @dx + @dy * @dy);\n\treturn @distance;\n\t--print @distance\nEND\n```","source":"_posts/java和数据库计算两个坐标的距离.md","raw":"title: \"java和数据库计算两个坐标的距离\"\ndate: 2015-04-21 00:41\ncategory: [Java]\ntags: [地图,坐标运算,距离]\n---\n\n##使用Java进行计算\n\n```java\n/**\n * 类功能说明：地图坐标距离计算工具类\n * Title: DistanceUtil.java\n * @author liuxing\n * @date 2013-9-8 下午10:36:03\n * @version V1.0\n */\npublic class DistanceUtil {\n\n\tprivate static double DEF_PI = Math.PI; // PI\n\tprivate static double DEF_2PI = Math.PI * 2; // 2*PI\n\tprivate static double DEF_PI180 = Math.PI / 180; // PI/180.0\n\tprivate static double DEF_R = 6370693.5; // 地球半径\n\n\t/**\n\t * \n\t * 功能说明：计算两个地图坐标点之间的距离（近距离计算）\n\t * liuxing 2013-9-8 下午10:42:17\n\t * @param lng1 起点经度\n\t * @param lat1 起点纬度\n\t * @param lng2 终点经度\n\t * @param lat2 终点纬度\n\t * @return\n\t */\n\tpublic static double getShortDistance(double lng1, double lat1, double lng2, double lat2) {\n\t\tdouble ew1, ns1, ew2, ns2;\n\t\tdouble dx, dy, dew;\n\t\tdouble distance;\n\t\t// 角度转换为弧度\n\t\tew1 = Math.toRadians(lng1);\n\t\tns1 = Math.toRadians(lat1);\n\t\tew2 = Math.toRadians(lng2);\n\t\tns2 = Math.toRadians(lat2);\n\t\t\n\t\t// 经度差\n\t\tdew = ew1 - ew2;\n\t\t// 若跨东经和西经180 度，进行调整\n\t\tif (dew > DEF_PI){\n\t\t\tdew = DEF_2PI - dew;\n\t\t} else if (dew < -DEF_PI){\n\t\t\tdew = DEF_2PI + dew;\n\t\t}\n\t\t\t\n\t\tdx = DEF_R * Math.cos(ns1) * dew; \t// 东西方向长度(在纬度圈上的投影长度)\n\t\tdy = DEF_R * (ns1 - ns2); \t\t\t// 南北方向长度(在经度圈上的投影长度)\n\t\t// 勾股定理求斜边长\n\t\tdistance = Math.sqrt(dx * dx + dy * dy);\n\t\treturn distance;\n\t}\n\n\t/**\n\t * \n\t * 功能说明：计算两个地图坐标点之间的距离（远距离计算）\n\t * liuxing 2013-9-8 下午10:43:21\n\t * @param lng1 起点经度\n\t * @param lat1 起点纬度\n\t * @param lng2 终点经度\n\t * @param lat2 终点纬度\n\t * @return\n\t */\n\tpublic static double getLongDistance(double lng1, double lat1, double lng2, double lat2) {\n\t\tdouble ew1, ns1, ew2, ns2;\n\t\tdouble distance;\n\t\t\n\t\t// 角度转换为弧度\n\t\tew1 = lng1 * DEF_PI180;\n\t\tns1 = lat1 * DEF_PI180;\n\t\tew2 = lng2 * DEF_PI180;\n\t\tns2 = lat2 * DEF_PI180;\n\t\t\n\t\t// 求大圆劣弧与球心所夹的角(弧度)\n\t\tdistance = Math.sin(ns1) * Math.sin(ns2) + Math.cos(ns1) * Math.cos(ns2) * Math.cos(ew1 - ew2);\n\t\t// 调整到[-1..1]范围内，避免溢出\n\t\tif (distance > 1.0){\n\t\t\tdistance = 1.0;\n\t\t} else if (distance < -1.0){\n\t\t\tdistance = -1.0;\n\t\t}\n\t\t\n\t\t// 求大圆劣弧长度\n\t\tdistance = DEF_R * Math.acos(distance);\n\t\treturn distance;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble mLat1 = 31.24081800000000; \t// point1纬度\n\t\tdouble mLng1 = 121.46541700000000; \t// point1经度\n\t\tdouble mLat2 = 31.239946;\t// point2纬度\n\t\tdouble mLng2 = 121.466417;\t// point2经度\n\t\t\n\t\tdouble distanceByShort = getShortDistance(mLng1, mLat1, mLng2, mLat2);\n\t\tSystem.out.println(distanceByShort);\n\t\t\n\t\tdouble distanceByLong = getLongDistance(mLng1, mLat1, mLng2, mLat2);\n\t\tSystem.out.println(distanceByLong);\n\t}\n\n}\n```\n\n##使用SqlServer函数计算\n\n其他数据库版本请找到相应的函数替换后移植\n\n```sql\n-- =============================================\n-- Author:      liuxing\n-- Create date: 2013-09-10\n-- Description:\t计算2个坐标点的距离（短距离计算）\n-- =============================================\nCREATE function dbo.fn_getShortDistance(\n\t @lng1 decimal(19,11)\n\t,@lat1 decimal(19,11)\n\t,@lng2 decimal(19,11)\n\t,@lat2 decimal(19,11)\n)\nreturns decimal(19,11)\nAS\nBEGIN\n\t--declare @lng1 decimal(19,11)\n\t--declare @lat1 decimal(19,11)\n\t--declare @lng2 decimal(19,11)\n\t--declare @lat2 decimal(19,11)\n\n\n\t--set @lat1 = 31.238662--; \t// point1纬度\n\t--set @lng1 = 121.466633--; // point1经度\n\t--set @lat2 = 31.239727--;\t// point2纬度\n\t--set @lng2 = 121.462745--;\t// point2经度\n\tdeclare @ew1 decimal(19,11)\n\t\t, @ns1 decimal(19,11)\n\t\t, @ew2 decimal(19,11)\n\t\t, @ns2 decimal(19,11)\n\t\t, @dx decimal(19,11)\n\t\t, @dy decimal(19,11)\n\t\t, @dew decimal(19,11)\n\t\t, @distance decimal(19,11)\n\t-- 角度转换为弧度\n\tset @ew1 = Radians(@lng1)-- * 0.01745329252;\n\tset @ns1 = Radians(@lat1)-- * 0.01745329252;\n\tset @ew2 = Radians(@lng2)-- * 0.01745329252;\n\tset @ns2 = Radians(@lat2)-- * 0.01745329252;\n\t-- 经度差\n\tset @dew = @ew1 - @ew2;\n\t-- 若跨东经和西经180 度，进行调整\n\tif (@dew > Pi())\n\tbegin\n\t\tset @dew = 2 * Pi() - @dew;\n\tend\n\telse if (@dew < -Pi())\n\tbegin\n\t\tset @dew = 2 * Pi() + @dew;\n\tend\n\t\t\n\tset @dx = 6370693.5 * Cos(@ns1) * @dew -- 东西方向长度(在纬度圈上的投影长度)\n\tset @dy = 6370693.5 * (@ns1 - @ns2)   -- 南北方向长度(在经度圈上的投影长度)\n\t-- 勾股定理求斜边长,开平方根\n\tset @distance = sqrt(@dx * @dx + @dy * @dy);\n\treturn @distance;\n\t--print @distance\nEND\n```","slug":"java和数据库计算两个坐标的距离","published":1,"updated":"2015-06-11T21:03:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb4b0027970q50c6tfz6"},{"title":"备忘","date":"2014-12-31T16:00:00.000Z","_content":"记录工作中遇到的一些小问题及解决办法，以防忘记后重头再找答案。\n\n##格式:\n问:Win7下 Eclipse中按\"Alt+Ctrl+Down或Alt+Ctrl+Up\"时，结果屏幕倒了怎么办？  \n答:是不是和其它应用的快捷键冲突了？比如Intel显卡，则可选择“图形属性”>“选项和支持”，将对应快捷键换掉。参考:http://www.2cto.com/os/201201/116412.html\n\n##或作为url收藏记录\n- Markdown语法: <http://wowubuntu.com/markdown/basic.html>  \n    马克飞象: <http://maxiang.info/>\n    Cmd Markdown: <https://www.zybuluo.com/mdeditor>\n    代码显示规范: <http://hexo.chenall.net/post/code/>\n- Oracle现在真是恶心，下载个Java SDK还非得让登陆不可。只好再找下载地址了: <http://ghaffarian.net/downloads/>  \n- GIT文章收藏:  \n    Git分支管理策略: <http://www.ruanyifeng.com/blog/2012/07/git.html>    \n    Git查看、删除、重命名远程分支和tag: http://zengrong.net/post/1746.htm  \n- Google无障碍浏览链接: <https://github.com/greatfire/wiki>  \n- 在线Android等源码: <http://www.grepcode.com/>, <http://androidxref.com/>  \n- Twitter University: <http://www.bluemobi.cn/>  \n\n##本项目使用了\n\n- CNZZ的网站统计服务，官网:<http://cnzz.com/>\n- 友言的网友评论服务，官网:<http://www.uyan.cc/>  \n- Google 的Adsense广告，官网:<https://www.google.com/adsense/login/zh_CN/>  \n\n如需查看或管理网站统计、评论或广告，请自行注册帐号并修改_includes目录下相关文件。","source":"_posts/faqs.md","raw":"title: \"备忘\"\ndate: 2015-01-01 00:00:00\ncategory: [其他]\ntags:\n---\n记录工作中遇到的一些小问题及解决办法，以防忘记后重头再找答案。\n\n##格式:\n问:Win7下 Eclipse中按\"Alt+Ctrl+Down或Alt+Ctrl+Up\"时，结果屏幕倒了怎么办？  \n答:是不是和其它应用的快捷键冲突了？比如Intel显卡，则可选择“图形属性”>“选项和支持”，将对应快捷键换掉。参考:http://www.2cto.com/os/201201/116412.html\n\n##或作为url收藏记录\n- Markdown语法: <http://wowubuntu.com/markdown/basic.html>  \n    马克飞象: <http://maxiang.info/>\n    Cmd Markdown: <https://www.zybuluo.com/mdeditor>\n    代码显示规范: <http://hexo.chenall.net/post/code/>\n- Oracle现在真是恶心，下载个Java SDK还非得让登陆不可。只好再找下载地址了: <http://ghaffarian.net/downloads/>  \n- GIT文章收藏:  \n    Git分支管理策略: <http://www.ruanyifeng.com/blog/2012/07/git.html>    \n    Git查看、删除、重命名远程分支和tag: http://zengrong.net/post/1746.htm  \n- Google无障碍浏览链接: <https://github.com/greatfire/wiki>  \n- 在线Android等源码: <http://www.grepcode.com/>, <http://androidxref.com/>  \n- Twitter University: <http://www.bluemobi.cn/>  \n\n##本项目使用了\n\n- CNZZ的网站统计服务，官网:<http://cnzz.com/>\n- 友言的网友评论服务，官网:<http://www.uyan.cc/>  \n- Google 的Adsense广告，官网:<https://www.google.com/adsense/login/zh_CN/>  \n\n如需查看或管理网站统计、评论或广告，请自行注册帐号并修改_includes目录下相关文件。","slug":"faqs","published":1,"updated":"2015-06-11T04:10:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb4f002e970q5f7ggqak"},{"title":"Windows 系统常用命令","date":"2014-03-20T02:54:00.000Z","_content":"\n来自小辉哥\n\n##必备命令\n```bash\nmsinfo32,查看系统各种信息（环境变量、驱动等等）\ngpedit.msc 组策略编辑\ngpupdate /force 组策略更新 \nmstsc 远程桌面 \nmmc控制台 \nservices.msc 服务配置 \ntaskmgr 任务管理器\nregedit：注册表编辑器\ncompmgmt.msc 计算机管理\ndevmgmt.msc 设备管理\nServerManager.msc 服务器管理\ngpmc.msc组策略管理\nipconfig 查看ip地址信息\ntasklist /M \n    显示进程引用的所有dll\n\ntasklist /SVC \n    显示每个进程里的服务。配合find 命令，可以筛选指定服务的进程信息 \n    例如： tasklist /SVC | find \"AjaxCenter\"\n\nfsutil fsinfo ntfsinfo c:\n    查看文件系统信息，可知道IO block size,对程序优化也有借鉴作用。\n```\n\n##其他常用命令\n```bash\nsysdm.cpl：查看计算机属性\ndxdiag ： 查看DirectX相关信息,也可以查看内存\ndevmgmt.msc： 设备管理\nwmic diskdrive  可以看出来磁盘和大小.\nWmic logicaldisk 可以看出来磁盘和大小\nwmic volume .可以看到有几个盘，每一个盘的文件系统和剩余空间\nfsutil volume diskfree c: 每个盘的剩余空间量，其实上一个命令也可以查看的\nwmic cpu 上面显示的有位宽，最大始终频率， 生产厂商，二级缓存等信息\nwmic memorychip 查看Windows7和2003的内存属性  \nWMIC MEMLOGICAL 查看xp内存命令\nwmic bios  BIOS信息\nsysteminfo 详细系统信息，内存，显卡，处理器\nwmic  process get Caption,name,commandline | find \"red5\",可以获取进程调用命令的详细情况\nver 查看操作系统版本。\n```","source":"_posts/Windows 系统常用命令.md","raw":"title: \"Windows 系统常用命令\"\ndate: 2014-03-20 10:54\ncategory: [系统配置]\ntags: [windows]\n---\n\n来自小辉哥\n\n##必备命令\n```bash\nmsinfo32,查看系统各种信息（环境变量、驱动等等）\ngpedit.msc 组策略编辑\ngpupdate /force 组策略更新 \nmstsc 远程桌面 \nmmc控制台 \nservices.msc 服务配置 \ntaskmgr 任务管理器\nregedit：注册表编辑器\ncompmgmt.msc 计算机管理\ndevmgmt.msc 设备管理\nServerManager.msc 服务器管理\ngpmc.msc组策略管理\nipconfig 查看ip地址信息\ntasklist /M \n    显示进程引用的所有dll\n\ntasklist /SVC \n    显示每个进程里的服务。配合find 命令，可以筛选指定服务的进程信息 \n    例如： tasklist /SVC | find \"AjaxCenter\"\n\nfsutil fsinfo ntfsinfo c:\n    查看文件系统信息，可知道IO block size,对程序优化也有借鉴作用。\n```\n\n##其他常用命令\n```bash\nsysdm.cpl：查看计算机属性\ndxdiag ： 查看DirectX相关信息,也可以查看内存\ndevmgmt.msc： 设备管理\nwmic diskdrive  可以看出来磁盘和大小.\nWmic logicaldisk 可以看出来磁盘和大小\nwmic volume .可以看到有几个盘，每一个盘的文件系统和剩余空间\nfsutil volume diskfree c: 每个盘的剩余空间量，其实上一个命令也可以查看的\nwmic cpu 上面显示的有位宽，最大始终频率， 生产厂商，二级缓存等信息\nwmic memorychip 查看Windows7和2003的内存属性  \nWMIC MEMLOGICAL 查看xp内存命令\nwmic bios  BIOS信息\nsysteminfo 详细系统信息，内存，显卡，处理器\nwmic  process get Caption,name,commandline | find \"red5\",可以获取进程调用命令的详细情况\nver 查看操作系统版本。\n```","slug":"Windows 系统常用命令","published":1,"updated":"2015-06-11T08:09:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb4j002h970qlqxo3mnt"},{"title":"RestTemplate最佳实践","date":"2015-05-21T02:56:27.000Z","_content":"*什么是RestTemplate？*\n\n> RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。\n> 调用RestTemplate的默认构造函数，RestTemplate对象在底层通过使用java.net包下的实现创建HTTP 请求，可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式。\n> ClientHttpRequestFactory接口主要提供了两种实现方式\n   - 一种是SimpleClientHttpRequestFactory，使用J2SE提供的方式（既java.net包提供的方式）创建底层的Http请求连接。\n   - 一种方式是使用HttpComponentsClientHttpRequestFactory方式，底层使用HttpClient访问远程的Http服务，使用HttpClient可以配置连接池和证书等信息。\n   \n---\n\n##xml配置的方式\n\n请查看RestTemplate源码了解细节，知其然知其所以然！\n\nRestTemplate默认是使用SimpleClientHttpRequestFactory，内部是调用jdk的HttpConnection，默认超时为-1\n\n@Autowire\nRestTemplate simpleRestTemplate\n@Autowire\nRestTemplate restTemplate\n\n###基于jdk的spring的RestTemplate\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\" default-lazy-init=\"true\">\n\n    <!--方式一、使用jdk的实现-->\n    <bean id=\"ky.requestFactory\" class=\"org.springframework.http.client.SimpleClientHttpRequestFactory\">\n        <property name=\"readTimeout\" value=\"10000\"/>\n        <property name=\"connectTimeout\" value=\"5000\"/>\n    </bean>\n\n    <bean id=\"simpleRestTemplate\" class=\"org.springframework.web.client.RestTemplate\">\n        <constructor-arg ref=\"ky.requestFactory\"/>\n        <property name=\"messageConverters\">\n            <list>\n                <bean class=\"org.springframework.http.converter.FormHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                    <property name=\"supportedMediaTypes\">\n                        <list>\n                            <value>text/plain;charset=UTF-8</value>\n                        </list>\n                    </property>\n                </bean>\n            </list>\n        </property>\n    </bean>\n\n</beans>\n```\n\n###使用Httpclient连接池的方式\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\" default-lazy-init=\"true\">\n\n    <!--方式二、使用httpclient的实现，带连接池-->\n    <bean id=\"ky.pollingConnectionManager\" class=\"org.apache.http.impl.conn.PoolingHttpClientConnectionManager\">\n        <!--整个连接池的并发-->\n        <property name=\"maxTotal\" value=\"1000\" />\n        <!--每个主机的并发-->\n        <property name=\"defaultMaxPerRoute\" value=\"1000\" />\n    </bean>\n\n    <bean id=\"ky.httpClientBuilder\" class=\"org.apache.http.impl.client.HttpClientBuilder\" factory-method=\"create\">\n        <property name=\"connectionManager\" ref=\"ky.pollingConnectionManager\" />\n        <!--开启重试-->\n        <property name=\"retryHandler\">\n            <bean class=\"org.apache.http.impl.client.DefaultHttpRequestRetryHandler\">\n                <constructor-arg value=\"2\"/>\n                <constructor-arg value=\"true\"/>\n            </bean>\n        </property>\n        <property name=\"defaultHeaders\">\n            <list>\n                <bean class=\"org.apache.http.message.BasicHeader\">\n                    <constructor-arg value=\"User-Agent\"/>\n                    <constructor-arg value=\"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36\"/>\n                </bean>\n                <bean class=\"org.apache.http.message.BasicHeader\">\n                    <constructor-arg value=\"Accept-Encoding\"/>\n                    <constructor-arg value=\"gzip,deflate\"/>\n                </bean>\n                <bean class=\"org.apache.http.message.BasicHeader\">\n                    <constructor-arg value=\"Accept-Language\"/>\n                    <constructor-arg value=\"zh-CN\"/>\n                </bean>\n            </list>\n        </property>\n    </bean>\n\n    <bean id=\"ky.httpClient\" factory-bean=\"ky.httpClientBuilder\" factory-method=\"build\" />\n\n    <bean id=\"ky.clientHttpRequestFactory\" class=\"org.springframework.http.client.HttpComponentsClientHttpRequestFactory\">\n        <constructor-arg ref=\"ky.httpClient\"/>\n        <!--连接超时时间，毫秒-->\n        <property name=\"connectTimeout\" value=\"5000\"/>\n        <!--读写超时时间，毫秒-->\n        <property name=\"readTimeout\" value=\"10000\"/>\n    </bean>\n\n    <bean id=\"restTemplate\" class=\"org.springframework.web.client.RestTemplate\">\n        <constructor-arg ref=\"ky.clientHttpRequestFactory\"/>\n        <property name=\"errorHandler\">\n            <bean class=\"org.springframework.web.client.DefaultResponseErrorHandler\"/>\n        </property>\n        <property name=\"messageConverters\">\n            <list>\n                <bean class=\"org.springframework.http.converter.FormHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                    <property name=\"supportedMediaTypes\">\n                        <list>\n                            <value>text/plain;charset=UTF-8</value>\n                        </list>\n                    </property>\n                </bean>\n            </list>\n        </property>\n    </bean>\n\n</beans>\n```\n\n##bean初始化+静态工具\n\n**线程安全的单例（懒汉模式）**\n###基于jdk的spring的RestTemplate\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.http.converter.FormHttpMessageConverter;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.http.converter.StringHttpMessageConverter;\nimport org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\nimport org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.DefaultResponseErrorHandler;\nimport org.springframework.web.client.RestTemplate;\n\nimport javax.annotation.PostConstruct;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @title：基于jdk的spring的RestTemplate\n * @author：liuxing\n * @date：2015-05-18 09:35\n */\n@Component\n@Lazy(false)\npublic class SimpleRestClient {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);\n\n    private static RestTemplate restTemplate;\n\n    static {\n        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();\n        requestFactory.setReadTimeout(10000);\n        requestFactory.setConnectTimeout(5000);\n\n        // 添加转换器\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        messageConverters.add(new StringHttpMessageConverter(Charset.forName(\"UTF-8\")));\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n        messageConverters.add(new MappingJackson2HttpMessageConverter());\n\n        restTemplate = new RestTemplate(messageConverters);\n        restTemplate.setRequestFactory(requestFactory);\n        restTemplate.setErrorHandler(new DefaultResponseErrorHandler());\n\n        LOGGER.info(\"SimpleRestClient初始化完成\");\n    }\n\n    private SimpleRestClient() {\n\n    }\n\n    @PostConstruct\n    public static RestTemplate getClient() {\n        return restTemplate;\n    }\n\n}\n```\n\n###使用Httpclient连接池的方式\n\n```java\n\nimport org.apache.http.Header;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy;\nimport org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\nimport org.apache.http.message.BasicHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.http.converter.FormHttpMessageConverter;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.http.converter.StringHttpMessageConverter;\nimport org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\nimport org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.DefaultResponseErrorHandler;\nimport org.springframework.web.client.RestTemplate;\n\nimport javax.annotation.PostConstruct;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @title：使用spring的restTemplate替代httpclient工具\n * @author：liuxing\n * @date：2015-05-18 08:48\n */\n@Component\n@Lazy(false)\npublic class RestClient {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);\n\n    private static RestTemplate restTemplate;\n\n    static {\n        // 长连接保持30秒\n        PoolingHttpClientConnectionManager pollingConnectionManager = new PoolingHttpClientConnectionManager(30, TimeUnit.SECONDS);\n        pollingConnectionManager.setMaxTotal(1000);\n        pollingConnectionManager.setDefaultMaxPerRoute(1000);\n\n        HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n        httpClientBuilder.setConnectionManager(pollingConnectionManager);\n        httpClientBuilder.setRetryHandler(new DefaultHttpRequestRetryHandler(2, true));\n        httpClientBuilder.setKeepAliveStrategy(new DefaultConnectionKeepAliveStrategy());\n\n        List<Header> headers = new ArrayList<>();\n        headers.add(new BasicHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36\"));\n        headers.add(new BasicHeader(\"Accept-Encoding\", \"gzip,deflate\"));\n        headers.add(new BasicHeader(\"Accept-Language\", \"zh-CN\"));\n\n        httpClientBuilder.setDefaultHeaders(headers);\n\n        HttpClient httpClient = httpClientBuilder.build();\n\n        HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);\n        clientHttpRequestFactory.setConnectTimeout(5000);\n        clientHttpRequestFactory.setReadTimeout(10000);\n\n        // 添加转换器\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        messageConverters.add(new StringHttpMessageConverter(Charset.forName(\"UTF-8\")));\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n        messageConverters.add(new MappingJackson2HttpMessageConverter());\n\n        restTemplate = new RestTemplate(messageConverters);\n        restTemplate.setRequestFactory(clientHttpRequestFactory);\n        restTemplate.setErrorHandler(new DefaultResponseErrorHandler());\n\n        LOGGER.info(\"RestClient初始化完成\");\n    }\n\n    private RestClient() {\n\n    }\n\n    @PostConstruct\n    public static RestTemplate getClient() {\n        return restTemplate;\n    }\n\n}\n```\n\n###HttpClientUtils\n\n```java\nimport com.dooioo.commons.Strings;\nimport com.dooioo.framework.SpringContextHolder;\nimport com.dooioo.ky.cache.HttpClientResultCache;\nimport org.apache.commons.collections.MapUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\n\nimport java.util.Map;\n\n/**\n * \n * 类功能说明：httpclient工具类,基于httpclient 4.x\n * Title: HttpClientUtils.java\n * @author 刘兴\n * @date 2014-3-7 下午7:48:58\n * @version V1.0\n */\npublic class HttpClientUtils {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientUtils.class);\n\n    /**\n     * post请求\n     * @param url\n     * @param formParams\n     * @return\n     */\n    public static String doPost(String url, Map<String, String> formParams) {\n        if (MapUtils.isEmpty(formParams)) {\n            return doPost(url);\n        }\n\n        try {\n            MultiValueMap<String, String> requestEntity = new LinkedMultiValueMap<>();\n            formParams.keySet().stream().forEach(key -> requestEntity.add(key, MapUtils.getString(formParams, key, \"\")));\n            return RestClient.getClient().postForObject(url, requestEntity, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"POST请求出错：{}\", url, e);\n        }\n\n        return Strings.EMPTY;\n    }\n\n    /**\n     * post请求\n     * @param url\n     * @return\n     */\n    public static String doPost(String url) {\n        try {\n            return RestClient.getClient().postForObject(url, HttpEntity.EMPTY, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"POST请求出错：{}\", url, e);\n        }\n\n        return Strings.EMPTY;\n    }\n\n    /**\n     * get请求\n     * @param url\n     * @return\n     */\n    public static String doGet(String url) {\n        try {\n            return RestClient.getClient().getForObject(url, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"GET请求出错：{}\", url, e);\n        }\n\n        return Strings.EMPTY;\n    }\n\n}\n```\n\n##使用样例\n\napi里面可以做自动的参数匹配：\n如：http://you domainn name/test?empNo={empNo}，则下面方法的最后一个参数为数据匹配参数，会自动根据key进行查找，然后替换\n\nAPI没有声明异常，注意进行异常处理\n\n更多使用语法请查看API文档\n\n```java\nResponseEntity<List<KyArea>> result = RestClient.getClient().exchange(DIVIDE_PLATE_API, HttpMethod.GET, HttpEntity.EMPTY, new ParameterizedTypeReference<List<KyArea>>() {}, map(\"empNo\", empNo));\nList<KyArea> list = result.getBody();\n\nResponseEntity<KyArea> result = RestClient.getClient().exchange(DIVIDE_PLATE_API, HttpMethod.GET, HttpEntity.EMPTY, KyArea.class, map(\"empNo\", empNo));\nKyArea kyArea = result.getBody();\n```\n\n##更多\n\n**RestTemplate API说明和使用参考**\n\nhttp://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/RestTemplate.html\n\nhttp://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html\n\nhttp://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html\n\n**HttpClient官方示例和参数配置说明**\n\nhttp://hc.apache.org/httpcomponents-client-4.4.x/examples.html\n\nhttp://hc.apache.org/httpcomponents-client-4.4.x/tutorial/html/index.html\n\n**依赖**\n*spring 3.x以上*\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n    <version>2.5.3</version>\n</dependency>\n\n<dependency>\n    <groupId>org.codehaus.jackson</groupId>\n    <artifactId>jackson-mapper-asl</artifactId>\n    <version>1.9.13</version>\n</dependency>\n```\n\n**注意点**\n\n1.关于httpclient配置的`defaultMaxPerRoute`和`maxTotal`\n`defaultMaxPerRoute`：最大路由并发数，以主机为单位\n`maxTotal`：整个连接池的并发数\n\n例如：\n`defaultMaxPerRoute`为10，`maxTotal`为100\n假设只会访问http://www.baidu.com和http://www.google.com\n那么能同时并发到客源的只能是10，房源也是10，整个连接永远不会到100\n\n2.部分方法注意查看源码，默认构造里面会新增常用的数据转换器，spring对jackson比较情有独钟，在解析xml和json时，优先使用jackson\n\n```java\n/**\n * Create a new instance of the {@link RestTemplate} using default settings.\n * Default {@link HttpMessageConverter}s are initialized.\n */\npublic RestTemplate() {\n    this.messageConverters.add(new ByteArrayHttpMessageConverter());\n    this.messageConverters.add(new StringHttpMessageConverter());\n    this.messageConverters.add(new ResourceHttpMessageConverter());\n    this.messageConverters.add(new SourceHttpMessageConverter<Source>());\n    this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\n    if (romePresent) {\n            this.messageConverters.add(new AtomFeedHttpMessageConverter());\n            this.messageConverters.add(new RssChannelHttpMessageConverter());\n    }\n    if (jackson2XmlPresent) {\n            messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n    }\n    else if (jaxb2Present) {\n            this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());\n    }\n    if (jackson2Present) {\n            this.messageConverters.add(new MappingJackson2HttpMessageConverter());\n    }\n    else if (gsonPresent) {\n            this.messageConverters.add(new GsonHttpMessageConverter());\n    }\n}\n\n/**\n * Create a new instance of the {@link RestTemplate} based on the given {@link ClientHttpRequestFactory}.\n * @param requestFactory HTTP request factory to use\n * @see org.springframework.http.client.SimpleClientHttpRequestFactory\n * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory\n */\npublic RestTemplate(ClientHttpRequestFactory requestFactory) {\n    this();\n    setRequestFactory(requestFactory);\n}\n```\n\n再看添加转换器的方法外部添加转换器时，this.messageConverters.clear();会先清除已有的，需要注意\n\n```java\n/**\n * Create a new instance of the {@link RestTemplate} using the given list of\n * {@link HttpMessageConverter} to use\n * @param messageConverters the list of {@link HttpMessageConverter} to use\n * @since 3.2.7\n */\npublic RestTemplate(List<HttpMessageConverter<?>> messageConverters) {\n    Assert.notEmpty(messageConverters, \"'messageConverters' must not be empty\");\n    this.messageConverters.addAll(messageConverters);\n}\n\n\n/**\n * Set the message body converters to use.\n * <p>These converters are used to convert from and to HTTP requests and responses.\n */\npublic void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {\n    Assert.notEmpty(messageConverters, \"'messageConverters' must not be empty\");\n    // Take getMessageConverters() List as-is when passed in here\n    if (this.messageConverters != messageConverters) {\n            this.messageConverters.clear();\n            this.messageConverters.addAll(messageConverters);\n    }\n}\n```","source":"_posts/RestTemplate最佳实践.md","raw":"title: \"RestTemplate最佳实践\"\ndate: 2015-5-21 10:56:27\ncategory: [Java]\ntags: [RestTemplate,HttpClient,Spring]\n---\n*什么是RestTemplate？*\n\n> RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。\n> 调用RestTemplate的默认构造函数，RestTemplate对象在底层通过使用java.net包下的实现创建HTTP 请求，可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式。\n> ClientHttpRequestFactory接口主要提供了两种实现方式\n   - 一种是SimpleClientHttpRequestFactory，使用J2SE提供的方式（既java.net包提供的方式）创建底层的Http请求连接。\n   - 一种方式是使用HttpComponentsClientHttpRequestFactory方式，底层使用HttpClient访问远程的Http服务，使用HttpClient可以配置连接池和证书等信息。\n   \n---\n\n##xml配置的方式\n\n请查看RestTemplate源码了解细节，知其然知其所以然！\n\nRestTemplate默认是使用SimpleClientHttpRequestFactory，内部是调用jdk的HttpConnection，默认超时为-1\n\n@Autowire\nRestTemplate simpleRestTemplate\n@Autowire\nRestTemplate restTemplate\n\n###基于jdk的spring的RestTemplate\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\" default-lazy-init=\"true\">\n\n    <!--方式一、使用jdk的实现-->\n    <bean id=\"ky.requestFactory\" class=\"org.springframework.http.client.SimpleClientHttpRequestFactory\">\n        <property name=\"readTimeout\" value=\"10000\"/>\n        <property name=\"connectTimeout\" value=\"5000\"/>\n    </bean>\n\n    <bean id=\"simpleRestTemplate\" class=\"org.springframework.web.client.RestTemplate\">\n        <constructor-arg ref=\"ky.requestFactory\"/>\n        <property name=\"messageConverters\">\n            <list>\n                <bean class=\"org.springframework.http.converter.FormHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                    <property name=\"supportedMediaTypes\">\n                        <list>\n                            <value>text/plain;charset=UTF-8</value>\n                        </list>\n                    </property>\n                </bean>\n            </list>\n        </property>\n    </bean>\n\n</beans>\n```\n\n###使用Httpclient连接池的方式\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\" default-lazy-init=\"true\">\n\n    <!--方式二、使用httpclient的实现，带连接池-->\n    <bean id=\"ky.pollingConnectionManager\" class=\"org.apache.http.impl.conn.PoolingHttpClientConnectionManager\">\n        <!--整个连接池的并发-->\n        <property name=\"maxTotal\" value=\"1000\" />\n        <!--每个主机的并发-->\n        <property name=\"defaultMaxPerRoute\" value=\"1000\" />\n    </bean>\n\n    <bean id=\"ky.httpClientBuilder\" class=\"org.apache.http.impl.client.HttpClientBuilder\" factory-method=\"create\">\n        <property name=\"connectionManager\" ref=\"ky.pollingConnectionManager\" />\n        <!--开启重试-->\n        <property name=\"retryHandler\">\n            <bean class=\"org.apache.http.impl.client.DefaultHttpRequestRetryHandler\">\n                <constructor-arg value=\"2\"/>\n                <constructor-arg value=\"true\"/>\n            </bean>\n        </property>\n        <property name=\"defaultHeaders\">\n            <list>\n                <bean class=\"org.apache.http.message.BasicHeader\">\n                    <constructor-arg value=\"User-Agent\"/>\n                    <constructor-arg value=\"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36\"/>\n                </bean>\n                <bean class=\"org.apache.http.message.BasicHeader\">\n                    <constructor-arg value=\"Accept-Encoding\"/>\n                    <constructor-arg value=\"gzip,deflate\"/>\n                </bean>\n                <bean class=\"org.apache.http.message.BasicHeader\">\n                    <constructor-arg value=\"Accept-Language\"/>\n                    <constructor-arg value=\"zh-CN\"/>\n                </bean>\n            </list>\n        </property>\n    </bean>\n\n    <bean id=\"ky.httpClient\" factory-bean=\"ky.httpClientBuilder\" factory-method=\"build\" />\n\n    <bean id=\"ky.clientHttpRequestFactory\" class=\"org.springframework.http.client.HttpComponentsClientHttpRequestFactory\">\n        <constructor-arg ref=\"ky.httpClient\"/>\n        <!--连接超时时间，毫秒-->\n        <property name=\"connectTimeout\" value=\"5000\"/>\n        <!--读写超时时间，毫秒-->\n        <property name=\"readTimeout\" value=\"10000\"/>\n    </bean>\n\n    <bean id=\"restTemplate\" class=\"org.springframework.web.client.RestTemplate\">\n        <constructor-arg ref=\"ky.clientHttpRequestFactory\"/>\n        <property name=\"errorHandler\">\n            <bean class=\"org.springframework.web.client.DefaultResponseErrorHandler\"/>\n        </property>\n        <property name=\"messageConverters\">\n            <list>\n                <bean class=\"org.springframework.http.converter.FormHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/>\n                <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                    <property name=\"supportedMediaTypes\">\n                        <list>\n                            <value>text/plain;charset=UTF-8</value>\n                        </list>\n                    </property>\n                </bean>\n            </list>\n        </property>\n    </bean>\n\n</beans>\n```\n\n##bean初始化+静态工具\n\n**线程安全的单例（懒汉模式）**\n###基于jdk的spring的RestTemplate\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.http.converter.FormHttpMessageConverter;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.http.converter.StringHttpMessageConverter;\nimport org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\nimport org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.DefaultResponseErrorHandler;\nimport org.springframework.web.client.RestTemplate;\n\nimport javax.annotation.PostConstruct;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @title：基于jdk的spring的RestTemplate\n * @author：liuxing\n * @date：2015-05-18 09:35\n */\n@Component\n@Lazy(false)\npublic class SimpleRestClient {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);\n\n    private static RestTemplate restTemplate;\n\n    static {\n        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();\n        requestFactory.setReadTimeout(10000);\n        requestFactory.setConnectTimeout(5000);\n\n        // 添加转换器\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        messageConverters.add(new StringHttpMessageConverter(Charset.forName(\"UTF-8\")));\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n        messageConverters.add(new MappingJackson2HttpMessageConverter());\n\n        restTemplate = new RestTemplate(messageConverters);\n        restTemplate.setRequestFactory(requestFactory);\n        restTemplate.setErrorHandler(new DefaultResponseErrorHandler());\n\n        LOGGER.info(\"SimpleRestClient初始化完成\");\n    }\n\n    private SimpleRestClient() {\n\n    }\n\n    @PostConstruct\n    public static RestTemplate getClient() {\n        return restTemplate;\n    }\n\n}\n```\n\n###使用Httpclient连接池的方式\n\n```java\n\nimport org.apache.http.Header;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy;\nimport org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\nimport org.apache.http.message.BasicHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.http.converter.FormHttpMessageConverter;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.http.converter.StringHttpMessageConverter;\nimport org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\nimport org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.DefaultResponseErrorHandler;\nimport org.springframework.web.client.RestTemplate;\n\nimport javax.annotation.PostConstruct;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @title：使用spring的restTemplate替代httpclient工具\n * @author：liuxing\n * @date：2015-05-18 08:48\n */\n@Component\n@Lazy(false)\npublic class RestClient {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);\n\n    private static RestTemplate restTemplate;\n\n    static {\n        // 长连接保持30秒\n        PoolingHttpClientConnectionManager pollingConnectionManager = new PoolingHttpClientConnectionManager(30, TimeUnit.SECONDS);\n        pollingConnectionManager.setMaxTotal(1000);\n        pollingConnectionManager.setDefaultMaxPerRoute(1000);\n\n        HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n        httpClientBuilder.setConnectionManager(pollingConnectionManager);\n        httpClientBuilder.setRetryHandler(new DefaultHttpRequestRetryHandler(2, true));\n        httpClientBuilder.setKeepAliveStrategy(new DefaultConnectionKeepAliveStrategy());\n\n        List<Header> headers = new ArrayList<>();\n        headers.add(new BasicHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36\"));\n        headers.add(new BasicHeader(\"Accept-Encoding\", \"gzip,deflate\"));\n        headers.add(new BasicHeader(\"Accept-Language\", \"zh-CN\"));\n\n        httpClientBuilder.setDefaultHeaders(headers);\n\n        HttpClient httpClient = httpClientBuilder.build();\n\n        HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);\n        clientHttpRequestFactory.setConnectTimeout(5000);\n        clientHttpRequestFactory.setReadTimeout(10000);\n\n        // 添加转换器\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        messageConverters.add(new StringHttpMessageConverter(Charset.forName(\"UTF-8\")));\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n        messageConverters.add(new MappingJackson2HttpMessageConverter());\n\n        restTemplate = new RestTemplate(messageConverters);\n        restTemplate.setRequestFactory(clientHttpRequestFactory);\n        restTemplate.setErrorHandler(new DefaultResponseErrorHandler());\n\n        LOGGER.info(\"RestClient初始化完成\");\n    }\n\n    private RestClient() {\n\n    }\n\n    @PostConstruct\n    public static RestTemplate getClient() {\n        return restTemplate;\n    }\n\n}\n```\n\n###HttpClientUtils\n\n```java\nimport com.dooioo.commons.Strings;\nimport com.dooioo.framework.SpringContextHolder;\nimport com.dooioo.ky.cache.HttpClientResultCache;\nimport org.apache.commons.collections.MapUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\n\nimport java.util.Map;\n\n/**\n * \n * 类功能说明：httpclient工具类,基于httpclient 4.x\n * Title: HttpClientUtils.java\n * @author 刘兴\n * @date 2014-3-7 下午7:48:58\n * @version V1.0\n */\npublic class HttpClientUtils {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientUtils.class);\n\n    /**\n     * post请求\n     * @param url\n     * @param formParams\n     * @return\n     */\n    public static String doPost(String url, Map<String, String> formParams) {\n        if (MapUtils.isEmpty(formParams)) {\n            return doPost(url);\n        }\n\n        try {\n            MultiValueMap<String, String> requestEntity = new LinkedMultiValueMap<>();\n            formParams.keySet().stream().forEach(key -> requestEntity.add(key, MapUtils.getString(formParams, key, \"\")));\n            return RestClient.getClient().postForObject(url, requestEntity, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"POST请求出错：{}\", url, e);\n        }\n\n        return Strings.EMPTY;\n    }\n\n    /**\n     * post请求\n     * @param url\n     * @return\n     */\n    public static String doPost(String url) {\n        try {\n            return RestClient.getClient().postForObject(url, HttpEntity.EMPTY, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"POST请求出错：{}\", url, e);\n        }\n\n        return Strings.EMPTY;\n    }\n\n    /**\n     * get请求\n     * @param url\n     * @return\n     */\n    public static String doGet(String url) {\n        try {\n            return RestClient.getClient().getForObject(url, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"GET请求出错：{}\", url, e);\n        }\n\n        return Strings.EMPTY;\n    }\n\n}\n```\n\n##使用样例\n\napi里面可以做自动的参数匹配：\n如：http://you domainn name/test?empNo={empNo}，则下面方法的最后一个参数为数据匹配参数，会自动根据key进行查找，然后替换\n\nAPI没有声明异常，注意进行异常处理\n\n更多使用语法请查看API文档\n\n```java\nResponseEntity<List<KyArea>> result = RestClient.getClient().exchange(DIVIDE_PLATE_API, HttpMethod.GET, HttpEntity.EMPTY, new ParameterizedTypeReference<List<KyArea>>() {}, map(\"empNo\", empNo));\nList<KyArea> list = result.getBody();\n\nResponseEntity<KyArea> result = RestClient.getClient().exchange(DIVIDE_PLATE_API, HttpMethod.GET, HttpEntity.EMPTY, KyArea.class, map(\"empNo\", empNo));\nKyArea kyArea = result.getBody();\n```\n\n##更多\n\n**RestTemplate API说明和使用参考**\n\nhttp://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/RestTemplate.html\n\nhttp://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html\n\nhttp://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html\n\n**HttpClient官方示例和参数配置说明**\n\nhttp://hc.apache.org/httpcomponents-client-4.4.x/examples.html\n\nhttp://hc.apache.org/httpcomponents-client-4.4.x/tutorial/html/index.html\n\n**依赖**\n*spring 3.x以上*\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n    <version>2.5.3</version>\n</dependency>\n\n<dependency>\n    <groupId>org.codehaus.jackson</groupId>\n    <artifactId>jackson-mapper-asl</artifactId>\n    <version>1.9.13</version>\n</dependency>\n```\n\n**注意点**\n\n1.关于httpclient配置的`defaultMaxPerRoute`和`maxTotal`\n`defaultMaxPerRoute`：最大路由并发数，以主机为单位\n`maxTotal`：整个连接池的并发数\n\n例如：\n`defaultMaxPerRoute`为10，`maxTotal`为100\n假设只会访问http://www.baidu.com和http://www.google.com\n那么能同时并发到客源的只能是10，房源也是10，整个连接永远不会到100\n\n2.部分方法注意查看源码，默认构造里面会新增常用的数据转换器，spring对jackson比较情有独钟，在解析xml和json时，优先使用jackson\n\n```java\n/**\n * Create a new instance of the {@link RestTemplate} using default settings.\n * Default {@link HttpMessageConverter}s are initialized.\n */\npublic RestTemplate() {\n    this.messageConverters.add(new ByteArrayHttpMessageConverter());\n    this.messageConverters.add(new StringHttpMessageConverter());\n    this.messageConverters.add(new ResourceHttpMessageConverter());\n    this.messageConverters.add(new SourceHttpMessageConverter<Source>());\n    this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\n    if (romePresent) {\n            this.messageConverters.add(new AtomFeedHttpMessageConverter());\n            this.messageConverters.add(new RssChannelHttpMessageConverter());\n    }\n    if (jackson2XmlPresent) {\n            messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n    }\n    else if (jaxb2Present) {\n            this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());\n    }\n    if (jackson2Present) {\n            this.messageConverters.add(new MappingJackson2HttpMessageConverter());\n    }\n    else if (gsonPresent) {\n            this.messageConverters.add(new GsonHttpMessageConverter());\n    }\n}\n\n/**\n * Create a new instance of the {@link RestTemplate} based on the given {@link ClientHttpRequestFactory}.\n * @param requestFactory HTTP request factory to use\n * @see org.springframework.http.client.SimpleClientHttpRequestFactory\n * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory\n */\npublic RestTemplate(ClientHttpRequestFactory requestFactory) {\n    this();\n    setRequestFactory(requestFactory);\n}\n```\n\n再看添加转换器的方法外部添加转换器时，this.messageConverters.clear();会先清除已有的，需要注意\n\n```java\n/**\n * Create a new instance of the {@link RestTemplate} using the given list of\n * {@link HttpMessageConverter} to use\n * @param messageConverters the list of {@link HttpMessageConverter} to use\n * @since 3.2.7\n */\npublic RestTemplate(List<HttpMessageConverter<?>> messageConverters) {\n    Assert.notEmpty(messageConverters, \"'messageConverters' must not be empty\");\n    this.messageConverters.addAll(messageConverters);\n}\n\n\n/**\n * Set the message body converters to use.\n * <p>These converters are used to convert from and to HTTP requests and responses.\n */\npublic void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {\n    Assert.notEmpty(messageConverters, \"'messageConverters' must not be empty\");\n    // Take getMessageConverters() List as-is when passed in here\n    if (this.messageConverters != messageConverters) {\n            this.messageConverters.clear();\n            this.messageConverters.addAll(messageConverters);\n    }\n}\n```","slug":"RestTemplate最佳实践","published":1,"updated":"2015-06-11T21:44:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb4m002k970qp3wporot"},{"title":"Java7 Try-with-resources (TWR)","date":"2014-09-25T05:45:49.000Z","_content":"\n转自《Java程序员修炼之道》\n\n使用Java7的Try-with-resources来自动关闭资源\n\n这个修改说起来容易，但其实暗藏玄机，最终证明做起来比最初预想的要难。其基本设想是把资源（比如文件或类似的东西）的作用域限定在代码块内，当程序离开这个代码块时，资源会被自动关闭。\n\n这是一项非常重要的改进，因为没人能在手动关闭资源时做到100%正确，甚至不久前Sun提供的操作指南都是错的。在向Coin项目提交这一提案时，提交者宣称JDK中有三分之二的close()用法都有bug，真是不可思议！\n\n好在编译器可以生成这种学究化、公式化且手工编写易犯错的代码，所以Java 7借助了编译器来实现这项改进。\n\n这可以减少我们编写错误代码的几率。相比之下，想想你用Java 6写段代码，要从一个URL（url）中读取字节流，并把读取到的内容写入到文件（out）中，这么做很容易产生错误。以下代码是可行方案之一。\n\n\n**Java 6中的资源管理语法**\n\n```java\nInputStream is = null;\ntry {\n  is = url.openStream();\n  OutputStream out = new FileOutputStream(file);\n  try {\n    byte[] buf = new byte[4096];\n    int len;\n    while ((len = is.read(buf)) >= 0)\n      out.write(buf, 0, len);\n   } catch (IOException iox) {               // 处理异常（能读或写）\n   } finally {\n     try {\n       out.close();\n      } catch (IOException closeOutx) {      // 遇到异常也做不了什么\n      }\n   }\n } catch (FileNotFoundException fnfx) {      // 处理异常\n } catch (IOException openx) {               // 处理异常\n } finally {\n    try {\n      if (is != null) is.close();\n    } catch (IOException closeInx) {         // 遇到异常也做不了什么\n    }\n }\n```\n\n看明白了吗？重点是在处理外部资源时，墨菲定律（任何事都可能出错）一定会生效，比如：\n\n- URL中的InputStream无法打开，不能读取或无法正常关闭；\n- OutputStream对应的File无法打开，无法写入或不能正常关闭；\n- 上面的问题同时出现。\n\n\n最后一种情况是最让人头疼的——异常的各种组合拳打出来令人难以招架。\n\n新语法能大大减少错误发生的可能性，这正是它受欢迎的主要原因。编译器不会犯开发人员编写代码时易犯的错误。\n\n让我们看看代码清单1-3中的代码用Java 7写出来什么样。和前面一样，url是一个指向下载目标文件的URL对象，file是一个保存下载数据的File对象。\n\n\n**Java 7中的资源管理语法**\n\n```java\ntry (OutputStream out = new FileOutputStream(file);\n     InputStream is = url.openStream() ) {\n  byte[] buf = new byte[4096];\n  int  len;\n  while ((len = is.read(buf)) > 0) {\n    out.write(buf, 0, len);\n  }\n}\n```\n\n这是资源自动化管理代码块的基本形式——把资源放在try的圆括号内。C#程序员看到这个也许会觉得有点眼熟，是的，它的确很像C#中的从句，带着这种理解使用这个新特性是个不错的起点。在这段代码块中使用的资源在处理完成后会自动关闭。\n\n但使用try-with-resources特性时还是要小心，因为在某些情况下资源可能无法关闭。比如在下面的代码中，如果从文件（someFile.bin）创建ObjectInputStream时出错，FileInputStream可能就无法正确关闭。\n\n```java\ntry ( ObjectInputStream in = new ObjectInputStream(new\n      FileInputStream(\"someFile.bin\")) ) { \n      ...\n}\n```\n\n假定文件（someFile.bin）存在，但可能不是ObjectInput类型的文件，所以文件无法正确打开。因此不能构建ObjectInputStream，所以FileInputStream也没办法关闭。\n\n要确保try-with-resources生效，正确的用法是为各个资源声明独立变量。\n\n```java\ntry ( FileInputStream fin = new FileInputStream(\"someFile.bin\");\n          ObjectInputStream in = new ObjectInputStream(fin) ) {\n    ...\n}\n```\n\nTWR的另一个好处是改善了错误跟踪的能力，能够更准确地跟踪堆栈中的异常。在Java 7之前，处理资源时抛出的异常信息经常会被覆盖。TWR中可能也会出现这种情况，因此Java 7对跟踪堆栈进行了改进，现在开发人员能看到可能会丢失的异常类型信息。\n\n\n比如在下面这段代码中，有一个返回InputStream的值为null的方法：\n\n```java\n try(InputStream i = getNullStream()) {\n   i.available();\n}\n```\n\n在改进后的跟踪堆栈中能看到提示，注意其中被抑制的NullPointerException（简称NPE）：\n\n```java\nException in thread \"main\" java.lang.NullPointerException \n  at wgjd.ch01.ScratchSuprExcep.run(ScratchSuprExcep.java:23)\n  at wgjd.ch01.ScratchSuprExcep.main(ScratchSuprExcep.java:39)\n  Suppressed:java.lang.NullPointerException \n  at wgjd.ch01.ScratchSuprExcep.run(ScratchSuprExcep.java:24)   \n    1 more\n```\n\n**TWR与AutoCloseable**\n\n目前TWR特性依靠一个新定义的接口实现AutoCloseable。TWR的try从句中出现的资源类都必须实现这个接口。Java 7平台中的大多数资源类都被修改过，已经实现了AutoCloseable（Java 7中还定义了其父接口Closeable），但并不是全部资源相关的类都采用了这项新技术。不过，JDBC 4.1已经具备了这个特性。\n\n\n然而在你自己的代码里，在需要处理资源时一定要用TWR，从而避免在异常处理时出现bug。\n\n希望你能尽快使用try-with-resources，把那些多余的bug从代码库中赶走。\n\n\n![xiulianzhidao](/images/xiulianzhidao.png)","source":"_posts/Java7 Try-with-resources (TWR).md","raw":"title: \"Java7 Try-with-resources (TWR)\"\ndate: 2014-9-25 13:45:49\ncategory: [书摘]\ntags: [TWR,Java7]\n---\n\n转自《Java程序员修炼之道》\n\n使用Java7的Try-with-resources来自动关闭资源\n\n这个修改说起来容易，但其实暗藏玄机，最终证明做起来比最初预想的要难。其基本设想是把资源（比如文件或类似的东西）的作用域限定在代码块内，当程序离开这个代码块时，资源会被自动关闭。\n\n这是一项非常重要的改进，因为没人能在手动关闭资源时做到100%正确，甚至不久前Sun提供的操作指南都是错的。在向Coin项目提交这一提案时，提交者宣称JDK中有三分之二的close()用法都有bug，真是不可思议！\n\n好在编译器可以生成这种学究化、公式化且手工编写易犯错的代码，所以Java 7借助了编译器来实现这项改进。\n\n这可以减少我们编写错误代码的几率。相比之下，想想你用Java 6写段代码，要从一个URL（url）中读取字节流，并把读取到的内容写入到文件（out）中，这么做很容易产生错误。以下代码是可行方案之一。\n\n\n**Java 6中的资源管理语法**\n\n```java\nInputStream is = null;\ntry {\n  is = url.openStream();\n  OutputStream out = new FileOutputStream(file);\n  try {\n    byte[] buf = new byte[4096];\n    int len;\n    while ((len = is.read(buf)) >= 0)\n      out.write(buf, 0, len);\n   } catch (IOException iox) {               // 处理异常（能读或写）\n   } finally {\n     try {\n       out.close();\n      } catch (IOException closeOutx) {      // 遇到异常也做不了什么\n      }\n   }\n } catch (FileNotFoundException fnfx) {      // 处理异常\n } catch (IOException openx) {               // 处理异常\n } finally {\n    try {\n      if (is != null) is.close();\n    } catch (IOException closeInx) {         // 遇到异常也做不了什么\n    }\n }\n```\n\n看明白了吗？重点是在处理外部资源时，墨菲定律（任何事都可能出错）一定会生效，比如：\n\n- URL中的InputStream无法打开，不能读取或无法正常关闭；\n- OutputStream对应的File无法打开，无法写入或不能正常关闭；\n- 上面的问题同时出现。\n\n\n最后一种情况是最让人头疼的——异常的各种组合拳打出来令人难以招架。\n\n新语法能大大减少错误发生的可能性，这正是它受欢迎的主要原因。编译器不会犯开发人员编写代码时易犯的错误。\n\n让我们看看代码清单1-3中的代码用Java 7写出来什么样。和前面一样，url是一个指向下载目标文件的URL对象，file是一个保存下载数据的File对象。\n\n\n**Java 7中的资源管理语法**\n\n```java\ntry (OutputStream out = new FileOutputStream(file);\n     InputStream is = url.openStream() ) {\n  byte[] buf = new byte[4096];\n  int  len;\n  while ((len = is.read(buf)) > 0) {\n    out.write(buf, 0, len);\n  }\n}\n```\n\n这是资源自动化管理代码块的基本形式——把资源放在try的圆括号内。C#程序员看到这个也许会觉得有点眼熟，是的，它的确很像C#中的从句，带着这种理解使用这个新特性是个不错的起点。在这段代码块中使用的资源在处理完成后会自动关闭。\n\n但使用try-with-resources特性时还是要小心，因为在某些情况下资源可能无法关闭。比如在下面的代码中，如果从文件（someFile.bin）创建ObjectInputStream时出错，FileInputStream可能就无法正确关闭。\n\n```java\ntry ( ObjectInputStream in = new ObjectInputStream(new\n      FileInputStream(\"someFile.bin\")) ) { \n      ...\n}\n```\n\n假定文件（someFile.bin）存在，但可能不是ObjectInput类型的文件，所以文件无法正确打开。因此不能构建ObjectInputStream，所以FileInputStream也没办法关闭。\n\n要确保try-with-resources生效，正确的用法是为各个资源声明独立变量。\n\n```java\ntry ( FileInputStream fin = new FileInputStream(\"someFile.bin\");\n          ObjectInputStream in = new ObjectInputStream(fin) ) {\n    ...\n}\n```\n\nTWR的另一个好处是改善了错误跟踪的能力，能够更准确地跟踪堆栈中的异常。在Java 7之前，处理资源时抛出的异常信息经常会被覆盖。TWR中可能也会出现这种情况，因此Java 7对跟踪堆栈进行了改进，现在开发人员能看到可能会丢失的异常类型信息。\n\n\n比如在下面这段代码中，有一个返回InputStream的值为null的方法：\n\n```java\n try(InputStream i = getNullStream()) {\n   i.available();\n}\n```\n\n在改进后的跟踪堆栈中能看到提示，注意其中被抑制的NullPointerException（简称NPE）：\n\n```java\nException in thread \"main\" java.lang.NullPointerException \n  at wgjd.ch01.ScratchSuprExcep.run(ScratchSuprExcep.java:23)\n  at wgjd.ch01.ScratchSuprExcep.main(ScratchSuprExcep.java:39)\n  Suppressed:java.lang.NullPointerException \n  at wgjd.ch01.ScratchSuprExcep.run(ScratchSuprExcep.java:24)   \n    1 more\n```\n\n**TWR与AutoCloseable**\n\n目前TWR特性依靠一个新定义的接口实现AutoCloseable。TWR的try从句中出现的资源类都必须实现这个接口。Java 7平台中的大多数资源类都被修改过，已经实现了AutoCloseable（Java 7中还定义了其父接口Closeable），但并不是全部资源相关的类都采用了这项新技术。不过，JDBC 4.1已经具备了这个特性。\n\n\n然而在你自己的代码里，在需要处理资源时一定要用TWR，从而避免在异常处理时出现bug。\n\n希望你能尽快使用try-with-resources，把那些多余的bug从代码库中赶走。\n\n\n![xiulianzhidao](/images/xiulianzhidao.png)","slug":"Java7 Try-with-resources (TWR)","published":1,"updated":"2015-06-11T19:41:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb4p002s970qtawbh1ru"},{"title":"JS Hash对象","date":"2012-09-07T16:23:00.000Z","_content":"引用：http://blog.csdn.net/cheng5128/article/details/5072385\n\n```javascript\n/*\n * 哈希对象\n * \n * empty \t\t\t清空hash。\n * contains \t\t检测hash是否包含此键值对，参数为key\n * put \t\t\t\t向hash增加一个键值对，参数两个，key与value\n * get \t\t\t\t根据key取得相应的value\n * remove \t\t根据key移除相应的键值对，返回修改后的hash\n * pop \t\t\t\t根据key移除相应的键值对，返回被移除的value\n * keys \t\t\t取得所有的键，以数组形式返回\n * values \t\t\t取得所有的值，以数组形式返回\n * items \t\t\t取得所有的键值对，以数组形式返回\n * toObject \t\t变成普通对象\n * ensure \t\t仅当此键不存在时才添加新的键值对\n * forEach或each \t类似Array.forEach，迭代执行传入函数\n * map \t\t\t\t类似Array.map，迭代执行传入函数，把执行结果放到一个新hash返回\n * filter \t\t\t类似Array.filter，迭代执行传入函数，把符合条件的键值对放到一个新hash返回\n * toString \t\t没什么好说的\n */\n\nvar Hash = function(obj) {\n    if (obj instanceof arguments.callee) return obj;\n    return new arguments.callee.fn.init(arguments);\n};\nHash.fn = Hash.prototype = {\n    init: function(obj) {\n        var key = obj[0],\n        value = obj[1],\n        core = {},\n        toString = Object.prototype.toString,\n        i = 0;\n        if (obj.length === 2) { //如果有两个参数\n            core[key] = value;\n        } else {\n            if (toString.call(key) === '[object String]') {\n                key = key.replace(/^\\s+|\\s+$/g, \"\"); //进行trim操作\n                var arr = key.indexOf(\",\") !== -1 ? key.split(\",\") : key.split(/\\s+/g);\n                while ((value = arr[i++])) core[value] = arr[i++];\n            } else if (toString.call(key) === '[object Array]') {\n                for (var i = 0, n = key.length; i < n; i++) core[i] = key[i]\n            } else {\n                core = key;\n            }\n        };\n        this.empty();\n        if (core) this.update(core);\n    },\n    empty: function() {\n        this._hash = {};\n        this.length = 0;\n        return this;\n    },\n    //用于初始化hash\n    //把普通对象的键值利用put方法传入_hash中,不考虑其prototype的成员\n    update: function(obj) {\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) this.put(prop, obj[prop]);\n        return this;\n    },\n    contains: function(key) {\n        return this.get(key) !== void(0);\n    },\n    put: function(key, value) {\n        if (!this.contains(key)) { //如果没包含则\n            this.length++;\n        }\n        this._hash[key] = value;\n        return value;\n    },\n    //取得相应的值\n    get: function(key) {\n        return this._hash[key];\n    },\n    //移除一个键值对\n    remove: function(key) {\n        delete this._hash[key];\n        this.length--;\n        return this;\n    },\n    //移除指定的键值对，并返回对应的值\n    pop: function(key) {\n        var results = this.get(key);\n        this.remove(key);\n        return results;\n    },\n    //取得所有的键，以数组形式返回\n    keys: function() {\n        var keys = [],\n        obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) keys.push(prop);\n        return keys;\n    },\n    //取得所有的值，以数组形式返回\n    values: function() {\n        var values = [],\n        obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) values.push(obj[prop]);\n        return values;\n    },\n    //取得所有的键值对，以数组形式返回\n    items: function() {\n        var items = [],\n        obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) items.push([prop, obj[prop]]);\n        return items;\n    },\n    //变成普通对象\n    toObject: function() {\n        return this._hash;\n    },\n    //仅当此键不存在时才添加，\n    ensure: function(key, value) {\n        var results = this.get(key);\n        if (results === void(0)) return this.put(key, value);\n        return results;\n    },\n    forEach: function(fn, bind) {\n        var pairs = this.items();\n        for (var i = 0, n = pairs.length; i < n; i++) {\n            fn.call(bind, pairs[i][1], pairs[i][0]);\n        }\n    },\n    map: function(fn, bind) {\n        var results = hash({});\n        this.each(function(value, key) {\n            results.put(key, fn.call(bind, value, key));\n        });\n        return results;\n    },\n    filter: function(fn, bind) {\n        var results = hash({});\n        this.each(function(value, key) {\n            if (fn.call(bind, value, key)) results.put(key, value);\n        });\n        return results;\n    },\n    index: function(val) { //与get方法相反，取得其key\n        var obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop) && obj[prop] === val) return prop;\n        return null;\n    },\n    toString: function() {\n        var pairs = this.items(),\n        results = [];\n        for (var i = 0, n = pairs.length; i < n; i++) {\n            results[i] = pairs[i][0] + \":\" + pairs[i][1]\n        }\n        return \"{ \" + results.join(\", \") + \" }\";\n    },\n    each: this.forEach\n};\nHash.fn.init.prototype = Hash.fn;\n```","source":"_posts/JS Hash对象.md","raw":"title: \"JS Hash对象\"\ndate: 2012-09-08 00:23\ncategory: [前端]\ntags: [js]\n---\n引用：http://blog.csdn.net/cheng5128/article/details/5072385\n\n```javascript\n/*\n * 哈希对象\n * \n * empty \t\t\t清空hash。\n * contains \t\t检测hash是否包含此键值对，参数为key\n * put \t\t\t\t向hash增加一个键值对，参数两个，key与value\n * get \t\t\t\t根据key取得相应的value\n * remove \t\t根据key移除相应的键值对，返回修改后的hash\n * pop \t\t\t\t根据key移除相应的键值对，返回被移除的value\n * keys \t\t\t取得所有的键，以数组形式返回\n * values \t\t\t取得所有的值，以数组形式返回\n * items \t\t\t取得所有的键值对，以数组形式返回\n * toObject \t\t变成普通对象\n * ensure \t\t仅当此键不存在时才添加新的键值对\n * forEach或each \t类似Array.forEach，迭代执行传入函数\n * map \t\t\t\t类似Array.map，迭代执行传入函数，把执行结果放到一个新hash返回\n * filter \t\t\t类似Array.filter，迭代执行传入函数，把符合条件的键值对放到一个新hash返回\n * toString \t\t没什么好说的\n */\n\nvar Hash = function(obj) {\n    if (obj instanceof arguments.callee) return obj;\n    return new arguments.callee.fn.init(arguments);\n};\nHash.fn = Hash.prototype = {\n    init: function(obj) {\n        var key = obj[0],\n        value = obj[1],\n        core = {},\n        toString = Object.prototype.toString,\n        i = 0;\n        if (obj.length === 2) { //如果有两个参数\n            core[key] = value;\n        } else {\n            if (toString.call(key) === '[object String]') {\n                key = key.replace(/^\\s+|\\s+$/g, \"\"); //进行trim操作\n                var arr = key.indexOf(\",\") !== -1 ? key.split(\",\") : key.split(/\\s+/g);\n                while ((value = arr[i++])) core[value] = arr[i++];\n            } else if (toString.call(key) === '[object Array]') {\n                for (var i = 0, n = key.length; i < n; i++) core[i] = key[i]\n            } else {\n                core = key;\n            }\n        };\n        this.empty();\n        if (core) this.update(core);\n    },\n    empty: function() {\n        this._hash = {};\n        this.length = 0;\n        return this;\n    },\n    //用于初始化hash\n    //把普通对象的键值利用put方法传入_hash中,不考虑其prototype的成员\n    update: function(obj) {\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) this.put(prop, obj[prop]);\n        return this;\n    },\n    contains: function(key) {\n        return this.get(key) !== void(0);\n    },\n    put: function(key, value) {\n        if (!this.contains(key)) { //如果没包含则\n            this.length++;\n        }\n        this._hash[key] = value;\n        return value;\n    },\n    //取得相应的值\n    get: function(key) {\n        return this._hash[key];\n    },\n    //移除一个键值对\n    remove: function(key) {\n        delete this._hash[key];\n        this.length--;\n        return this;\n    },\n    //移除指定的键值对，并返回对应的值\n    pop: function(key) {\n        var results = this.get(key);\n        this.remove(key);\n        return results;\n    },\n    //取得所有的键，以数组形式返回\n    keys: function() {\n        var keys = [],\n        obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) keys.push(prop);\n        return keys;\n    },\n    //取得所有的值，以数组形式返回\n    values: function() {\n        var values = [],\n        obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) values.push(obj[prop]);\n        return values;\n    },\n    //取得所有的键值对，以数组形式返回\n    items: function() {\n        var items = [],\n        obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop)) items.push([prop, obj[prop]]);\n        return items;\n    },\n    //变成普通对象\n    toObject: function() {\n        return this._hash;\n    },\n    //仅当此键不存在时才添加，\n    ensure: function(key, value) {\n        var results = this.get(key);\n        if (results === void(0)) return this.put(key, value);\n        return results;\n    },\n    forEach: function(fn, bind) {\n        var pairs = this.items();\n        for (var i = 0, n = pairs.length; i < n; i++) {\n            fn.call(bind, pairs[i][1], pairs[i][0]);\n        }\n    },\n    map: function(fn, bind) {\n        var results = hash({});\n        this.each(function(value, key) {\n            results.put(key, fn.call(bind, value, key));\n        });\n        return results;\n    },\n    filter: function(fn, bind) {\n        var results = hash({});\n        this.each(function(value, key) {\n            if (fn.call(bind, value, key)) results.put(key, value);\n        });\n        return results;\n    },\n    index: function(val) { //与get方法相反，取得其key\n        var obj = this._hash;\n        for (var prop in obj) if (obj.hasOwnProperty(prop) && obj[prop] === val) return prop;\n        return null;\n    },\n    toString: function() {\n        var pairs = this.items(),\n        results = [];\n        for (var i = 0, n = pairs.length; i < n; i++) {\n            results[i] = pairs[i][0] + \":\" + pairs[i][1]\n        }\n        return \"{ \" + results.join(\", \") + \" }\";\n    },\n    each: this.forEach\n};\nHash.fn.init.prototype = Hash.fn;\n```","slug":"JS Hash对象","published":1,"updated":"2015-06-10T16:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciat8vb4r002y970q3c2s37yf"}],"PostAsset":[],"PostCategory":[{"post_id":"ciat8vb2n0006970q095d1xqv","category_id":"ciat8vb2r0007970q4ut2jelh","_id":"ciat8vb2t000a970qy9y881rx"},{"post_id":"ciat8vb2v000b970qvdbnutht","category_id":"ciat8vb2x000c970qdjs6phd4","_id":"ciat8vb2x000d970qgq5sdt8h"},{"post_id":"ciat8vb2z000e970qvjycb1hy","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb32000i970qkmltioiv"},{"post_id":"ciat8vb34000j970qeg5frpgy","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb35000k970qzj6qxoe7"},{"post_id":"ciat8vb37000m970qzp02v7nd","category_id":"ciat8vb2x000c970qdjs6phd4","_id":"ciat8vb38000n970q1pw6ojc8"},{"post_id":"ciat8vb39000o970qim873640","category_id":"ciat8vb3a000p970qyhcycsmj","_id":"ciat8vb3b000s970qofetif5z"},{"post_id":"ciat8vb3c000x970q1rt5ovg4","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb3d000y970q5oh2yae6"},{"post_id":"ciat8vb3f000z970q88ln2d62","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb3h0010970qogeh982x"},{"post_id":"ciat8vb3j0017970qfpl1llda","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb3k0018970qepf2k6j8"},{"post_id":"ciat8vb3n001d970qrja3gt48","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb3o001e970qxzuqp9pv"},{"post_id":"ciat8vb3p001h970qzp6tk0rk","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb3r001i970qki0dkyt1"},{"post_id":"ciat8vb3t001k970qxv11n1ea","category_id":"ciat8vb2x000c970qdjs6phd4","_id":"ciat8vb3v001l970q4uht8opq"},{"post_id":"ciat8vb3w001m970q2ujrrokg","category_id":"ciat8vb2r0007970q4ut2jelh","_id":"ciat8vb3x001n970q2kdllmef"},{"post_id":"ciat8vb3y001p970q2yvowl0p","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb40001q970q0mm6y4nc"},{"post_id":"ciat8vb41001s970qdnk1hpeb","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb42001t970qvl1jo74l"},{"post_id":"ciat8vb45001z970qvfd1jbm5","category_id":"ciat8vb460020970qvenkmhh9","_id":"ciat8vb470022970qdtgu2m0n"},{"post_id":"ciat8vb480023970qmvrwpfsn","category_id":"ciat8vb2r0007970q4ut2jelh","_id":"ciat8vb490024970q8be6b7hp"},{"post_id":"ciat8vb4b0027970q50c6tfz6","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb4d0028970qzwholi7j"},{"post_id":"ciat8vb4f002e970q5f7ggqak","category_id":"ciat8vb4h002f970qwg0ukxqq","_id":"ciat8vb4i002g970qmeo2nz1x"},{"post_id":"ciat8vb4j002h970qlqxo3mnt","category_id":"ciat8vb460020970qvenkmhh9","_id":"ciat8vb4l002i970qcvif3nmx"},{"post_id":"ciat8vb4m002k970qp3wporot","category_id":"ciat8vb31000f970qlqkipb3x","_id":"ciat8vb4n002l970qd14ng8uj"},{"post_id":"ciat8vb4p002s970qtawbh1ru","category_id":"ciat8vb3a000p970qyhcycsmj","_id":"ciat8vb4p002t970q2ze158nq"},{"post_id":"ciat8vb4r002y970q3c2s37yf","category_id":"ciat8vb2r0007970q4ut2jelh","_id":"ciat8vb4s002z970qrq11pgfs"}],"PostTag":[{"post_id":"ciat8vb2n0006970q095d1xqv","tag_id":"ciat8vb2r0008970qronjbbzw","_id":"ciat8vb2t0009970qmnlpmbf8"},{"post_id":"ciat8vb2z000e970qvjycb1hy","tag_id":"ciat8vb31000g970q52lbkrc9","_id":"ciat8vb32000h970q2kneg7wf"},{"post_id":"ciat8vb34000j970qeg5frpgy","tag_id":"ciat8vb31000g970q52lbkrc9","_id":"ciat8vb35000l970qeopam71h"},{"post_id":"ciat8vb39000o970qim873640","tag_id":"ciat8vb3a000q970qmrdxvx1a","_id":"ciat8vb3b000u970qe412qv8r"},{"post_id":"ciat8vb39000o970qim873640","tag_id":"ciat8vb3b000r970qygsgrr88","_id":"ciat8vb3b000v970qnux2d4cx"},{"post_id":"ciat8vb39000o970qim873640","tag_id":"ciat8vb3b000t970q9noo57p7","_id":"ciat8vb3b000w970q661vqhnv"},{"post_id":"ciat8vb3f000z970q88ln2d62","tag_id":"ciat8vb3h0011970q76m79193","_id":"ciat8vb3i0014970q0jhy45fi"},{"post_id":"ciat8vb3f000z970q88ln2d62","tag_id":"ciat8vb3h0012970qvdivngxc","_id":"ciat8vb3i0015970qsp7wqpl0"},{"post_id":"ciat8vb3f000z970q88ln2d62","tag_id":"ciat8vb3i0013970q9r46p6a0","_id":"ciat8vb3i0016970q15mduoju"},{"post_id":"ciat8vb3j0017970qfpl1llda","tag_id":"ciat8vb3k0019970qtn59bswf","_id":"ciat8vb3l001b970qlrgdbagk"},{"post_id":"ciat8vb3j0017970qfpl1llda","tag_id":"ciat8vb3l001a970q1eemj8u9","_id":"ciat8vb3l001c970qu2f7ie9w"},{"post_id":"ciat8vb3n001d970qrja3gt48","tag_id":"ciat8vb3o001f970qpuqp1ga0","_id":"ciat8vb3o001g970q4qoh9ee4"},{"post_id":"ciat8vb3p001h970qzp6tk0rk","tag_id":"ciat8vb3h0011970q76m79193","_id":"ciat8vb3r001j970ql3zkd2i2"},{"post_id":"ciat8vb3w001m970q2ujrrokg","tag_id":"ciat8vb31000g970q52lbkrc9","_id":"ciat8vb3x001o970q31bti7f5"},{"post_id":"ciat8vb3y001p970q2yvowl0p","tag_id":"ciat8vb3l001a970q1eemj8u9","_id":"ciat8vb40001r970qbwqm5yfi"},{"post_id":"ciat8vb41001s970qdnk1hpeb","tag_id":"ciat8vb3k0019970qtn59bswf","_id":"ciat8vb44001w970qh0ocbg3i"},{"post_id":"ciat8vb41001s970qdnk1hpeb","tag_id":"ciat8vb44001u970qppj6p8yu","_id":"ciat8vb44001x970q9h6icvno"},{"post_id":"ciat8vb41001s970qdnk1hpeb","tag_id":"ciat8vb44001v970q241t9u5p","_id":"ciat8vb44001y970qdl6f347b"},{"post_id":"ciat8vb45001z970qvfd1jbm5","tag_id":"ciat8vb3h0012970qvdivngxc","_id":"ciat8vb470021970qc8ndxdp5"},{"post_id":"ciat8vb480023970qmvrwpfsn","tag_id":"ciat8vb490025970qwo3bargb","_id":"ciat8vb490026970qyx1jst9q"},{"post_id":"ciat8vb4b0027970q50c6tfz6","tag_id":"ciat8vb31000g970q52lbkrc9","_id":"ciat8vb4e002b970q7v99r08n"},{"post_id":"ciat8vb4b0027970q50c6tfz6","tag_id":"ciat8vb4d0029970q8cjhganl","_id":"ciat8vb4e002c970q5n8gojr6"},{"post_id":"ciat8vb4b0027970q50c6tfz6","tag_id":"ciat8vb4e002a970qdh0sk5s1","_id":"ciat8vb4e002d970qei4lp3y7"},{"post_id":"ciat8vb4j002h970qlqxo3mnt","tag_id":"ciat8vb3i0013970q9r46p6a0","_id":"ciat8vb4l002j970qy8v2qrwh"},{"post_id":"ciat8vb4m002k970qp3wporot","tag_id":"ciat8vb4n002m970q1cnl164d","_id":"ciat8vb4o002p970qo0bnk3ed"},{"post_id":"ciat8vb4m002k970qp3wporot","tag_id":"ciat8vb4n002n970qwl8j2jgs","_id":"ciat8vb4o002q970qk8yw5rzj"},{"post_id":"ciat8vb4m002k970qp3wporot","tag_id":"ciat8vb4o002o970qt9ap0iuf","_id":"ciat8vb4o002r970qjpanmbc6"},{"post_id":"ciat8vb4p002s970qtawbh1ru","tag_id":"ciat8vb4q002u970q03g2k0i8","_id":"ciat8vb4q002w970qzcwsfj4d"},{"post_id":"ciat8vb4p002s970qtawbh1ru","tag_id":"ciat8vb4q002v970qo309cm1x","_id":"ciat8vb4q002x970qgkzn965x"},{"post_id":"ciat8vb4r002y970q3c2s37yf","tag_id":"ciat8vb2r0008970qronjbbzw","_id":"ciat8vb4s0030970qgwpyo9qa"}],"Tag":[{"name":"js","_id":"ciat8vb2r0008970qronjbbzw"},{"name":"地图","_id":"ciat8vb31000g970q52lbkrc9"},{"name":"编程","_id":"ciat8vb3a000q970qmrdxvx1a"},{"name":"心态","_id":"ciat8vb3b000r970qygsgrr88"},{"name":"职业发展","_id":"ciat8vb3b000t970q9noo57p7"},{"name":"jmagick","_id":"ciat8vb3h0011970q76m79193"},{"name":"linux","_id":"ciat8vb3h0012970qvdivngxc"},{"name":"windows","_id":"ciat8vb3i0013970q9r46p6a0"},{"name":"spring","_id":"ciat8vb3k0019970qtn59bswf"},{"name":"websocket","_id":"ciat8vb3l001a970q1eemj8u9"},{"name":"pinyin4j","_id":"ciat8vb3o001f970qpuqp1ga0"},{"name":"框架","_id":"ciat8vb44001u970qppj6p8yu"},{"name":"ibatis","_id":"ciat8vb44001v970q241t9u5p"},{"name":"jquery","_id":"ciat8vb490025970qwo3bargb"},{"name":"坐标运算","_id":"ciat8vb4d0029970q8cjhganl"},{"name":"距离","_id":"ciat8vb4e002a970qdh0sk5s1"},{"name":"RestTemplate","_id":"ciat8vb4n002m970q1cnl164d"},{"name":"HttpClient","_id":"ciat8vb4n002n970qwl8j2jgs"},{"name":"Spring","_id":"ciat8vb4o002o970qt9ap0iuf"},{"name":"TWR","_id":"ciat8vb4q002u970q03g2k0i8"},{"name":"Java7","_id":"ciat8vb4q002v970qo309cm1x"}]}}